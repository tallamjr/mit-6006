1
00:00:12,837 --> 00:00:13,670
JASON KU: I'm Jason.

2
00:00:13,670 --> 00:00:16,110
Hopefully you guys
saw me on Tuesday.

3
00:00:16,110 --> 00:00:20,900
This is our first ever
6.006 problem session

4
00:00:20,900 --> 00:00:22,910
that we'll be having
on Fridays this term.

5
00:00:22,910 --> 00:00:25,100
It's really an experiment.

6
00:00:25,100 --> 00:00:27,100
We've never done this before.

7
00:00:27,100 --> 00:00:29,600
But one of the things that we
were discussed while preparing

8
00:00:29,600 --> 00:00:34,310
for this class is that we
have two different methods

9
00:00:34,310 --> 00:00:38,300
of instruction, formally,
usually in this class--

10
00:00:38,300 --> 00:00:41,240
a lecture, which is
there to present you with

11
00:00:41,240 --> 00:00:44,630
the fundamental material,
the data structures,

12
00:00:44,630 --> 00:00:49,210
and the algorithms that are the
base, the foundation of what--

13
00:00:49,210 --> 00:00:52,740
how you will be approaching
problems in this class;

14
00:00:52,740 --> 00:00:58,440
and then the problem sets
that you will work on,

15
00:00:58,440 --> 00:01:01,310
our applications
of that material.

16
00:01:01,310 --> 00:01:04,250
But there's usually
a much different feel

17
00:01:04,250 --> 00:01:07,190
between those problems
that we'll give you then

18
00:01:07,190 --> 00:01:09,640
the underlying
foundational material.

19
00:01:09,640 --> 00:01:11,580
So the application
of that material

20
00:01:11,580 --> 00:01:12,830
will feel very different.

21
00:01:12,830 --> 00:01:14,330
And a lot of times,
there are tricks

22
00:01:14,330 --> 00:01:18,560
to approaching the problems
or ways of approaching

23
00:01:18,560 --> 00:01:21,560
the problems that
you kind of just

24
00:01:21,560 --> 00:01:23,820
have to figure out by
working on the problem,

25
00:01:23,820 --> 00:01:26,170
sometimes going to office hours.

26
00:01:26,170 --> 00:01:30,170
But what we want to
do this term was to--

27
00:01:30,170 --> 00:01:33,470
since we had the opportunity
to be recorded by OCW,

28
00:01:33,470 --> 00:01:37,520
was to record us going
through some problems

29
00:01:37,520 --> 00:01:39,620
that we've had on
problem sets in the past

30
00:01:39,620 --> 00:01:42,650
so you could see how
we would approach

31
00:01:42,650 --> 00:01:46,100
working on these problems
that you'll be working on,

32
00:01:46,100 --> 00:01:47,660
at least in a similar vein.

33
00:01:47,660 --> 00:01:50,240
So that's the goal of
these problem sessions.

34
00:01:50,240 --> 00:01:55,020
In the past, for OCW, we
have recorded a recitation,

35
00:01:55,020 --> 00:01:58,250
but we felt that that was
a little less useful to you

36
00:01:58,250 --> 00:01:59,960
guys, because
recitation is meant

37
00:01:59,960 --> 00:02:03,260
for interaction, questions--
one-on-one questions.

38
00:02:03,260 --> 00:02:05,480
We want to be a safe
space for you guys

39
00:02:05,480 --> 00:02:08,060
to interact with
the material with--

40
00:02:08,060 --> 00:02:11,570
in a smaller environment
that might not be recorded.

41
00:02:11,570 --> 00:02:14,460
So that's the goal of this--

42
00:02:14,460 --> 00:02:17,660
these sessions that we
will be doing on Fridays.

43
00:02:17,660 --> 00:02:22,080
Any questions about what
we're going to be doing today?

44
00:02:22,080 --> 00:02:22,580
OK.

45
00:02:22,580 --> 00:02:28,240
So we do have a handout up
here by the door, which we may

46
00:02:28,240 --> 00:02:29,490
or may not have in the future.

47
00:02:29,490 --> 00:02:30,990
This is all an
experiment, so you'll

48
00:02:30,990 --> 00:02:34,280
have to work with us as
we figure this stuff out.

49
00:02:34,280 --> 00:02:39,150
They were posted on LMOD about
an hour before this session.

50
00:02:39,150 --> 00:02:43,190
We'll try to keep
that as a standard.

51
00:02:43,190 --> 00:02:45,740
But it just shows
you the questions

52
00:02:45,740 --> 00:02:48,935
we'll work on today
in the session.

53
00:02:52,205 --> 00:02:55,520
It isn't just the problem
set from last term.

54
00:02:55,520 --> 00:02:57,800
It's a selection of problems
from previous terms,

55
00:02:57,800 --> 00:02:59,420
and some of them
have been edited

56
00:02:59,420 --> 00:03:02,880
to be maybe a little shorter
and things like that.

57
00:03:02,880 --> 00:03:04,340
So what we're
going to do is just

58
00:03:04,340 --> 00:03:05,810
go through the
problems one by one.

59
00:03:05,810 --> 00:03:10,370
I'll try to just show you how
I'm approaching the problems,

60
00:03:10,370 --> 00:03:12,920
but at any point, if you want
to, you can ask questions.

61
00:03:12,920 --> 00:03:13,960
That's fine.

62
00:03:13,960 --> 00:03:15,380
OK?

63
00:03:15,380 --> 00:03:18,035
All right, so the first
question we have is--

64
00:03:18,035 --> 00:03:20,870
has a setup that's
very similar to what

65
00:03:20,870 --> 00:03:23,180
you will have on your Pset1.

66
00:03:23,180 --> 00:03:28,670
It's essentially saying that
it has usually many parts.

67
00:03:28,670 --> 00:03:32,780
This has two parts, an
A part and a B part.

68
00:03:32,780 --> 00:03:35,780
I've omitted a B
and a C that that

69
00:03:35,780 --> 00:03:37,400
was on last term's problem set.

70
00:03:37,400 --> 00:03:40,940
And it has five functions
each, and you're trying

71
00:03:40,940 --> 00:03:44,540
to order them increasing as--

72
00:03:44,540 --> 00:03:46,350
based on their
asymptotic behavior.

73
00:03:46,350 --> 00:03:50,990
So here are the
functions that we have.

74
00:03:50,990 --> 00:03:52,400
Maybe I'll stick it up instead.

75
00:03:58,300 --> 00:04:01,388
All right, so we have a
few sets of functions,

76
00:04:01,388 --> 00:04:02,680
and we just want to order them.

77
00:04:02,680 --> 00:04:09,730
And some of the functions may
be asymptotically equivalent--

78
00:04:09,730 --> 00:04:12,280
in which case, when we
are ordering these things,

79
00:04:12,280 --> 00:04:14,720
we're going to put
those numbers in a set.

80
00:04:14,720 --> 00:04:19,480
So what we have as an
example are three functions--

81
00:04:19,480 --> 00:04:24,490
n, root n, and n plus root n.

82
00:04:24,490 --> 00:04:26,510
This is one, two, three.

83
00:04:26,510 --> 00:04:28,450
And what we're going
to ask you to do

84
00:04:28,450 --> 00:04:32,740
is order those functions based
on their asymptotic complexity.

85
00:04:32,740 --> 00:04:35,410
So hopefully you guys
can get this one.

86
00:04:35,410 --> 00:04:39,730
Which one's the slowest
growth in terms--

87
00:04:39,730 --> 00:04:41,410
root n, so number two.

88
00:04:41,410 --> 00:04:45,340
So if we say f of 2
will be our first one.

89
00:04:45,340 --> 00:04:48,070
And then, how about
the other two?

90
00:04:48,070 --> 00:04:49,030
STUDENT: [INAUDIBLE]

91
00:04:49,030 --> 00:04:50,155
JASON KU: They're the same.

92
00:04:50,155 --> 00:04:52,060
They're both order n.

93
00:04:52,060 --> 00:04:57,660
So we would put in set
brackets f1 and f3.

94
00:04:57,660 --> 00:05:01,420
And on your problem set, if you
put just 2, and 1, and 3 here,

95
00:05:01,420 --> 00:05:04,120
that would probably be fine.

96
00:05:04,120 --> 00:05:07,780
But if you were to
put 2 over here or not

97
00:05:07,780 --> 00:05:11,210
have these curly
braces around here,

98
00:05:11,210 --> 00:05:14,170
those would not be correct, and
you'd get points marked off.

99
00:05:14,170 --> 00:05:15,370
Does that make sense?

100
00:05:15,370 --> 00:05:20,000
OK, so we're going to approach
the first set of problems--

101
00:05:20,000 --> 00:05:22,150
first set of functions,
which is a little

102
00:05:22,150 --> 00:05:24,290
different than the
second set of functions.

103
00:05:24,290 --> 00:05:25,832
Hopefully this one's
a little easier.

104
00:05:28,130 --> 00:05:30,130
One of the common
approaches that I have

105
00:05:30,130 --> 00:05:32,650
in going through these things--

106
00:05:32,650 --> 00:05:35,260
some of these are in a
form that is hard for me

107
00:05:35,260 --> 00:05:39,430
to tell how they would
compare to other things.

108
00:05:39,430 --> 00:05:43,750
Actually, most of these
are fine, but in general--

109
00:05:43,750 --> 00:05:46,600
can anyone, just by
eyeballing, tell me

110
00:05:46,600 --> 00:05:48,340
an order that works for them?

111
00:05:51,820 --> 00:05:52,660
Yeah?

112
00:05:52,660 --> 00:05:54,460
STUDENT: OK--

113
00:05:54,460 --> 00:05:56,710
JASON KU: This is
a little difficult

114
00:05:56,710 --> 00:05:58,427
to do on the spot
with five functions.

115
00:05:58,427 --> 00:05:59,010
STUDENT: Yeah.

116
00:05:59,010 --> 00:06:00,180
A little iffy about f1.

117
00:06:00,180 --> 00:06:00,930
JASON KU: OK.

118
00:06:00,930 --> 00:06:04,370
STUDENT: But f5 is definitely
smaller than f2, which is--

119
00:06:04,370 --> 00:06:06,625
smaller than f2 which
is smaller than f4.

120
00:06:06,625 --> 00:06:08,620
And f1 in iffy.

121
00:06:08,620 --> 00:06:09,910
JASON KU: OK, great.

122
00:06:09,910 --> 00:06:10,750
That's excellent.

123
00:06:10,750 --> 00:06:16,150
So what we've got here
is, on f2, f3, and f5,

124
00:06:16,150 --> 00:06:18,460
you kind of have
this n leading term.

125
00:06:18,460 --> 00:06:24,700
If we factor an n out of that,
then we're comparing log with--

126
00:06:24,700 --> 00:06:27,940
basically, we look over here
at the polynomial function.

127
00:06:27,940 --> 00:06:32,140
This one's smallest out of
them, and then the log factor

128
00:06:32,140 --> 00:06:34,330
is smaller than a
polynomial factor.

129
00:06:34,330 --> 00:06:36,810
Log grows slower than linear.

130
00:06:36,810 --> 00:06:42,250
And so this guy is smaller
than f2 is smaller than f3.

131
00:06:42,250 --> 00:06:44,500
That's great-- that
your colleague said.

132
00:06:47,170 --> 00:06:50,080
Hopefully proved in
recitation today--

133
00:06:50,080 --> 00:07:03,340
no, Wednesday-- this nice fact,
I guess, that a is less than,

134
00:07:03,340 --> 00:07:06,820
asymptotically,
this polynomial--

135
00:07:06,820 --> 00:07:11,050
this log n to any power
is asymptotically less

136
00:07:11,050 --> 00:07:14,800
than any polynomial for
any positive a and b.

137
00:07:14,800 --> 00:07:17,170
And in particular, there's
actually a stronger thing

138
00:07:17,170 --> 00:07:20,020
you can say, which is little o.

139
00:07:20,020 --> 00:07:23,230
Did you guys talk about
little o in recitation at all?

140
00:07:23,230 --> 00:07:24,400
Probably not.

141
00:07:24,400 --> 00:07:29,930
It's kind of the same as big
O, except is big O minus theta.

142
00:07:29,930 --> 00:07:33,610
So things that are
asymptotically equivalent

143
00:07:33,610 --> 00:07:35,380
are not going to be
included in this set.

144
00:07:35,380 --> 00:07:37,330
So actually, these
things are strictly

145
00:07:37,330 --> 00:07:39,790
asymptotic-- grow
strictly asymptotically

146
00:07:39,790 --> 00:07:41,510
slower than any polynomial.

147
00:07:41,510 --> 00:07:42,680
Does that make sense?

148
00:07:42,680 --> 00:07:43,180
OK.

149
00:07:43,180 --> 00:07:49,262
So knowing this identity,
or this relation,

150
00:07:49,262 --> 00:07:50,470
can we say anything about f1?

151
00:07:54,557 --> 00:07:55,390
Maybe someone else--

152
00:07:55,390 --> 00:07:56,680
STUDENT: Any a and b, right?

153
00:07:56,680 --> 00:07:59,330
JASON KU: Any a and b--
any positive a and B--

154
00:07:59,330 --> 00:08:01,670
anyone else have a guess?

155
00:08:01,670 --> 00:08:03,530
Yeah?

156
00:08:03,530 --> 00:08:05,630
STUDENT: That f1
is less than f5--

157
00:08:05,630 --> 00:08:08,150
JASON KU: Yeah, f1 is
less than f5, right?

158
00:08:08,150 --> 00:08:10,310
Because just using that
identity, this-- sorry--

159
00:08:10,310 --> 00:08:15,560
a here that erased, stupidly,
is smaller than, say--

160
00:08:15,560 --> 00:08:23,600
this is bigger than n, and n
to the b, being 1, is bigger.

161
00:08:23,600 --> 00:08:27,600
And then, as your colleague
pointed out before,

162
00:08:27,600 --> 00:08:30,840
this thing is exponential,
so definitely higher

163
00:08:30,840 --> 00:08:31,590
than a polynomial.

164
00:08:31,590 --> 00:08:32,965
OK, so that was
very easy, right?

165
00:08:32,965 --> 00:08:36,590
So the answer here
is, if I got--

166
00:08:36,590 --> 00:08:45,320
if I remember correctly, f1,
f5, f2, f3, and then f4--

167
00:08:45,320 --> 00:08:47,710
great.

168
00:08:47,710 --> 00:08:49,480
So that one was pretty easy.

169
00:08:49,480 --> 00:08:53,360
How about b-- or d, I guess?

170
00:08:53,360 --> 00:08:53,860
Yeah?

171
00:08:53,860 --> 00:08:55,210
STUDENT: Can I just
another question--

172
00:08:55,210 --> 00:08:55,835
JASON KU: Sure.

173
00:08:55,835 --> 00:08:58,300
STUDENT: [INAUDIBLE] How would
you go about proving that?

174
00:08:58,300 --> 00:09:00,217
JASON KU: How would you
go about proving that?

175
00:09:00,217 --> 00:09:04,240
So there is a proof in your
recitation handout there.

176
00:09:04,240 --> 00:09:08,260
The method in which they proved
that in the recitation handout

177
00:09:08,260 --> 00:09:15,100
was putting the two--

178
00:09:15,100 --> 00:09:18,250
taking a ratio of
the two functions

179
00:09:18,250 --> 00:09:21,580
and taking their limit
as n goes to infinity.

180
00:09:21,580 --> 00:09:24,480
And if the top one--

181
00:09:24,480 --> 00:09:29,020
it grows arbitrarily, then
the top one would be--

182
00:09:29,020 --> 00:09:30,670
grow asymptotically faster.

183
00:09:30,670 --> 00:09:33,670
And if the it went
to 0, the bottom one

184
00:09:33,670 --> 00:09:35,530
would grow
asymptotically faster.

185
00:09:35,530 --> 00:09:37,750
And if it went to
some constant, then

186
00:09:37,750 --> 00:09:40,810
that would be
asymptotically equivalent.

187
00:09:40,810 --> 00:09:42,190
Does that make sense?

188
00:09:42,190 --> 00:09:45,580
In actuality, to make
the limit easier to take,

189
00:09:45,580 --> 00:09:49,270
we take the limit of the
logarithm of the ratio.

190
00:09:49,270 --> 00:09:50,890
It just made it easier.

191
00:09:50,890 --> 00:09:53,470
Does that makes sense?

192
00:09:53,470 --> 00:09:56,875
OK, so let's move on to b.

193
00:09:56,875 --> 00:09:59,770
b-- we have a polynomial,
and an exponential,

194
00:09:59,770 --> 00:10:02,940
and then we have these
things down here.

195
00:10:02,940 --> 00:10:06,953
What do these things
in parentheses mean?

196
00:10:06,953 --> 00:10:07,620
STUDENT: Choose.

197
00:10:07,620 --> 00:10:08,620
JASON KU: Choose, right.

198
00:10:08,620 --> 00:10:11,190
It's a binomial coefficient.

199
00:10:11,190 --> 00:10:14,040
Does anyone know the
binomial coefficient is?

200
00:10:14,040 --> 00:10:14,820
Yeah?

201
00:10:14,820 --> 00:10:16,470
Hopefully from
6.042 or something

202
00:10:16,470 --> 00:10:18,510
like that, or whatever
your competition math

203
00:10:18,510 --> 00:10:20,320
background is--

204
00:10:20,320 --> 00:10:23,490
but in general, we
have this definition.

205
00:10:23,490 --> 00:10:24,660
This thing is what?

206
00:10:24,660 --> 00:10:26,370
Does anyone remember?

207
00:10:26,370 --> 00:10:29,900
What does n choose k mean?

208
00:10:29,900 --> 00:10:30,400
Yeah?

209
00:10:30,400 --> 00:10:33,520
STUDENT: The number of ways
to choose k objects from n

210
00:10:33,520 --> 00:10:34,020
[INAUDIBLE]

211
00:10:34,020 --> 00:10:35,853
JASON KU: Yeah, the
number of ways to choose

212
00:10:35,853 --> 00:10:38,190
k objects from n things--

213
00:10:38,190 --> 00:10:41,820
I never remember this formula.

214
00:10:41,820 --> 00:10:45,723
And probably, a lot of you
have memorized this formula.

215
00:10:45,723 --> 00:10:47,140
I'm not going to
ask you to do it.

216
00:10:47,140 --> 00:10:50,950
I'm going to tell you
how I think about this.

217
00:10:50,950 --> 00:10:54,570
What if I want to know the
number of permutations of n

218
00:10:54,570 --> 00:10:58,190
choose k-- or I mean of n?

219
00:10:58,190 --> 00:10:58,690
Sorry.

220
00:10:58,690 --> 00:11:01,680
Just how many permutations
are there of n items?

221
00:11:01,680 --> 00:11:02,730
What is that?

222
00:11:02,730 --> 00:11:04,890
That's just n factorial, right?

223
00:11:04,890 --> 00:11:08,400
So what we do here is
we'd want to choose

224
00:11:08,400 --> 00:11:11,510
some n number of things.

225
00:11:14,130 --> 00:11:17,370
I have n factorial different
ways of choosing those,

226
00:11:17,370 --> 00:11:24,090
but then, essentially, in here
and in here, k and n minus k--

227
00:11:24,090 --> 00:11:26,940
I don't really care
what their order is.

228
00:11:26,940 --> 00:11:30,360
So I'm going to divide
out the permutations

229
00:11:30,360 --> 00:11:32,050
of this stuff and this stuff.

230
00:11:32,050 --> 00:11:33,520
Does that makes sense?

231
00:11:33,520 --> 00:11:36,540
So the formula here
as I remember it,

232
00:11:36,540 --> 00:11:42,300
that hopefully is correct,
is n minus k factorial.

233
00:11:42,300 --> 00:11:46,440
So I'm getting all of the
permutations of the whole thing

234
00:11:46,440 --> 00:11:48,930
divided by their constituents.

235
00:11:48,930 --> 00:11:51,410
Does that make sense?

236
00:11:51,410 --> 00:11:53,260
Did I do that right?

237
00:11:53,260 --> 00:11:56,330
OK, cool-- so that's
a nice transformation.

238
00:11:56,330 --> 00:11:59,152
So the first step is writing
these in terms of factorials.

239
00:11:59,152 --> 00:12:01,360
That doesn't really help me
any, because I don't know

240
00:12:01,360 --> 00:12:03,760
how big factorial is based--

241
00:12:03,760 --> 00:12:06,190
with respect to
these other things.

242
00:12:06,190 --> 00:12:09,930
Does anyone know how
big factorial is?

243
00:12:09,930 --> 00:12:10,530
Yeah?

244
00:12:10,530 --> 00:12:11,820
STUDENT: You can use
Sterling's approximation.

245
00:12:11,820 --> 00:12:13,778
JASON KU: You can use
Sterling's approximation.

246
00:12:13,778 --> 00:12:14,670
So that's nice.

247
00:12:14,670 --> 00:12:18,240
Does anyone remember what
Sterling's approximation is?

248
00:12:18,240 --> 00:12:19,170
No.

249
00:12:19,170 --> 00:12:20,280
I don't remember either.

250
00:12:20,280 --> 00:12:22,380
I always have to look it up.

251
00:12:22,380 --> 00:12:30,720
Sterling's approximation says
n factorial is approximately--

252
00:12:30,720 --> 00:12:33,210
and this approximately
is much stronger

253
00:12:33,210 --> 00:12:38,700
than an asymptotic behavior.

254
00:12:38,700 --> 00:12:40,860
It's actually, as these things--

255
00:12:40,860 --> 00:12:43,650
as n approaches infinity,
these things are equal.

256
00:12:43,650 --> 00:12:46,170
The limit is the identity.

257
00:12:46,170 --> 00:12:48,660
But the approximation
is the square root

258
00:12:48,660 --> 00:12:53,760
of 2 pi n n/3 to the n.

259
00:12:53,760 --> 00:12:54,660
OK, that's fun.

260
00:12:57,850 --> 00:12:59,260
So what kind of growth is this?

261
00:13:03,400 --> 00:13:05,620
Super bad, right?

262
00:13:05,620 --> 00:13:11,190
It's definitely exponential
or higher than exponential.

263
00:13:11,190 --> 00:13:13,410
It's n to the n--
something like that--

264
00:13:13,410 --> 00:13:15,360
dividing out an e--

265
00:13:15,360 --> 00:13:21,890
this is e, the base of
the natural logarithm.

266
00:13:21,890 --> 00:13:24,015
And this is a
constant, and so is pi.

267
00:13:24,015 --> 00:13:25,905
Pi is a constant--
kind of interesting

268
00:13:25,905 --> 00:13:27,780
that we have two
transcendental numbers here.

269
00:13:27,780 --> 00:13:31,050
That's kind of fun mathematics.

270
00:13:31,050 --> 00:13:33,690
I'm sure some-- one of
your 6.042 instructors

271
00:13:33,690 --> 00:13:35,340
could tell you why.

272
00:13:35,340 --> 00:13:38,370
I can't right now off
the top of my head.

273
00:13:38,370 --> 00:13:42,330
But this is an approximation
that's very good.

274
00:13:42,330 --> 00:13:45,510
And actually,
sometimes other people

275
00:13:45,510 --> 00:13:50,380
will think-- this is what people
call Sterling's approximation.

276
00:13:50,380 --> 00:13:54,390
One weaker notion that
sometimes is useful for you

277
00:13:54,390 --> 00:14:01,280
is, if you take the
logarithm of both sides,

278
00:14:01,280 --> 00:14:03,980
this is asymptotically what?

279
00:14:08,800 --> 00:14:10,790
If I took the log
of this thing--

280
00:14:10,790 --> 00:14:12,470
STUDENT: Polynomial--

281
00:14:12,470 --> 00:14:15,957
JASON KU: It is a
polynomial thing.

282
00:14:15,957 --> 00:14:16,790
STUDENT: [INAUDIBLE]

283
00:14:16,790 --> 00:14:20,180
JASON KU: It's
basically n log n.

284
00:14:20,180 --> 00:14:26,270
If we take a log of this thing,
it would be various things.

285
00:14:26,270 --> 00:14:28,550
All right, let's do it out.

286
00:14:28,550 --> 00:14:33,110
2 pi n n/e to the n--

287
00:14:33,110 --> 00:14:36,710
so when we're inside a
logarithm, multiplication--

288
00:14:36,710 --> 00:14:38,060
we can split it out--

289
00:14:38,060 --> 00:14:39,410
becomes addition.

290
00:14:39,410 --> 00:14:44,150
Division becomes subtraction.

291
00:14:44,150 --> 00:14:47,880
And this thing grows faster
than all these other things,

292
00:14:47,880 --> 00:14:51,230
so we can ignore them when we
add them out asymptotically.

293
00:14:51,230 --> 00:14:53,900
And so what we end up
getting is this n to the n.

294
00:14:53,900 --> 00:14:55,820
The n comes out
on the logarithm,

295
00:14:55,820 --> 00:15:00,890
and you get something
that's theta n log n.

296
00:15:00,890 --> 00:15:03,180
Oh, that's fun.

297
00:15:03,180 --> 00:15:07,190
This is something we might
use later on in the class.

298
00:15:07,190 --> 00:15:12,110
OK, but when we are
comparing these functions,

299
00:15:12,110 --> 00:15:14,750
one of the nice things
to do is convert them

300
00:15:14,750 --> 00:15:17,090
into something
that's familiar to us

301
00:15:17,090 --> 00:15:19,400
so that we can
compare them easily.

302
00:15:19,400 --> 00:15:25,490
So here, this thing is
whatever that thing is, roughly

303
00:15:25,490 --> 00:15:31,370
square root n n/e to the n.

304
00:15:31,370 --> 00:15:36,260
This is, I'm going
to say, theta.

305
00:15:36,260 --> 00:15:38,870
That's a little
bit more precise.

306
00:15:38,870 --> 00:15:41,227
All right, then what
about these two things?

307
00:15:41,227 --> 00:15:42,560
Let's start with the bottom one.

308
00:15:42,560 --> 00:15:45,240
Can someone tell me what
this is, asymptotically?

309
00:15:45,240 --> 00:15:45,740
Yeah?

310
00:15:45,740 --> 00:15:46,760
STUDENT: n cubed--

311
00:15:46,760 --> 00:15:47,630
JASON KU: n cubed--

312
00:15:47,630 --> 00:15:48,470
why is that?

313
00:15:48,470 --> 00:15:52,700
Well, if we plug this stuff
into that definition here,

314
00:15:52,700 --> 00:16:01,100
we have n factorial over 3
factorial n minus 3 factorial.

315
00:16:01,100 --> 00:16:04,280
n factorial over n
minus 3 factorial

316
00:16:04,280 --> 00:16:06,620
just leaves us with
an n, an n minus 1,

317
00:16:06,620 --> 00:16:10,100
and an n minus 2 over 6.

318
00:16:10,100 --> 00:16:11,900
And if you multiply
all that out,

319
00:16:11,900 --> 00:16:16,760
the leading term is an
n cubed, so this thing

320
00:16:16,760 --> 00:16:20,460
is asymptotically n cubed.

321
00:16:20,460 --> 00:16:23,060
I skipped some steps,
but hopefully you

322
00:16:23,060 --> 00:16:25,720
could follow that.

323
00:16:25,720 --> 00:16:32,550
And then the last thing to
remain is this one right there.

324
00:16:32,550 --> 00:16:35,830
That one's a little tricky.

325
00:16:35,830 --> 00:16:37,780
Anyone want to help me out here?

326
00:16:37,780 --> 00:16:41,980
What we can do is we can
stick it into this formula,

327
00:16:41,980 --> 00:16:44,590
and then apply
Sterling's approximation

328
00:16:44,590 --> 00:16:47,020
to replace the factorials.

329
00:16:47,020 --> 00:16:48,280
That makes sense?

330
00:16:48,280 --> 00:16:50,680
OK, so what I'm going to do is--

331
00:16:50,680 --> 00:16:53,000
let's do this in two steps.

332
00:16:53,000 --> 00:16:57,760
This is going to be
n factorial over--

333
00:16:57,760 --> 00:16:59,800
what is this? n/2
factorial-- and then

334
00:16:59,800 --> 00:17:02,330
what is n minus n over 2?

335
00:17:02,330 --> 00:17:03,490
That's also n/2.

336
00:17:03,490 --> 00:17:10,720
So this is going to be
n/2 factorial squared.

337
00:17:10,720 --> 00:17:12,099
Is that OK?

338
00:17:12,099 --> 00:17:13,430
Yeah?

339
00:17:13,430 --> 00:17:17,119
Now let's replace this stuff
with Sterling's approximation

340
00:17:17,119 --> 00:17:19,310
and see if we can simplify.

341
00:17:19,310 --> 00:17:25,940
So on the top, we have 2
pi n n/e to the n over--

342
00:17:25,940 --> 00:17:31,460
and then we've got
a square here, pi n.

343
00:17:31,460 --> 00:17:33,860
I cancelled the 2--

344
00:17:33,860 --> 00:17:37,880
n/2 over e to the n/2.

345
00:17:40,520 --> 00:17:42,360
Did I do that right?

346
00:17:42,360 --> 00:17:42,860
OK.

347
00:17:42,860 --> 00:17:45,110
I can't spell, and
a lot of times,

348
00:17:45,110 --> 00:17:50,090
I make arithmetic errors, so
catch me if I am doing one.

349
00:17:50,090 --> 00:17:53,965
OK, so let's simplify
this bottom here.

350
00:17:53,965 --> 00:17:55,340
I'm not going to
rewrite the top.

351
00:17:55,340 --> 00:17:57,860
The bottom here--
we square this guy.

352
00:17:57,860 --> 00:18:00,350
It's the pi times n.

353
00:18:00,350 --> 00:18:03,470
And then this guy, n/2 squared--

354
00:18:03,470 --> 00:18:07,010
that just stays is an n.

355
00:18:07,010 --> 00:18:11,360
Then we have n/2 to the n/e--

356
00:18:14,540 --> 00:18:18,020
something like that. n/2 over
e to the n-- that makes more--

357
00:18:18,020 --> 00:18:19,340
me happier.

358
00:18:19,340 --> 00:18:21,710
OK, so now we have
this over this.

359
00:18:21,710 --> 00:18:23,130
How do we simplify?

360
00:18:23,130 --> 00:18:27,230
Well, we can cancel out
one of the root n's.

361
00:18:27,230 --> 00:18:34,010
So we've got square root of pi
n down here and square root of 2

362
00:18:34,010 --> 00:18:36,870
up top.

363
00:18:36,870 --> 00:18:40,590
And then what have we got?

364
00:18:40,590 --> 00:18:45,030
We've got n to the n down here
and n to the n down-- up there,

365
00:18:45,030 --> 00:18:46,070
so those cancel.

366
00:18:46,070 --> 00:18:50,240
We got 1 over e to the n,
1 over e to the n up there.

367
00:18:50,240 --> 00:18:51,410
Those cancel.

368
00:18:51,410 --> 00:18:55,240
What's left in this term,
when-- after we cancel?

369
00:18:55,240 --> 00:18:58,630
1 over 2 to the n in the
denominator, which is

370
00:18:58,630 --> 00:19:02,080
2 to the n in the numerator--

371
00:19:02,080 --> 00:19:07,170
so this thing is what
this thing is right.

372
00:19:07,170 --> 00:19:07,793
Asymptote.

373
00:19:07,793 --> 00:19:09,210
We can get rid of
these constants.

374
00:19:09,210 --> 00:19:10,110
And it's root n--

375
00:19:10,110 --> 00:19:15,520
I mean, it's 2 to the n
over root n, asymptotically.

376
00:19:15,520 --> 00:19:16,910
Does that makes
sense, everybody?

377
00:19:16,910 --> 00:19:17,500
OK.

378
00:19:17,500 --> 00:19:22,930
With that knowledge-- and I'm
sorry for my messy board work--

379
00:19:22,930 --> 00:19:25,150
what is the ordering of
these functions then?

380
00:19:25,150 --> 00:19:27,850
Can someone help me out?

381
00:19:27,850 --> 00:19:34,410
Someone else-- Eric, I'm sorry.

382
00:19:34,410 --> 00:19:36,210
You can't answer.

383
00:19:36,210 --> 00:19:37,050
Come on, guys.

384
00:19:37,050 --> 00:19:38,160
You followed what I said.

385
00:19:40,740 --> 00:19:44,020
Start it out for me.

386
00:19:44,020 --> 00:19:49,783
STUDENT: I think [INAUDIBLE]
f2 and f5 [INAUDIBLE]

387
00:19:49,783 --> 00:19:50,450
JASON KU: Right.

388
00:19:50,450 --> 00:19:53,120
So both of these things are
asymptotically equivalent,

389
00:19:53,120 --> 00:19:56,080
so we should put
those in brackets--

390
00:19:56,080 --> 00:19:59,790
f2, f5.

391
00:19:59,790 --> 00:20:04,266
STUDENT: And then
it would go f--

392
00:20:04,266 --> 00:20:07,158
[INAUDIBLE] 3.

393
00:20:07,158 --> 00:20:07,700
JASON KU: f3.

394
00:20:07,700 --> 00:20:09,020
This one?

395
00:20:09,020 --> 00:20:10,504
Why this one?

396
00:20:10,504 --> 00:20:11,360
STUDENT: Nevermind.

397
00:20:11,360 --> 00:20:14,540
JASON KU: I'm just asking you
to justify what you're saying.

398
00:20:14,540 --> 00:20:17,372
STUDENT: Well, because I feel
like we have the [INAUDIBLE]

399
00:20:17,372 --> 00:20:18,080
JASON KU: Uh-huh.

400
00:20:18,080 --> 00:20:19,520
STUDENT: [INAUDIBLE]

401
00:20:19,520 --> 00:20:22,640
JASON KU: This
one's the biggest?

402
00:20:22,640 --> 00:20:24,512
STUDENT: [INAUDIBLE]

403
00:20:24,512 --> 00:20:25,970
JASON KU: f4 is
the biggest, right?

404
00:20:25,970 --> 00:20:28,760
So this one's definitely
bigger than this,

405
00:20:28,760 --> 00:20:34,790
because it's n to the n,
as opposed to 2 to the n.

406
00:20:34,790 --> 00:20:40,250
So for any n larger
than 2 plus e

407
00:20:40,250 --> 00:20:43,680
is fairly obvious
that that's bigger.

408
00:20:43,680 --> 00:20:45,980
STUDENT: So wouldn't
f3 be before f1?

409
00:20:45,980 --> 00:20:47,540
JASON KU: Why would
f3 be before f1?

410
00:20:47,540 --> 00:20:49,790
STUDENT: [INAUDIBLE] 2 to
the n divided by [INAUDIBLE]

411
00:20:49,790 --> 00:20:52,490
JASON KU: But we're dividing
by a polynomial factor, right?

412
00:20:52,490 --> 00:20:56,900
So it's going to be
slower asymptotically

413
00:20:56,900 --> 00:20:59,140
than the first one right there.

414
00:20:59,140 --> 00:21:01,250
So you got it right.

415
00:21:01,250 --> 00:21:01,790
What is it?

416
00:21:01,790 --> 00:21:07,970
F3, f1, and f4--

417
00:21:07,970 --> 00:21:09,030
OK?

418
00:21:09,030 --> 00:21:13,040
Cool-- so it's a
little complicated,

419
00:21:13,040 --> 00:21:17,180
but just applying some
logarithm an exponent rules,

420
00:21:17,180 --> 00:21:20,840
understanding that logarithmic
factors grow slower

421
00:21:20,840 --> 00:21:24,140
than polynomial ones,
and again, grow slower

422
00:21:24,140 --> 00:21:26,090
than exponential ones.

423
00:21:26,090 --> 00:21:28,310
And being able to do some
transformations of some

424
00:21:28,310 --> 00:21:30,260
of these mathematical
quantities to get them

425
00:21:30,260 --> 00:21:33,620
in a polynomial-like
looking form

426
00:21:33,620 --> 00:21:35,750
is how you're going to
approach these problems.

427
00:21:35,750 --> 00:21:37,100
Does that make sense?

428
00:21:37,100 --> 00:21:41,513
All right, so we're going to
move on to question 2 now.

429
00:21:41,513 --> 00:21:42,680
Yeah, you've got a question?

430
00:21:42,680 --> 00:21:44,055
STUDENT: Yeah, I
have a question.

431
00:21:44,055 --> 00:21:46,790
What did you say the
theta bound was for 4?

432
00:21:46,790 --> 00:21:48,620
JASON KU: Theta bound for 4?

433
00:21:48,620 --> 00:21:49,170
This guy?

434
00:21:49,170 --> 00:21:51,870
STUDENT: [INAUDIBLE]

435
00:21:51,870 --> 00:21:53,750
JASON KU: So it's just that.

436
00:21:53,750 --> 00:21:56,120
I don't know how to
simplify that any further.

437
00:21:56,120 --> 00:21:58,180
You've got a
polynomial factor here,

438
00:21:58,180 --> 00:22:02,450
and then this is an n to the n
term divided by an exponential.

439
00:22:02,450 --> 00:22:02,950
Yeah?

440
00:22:02,950 --> 00:22:05,820
STUDENT: For f3,
which one did you--

441
00:22:05,820 --> 00:22:07,160
how did you reduce--

442
00:22:07,160 --> 00:22:09,530
which one is f3 [INAUDIBLE]

443
00:22:09,530 --> 00:22:15,140
JASON KU: f3 took this
little cycle here.

444
00:22:15,140 --> 00:22:20,720
What we did was we
expanded out the definition

445
00:22:20,720 --> 00:22:23,150
of the binomial
coefficient here.

446
00:22:23,150 --> 00:22:25,220
Then we applied
Sterling, and then we

447
00:22:25,220 --> 00:22:26,880
simplified and got back.

448
00:22:26,880 --> 00:22:27,920
Does that make sense?

449
00:22:27,920 --> 00:22:28,662
Yeah?

450
00:22:28,662 --> 00:22:29,605
STUDENT: [INAUDIBLE]

451
00:22:29,605 --> 00:22:30,230
JASON KU: Sure.

452
00:22:30,230 --> 00:22:34,000
STUDENT: Is there a reason
that f3 is before f1?

453
00:22:34,000 --> 00:22:37,760
JASON KU: Why is f3 before f1?

454
00:22:37,760 --> 00:22:44,140
If I erase the 2 and the pi,
this thing is theta of that--

455
00:22:44,140 --> 00:22:47,590
2 to the n over a
polynomial factor.

456
00:22:47,590 --> 00:22:51,280
It's over n to the 1/2.

457
00:22:51,280 --> 00:22:55,800
n to the 1/2 grows
non-trivially.

458
00:22:55,800 --> 00:22:56,440
Right?

459
00:22:56,440 --> 00:22:59,890
And so this is going to decrease
the running time of this thing

460
00:22:59,890 --> 00:23:01,590
by a polynomial factor.

461
00:23:01,590 --> 00:23:02,710
You could think about--

462
00:23:02,710 --> 00:23:07,220
we're multiplying this by
n to the minus 1/2 as well.

463
00:23:07,220 --> 00:23:09,550
That's another way
of thinking about it.

464
00:23:09,550 --> 00:23:12,490
Any other questions?

465
00:23:12,490 --> 00:23:22,140
OK, so we're going to move
on to problem 2, I guess.

466
00:23:22,140 --> 00:23:23,630
I need a eraser.

467
00:23:30,500 --> 00:23:36,150
So problem 2 is kind of
a funny looking problem.

468
00:23:36,150 --> 00:23:41,960
The point of this
problem is to get

469
00:23:41,960 --> 00:23:44,600
you to think about using
some of the things we're

470
00:23:44,600 --> 00:23:48,680
going to be using in this
class as a black box.

471
00:23:48,680 --> 00:23:50,750
What using something
as a black box

472
00:23:50,750 --> 00:23:53,780
means is that has a kind of a
public interface that you're

473
00:23:53,780 --> 00:23:56,180
allowed to work with,
but I'm not allowed

474
00:23:56,180 --> 00:23:58,370
to see what's inside of it.

475
00:23:58,370 --> 00:24:00,770
And a lot of times, what
we'll do in this class

476
00:24:00,770 --> 00:24:04,610
is try to use a
black box and just

477
00:24:04,610 --> 00:24:09,380
try to use the abstracted
outer functions so that we

478
00:24:09,380 --> 00:24:10,790
can prove things about it.

479
00:24:10,790 --> 00:24:13,460
We can just accept
those as true,

480
00:24:13,460 --> 00:24:17,130
and then use those to
deal with our analysis.

481
00:24:17,130 --> 00:24:18,860
So what we're given
in this problem

482
00:24:18,860 --> 00:24:25,190
is a data structure supporting
a sequence interface

483
00:24:25,190 --> 00:24:27,260
that you heard about yesterday.

484
00:24:27,260 --> 00:24:28,760
What's a sequence
interface again?

485
00:24:31,560 --> 00:24:34,110
How does it store items?

486
00:24:34,110 --> 00:24:35,490
Anyone remember?

487
00:24:35,490 --> 00:24:36,454
Yeah?

488
00:24:36,454 --> 00:24:37,780
STUDENT: [INAUDIBLE]

489
00:24:37,780 --> 00:24:38,750
JASON KU: Well, it--

490
00:24:38,750 --> 00:24:39,250
OK.

491
00:24:39,250 --> 00:24:40,637
STUDENT: [INAUDIBLE]

492
00:24:40,637 --> 00:24:41,470
JASON KU: All right.

493
00:24:41,470 --> 00:24:43,900
So what your colleague
is saying here

494
00:24:43,900 --> 00:24:47,410
is we list them in
a contiguous array.

495
00:24:47,410 --> 00:24:50,100
Does anyone have a problem
with that definition?

496
00:24:50,100 --> 00:24:51,415
Yeah, up there--

497
00:24:51,415 --> 00:24:54,980
STUDENT: [INAUDIBLE]

498
00:24:54,980 --> 00:24:56,530
JASON KU: OK.

499
00:24:56,530 --> 00:25:01,490
So one of the important
things about this class

500
00:25:01,490 --> 00:25:03,920
is abstracting this
idea of an interface

501
00:25:03,920 --> 00:25:05,090
versus an implementation.

502
00:25:05,090 --> 00:25:08,630
And so what this student
down here was talking

503
00:25:08,630 --> 00:25:11,958
to me about an array as an
underlying implementation,

504
00:25:11,958 --> 00:25:14,000
and what the student back
there was talking about

505
00:25:14,000 --> 00:25:14,940
is a linked list.

506
00:25:14,940 --> 00:25:19,310
These are both things that
can implement that interface.

507
00:25:19,310 --> 00:25:22,610
But in reality, the interface
is something abstracted outside

508
00:25:22,610 --> 00:25:23,840
of those ideas.

509
00:25:23,840 --> 00:25:27,530
We could implement with either
of those data structures.

510
00:25:27,530 --> 00:25:31,440
So what makes the sequence
interface a sequence interface?

511
00:25:31,440 --> 00:25:31,940
Yeah?

512
00:25:31,940 --> 00:25:33,607
STUDENT: It's in
order, or at least it's

513
00:25:33,607 --> 00:25:38,570
indexed in a specific way
that allows for [INAUDIBLE]

514
00:25:38,570 --> 00:25:42,260
JASON KU: So it's about the
data that we're storing.

515
00:25:42,260 --> 00:25:45,980
We're storing some
number of things,

516
00:25:45,980 --> 00:25:49,010
and the important thing
is that the data structure

517
00:25:49,010 --> 00:25:53,090
is maintaining being
able to find items

518
00:25:53,090 --> 00:25:57,920
in that set by maintaining
an order on them.

519
00:25:57,920 --> 00:26:00,290
I usually like to call
it an extrinsic order

520
00:26:00,290 --> 00:26:01,370
on these things.

521
00:26:01,370 --> 00:26:04,070
It has nothing to do
with what the items are.

522
00:26:04,070 --> 00:26:06,410
It has to do with how
I put them in order.

523
00:26:06,410 --> 00:26:08,360
There's a first thing,
there's a 10th thing,

524
00:26:08,360 --> 00:26:09,410
there's a last thing.

525
00:26:09,410 --> 00:26:10,130
Right?

526
00:26:10,130 --> 00:26:13,520
That's what a sequence
of items is right.

527
00:26:13,520 --> 00:26:16,340
And so what this
data structure is

528
00:26:16,340 --> 00:26:21,950
doing, that's the input that
is what we have available to us

529
00:26:21,950 --> 00:26:25,340
in this problem, is some
kind of data structure

530
00:26:25,340 --> 00:26:28,130
storing a sequence of things.

531
00:26:28,130 --> 00:26:30,770
And it can support
these four operations--

532
00:26:30,770 --> 00:26:36,290
an insert first, insert last,
delete first, and delete last.

533
00:26:36,290 --> 00:26:40,160
And it supports each of those
things in constant time.

534
00:26:40,160 --> 00:26:44,760
You don't a data structure
that does that yet.

535
00:26:44,760 --> 00:26:47,790
You will on your
problem set 1, and we'll

536
00:26:47,790 --> 00:26:51,540
talk about another
way to do that today.

537
00:26:51,540 --> 00:26:54,550
But we don't care
how it's implemented.

538
00:26:54,550 --> 00:26:57,090
We just give you this black
box that achieves these things.

539
00:26:57,090 --> 00:26:59,430
Yay-- awesome.

540
00:26:59,430 --> 00:27:03,690
And so what we're trying to
do is, we have this thing,

541
00:27:03,690 --> 00:27:06,570
and I want to be able to
manipulate the sequence stored

542
00:27:06,570 --> 00:27:12,690
inside, but all I have access to
are these external operations.

543
00:27:12,690 --> 00:27:19,260
So the idea is going to be
let's implement algorithms

544
00:27:19,260 --> 00:27:22,080
for these-- some
higher level operations

545
00:27:22,080 --> 00:27:25,500
in terms of these lower level
things that are given to us.

546
00:27:25,500 --> 00:27:27,070
Does that makes sense?

547
00:27:27,070 --> 00:27:29,760
And this is actually a
pretty easy question.

548
00:27:29,760 --> 00:27:33,180
Hopefully we'll have slightly
more difficult ones for you

549
00:27:33,180 --> 00:27:33,900
on--

550
00:27:33,900 --> 00:27:37,200
in a different context
on problem set 1.

551
00:27:37,200 --> 00:27:42,150
OK, so the first operation
we're going to support--

552
00:27:42,150 --> 00:27:44,220
or try to support--

553
00:27:44,220 --> 00:27:49,080
is an operation
called swap_ends.

554
00:27:49,080 --> 00:27:51,540
And what this is going to do
is take the data structure

555
00:27:51,540 --> 00:27:52,290
that we gave--

556
00:27:52,290 --> 00:27:55,530
another way you could do this
is put this as a method on that

557
00:27:55,530 --> 00:27:57,960
data structure, but let's
do this separately--

558
00:27:57,960 --> 00:28:00,840
it's going to take that data
structure that we gave--

559
00:28:00,840 --> 00:28:05,850
that I gave you, that's
storing the sequence,

560
00:28:05,850 --> 00:28:07,620
as the only argument.

561
00:28:07,620 --> 00:28:10,470
And what we're
asking you to do is

562
00:28:10,470 --> 00:28:13,320
describe an algorithm to swap
the first and the last items.

563
00:28:17,470 --> 00:28:21,660
I it was an array, I could just
look at index 0, look at that,

564
00:28:21,660 --> 00:28:25,080
look at the last one look
at that, and swap them.

565
00:28:25,080 --> 00:28:29,010
But I don't have access to what
that underlying representation

566
00:28:29,010 --> 00:28:33,090
is, so how would I do that
using the things that we

567
00:28:33,090 --> 00:28:35,470
have available to us?

568
00:28:35,470 --> 00:28:38,130
This is a pretty easy question.

569
00:28:38,130 --> 00:28:39,120
What have we got?

570
00:28:39,120 --> 00:28:39,900
STUDENT: Just a quick question.

571
00:28:39,900 --> 00:28:40,440
JASON KU: Yeah.

572
00:28:40,440 --> 00:28:42,232
STUDENT: Does the delete
method also return

573
00:28:42,232 --> 00:28:43,277
whatever it deletes?

574
00:28:43,277 --> 00:28:43,860
JASON KU: Yes.

575
00:28:43,860 --> 00:28:44,440
Yes, it does.

576
00:28:44,440 --> 00:28:47,490
So in general, if you actually
take a look at the session

577
00:28:47,490 --> 00:28:49,680
notes, it's giving you
a nice little reminder--

578
00:28:49,680 --> 00:28:52,770
recall, the delete operations
return the deleted item.

579
00:28:52,770 --> 00:28:55,380
OK?

580
00:28:55,380 --> 00:28:56,880
It says it right
there on the thing.

581
00:28:59,550 --> 00:29:00,960
Yeah?

582
00:29:00,960 --> 00:29:02,580
STUDENT: Oh, I also
had a question.

583
00:29:02,580 --> 00:29:03,620
JASON KU: Sure.

584
00:29:03,620 --> 00:29:05,240
STUDENT: And this
actually [INAUDIBLE]

585
00:29:05,240 --> 00:29:05,948
JASON KU: Mm-hmm.

586
00:29:05,948 --> 00:29:08,070
STUDENT: It's not
related [INAUDIBLE]

587
00:29:08,070 --> 00:29:12,334
if they don't specify a space
[INAUDIBLE] does that mean

588
00:29:12,334 --> 00:29:13,050
[INAUDIBLE]

589
00:29:13,050 --> 00:29:14,550
JASON KU: Yeah, so
one of the things

590
00:29:14,550 --> 00:29:18,760
that Eric talked about yesterday
was generally, in this class,

591
00:29:18,760 --> 00:29:19,680
if you have--

592
00:29:19,680 --> 00:29:21,805
usually what we'll give
you is a running time

593
00:29:21,805 --> 00:29:23,430
bound on the things
that you asked for.

594
00:29:23,430 --> 00:29:26,970
And because allocation
of space by our model

595
00:29:26,970 --> 00:29:31,080
takes that amount of
time, the amount of time--

596
00:29:31,080 --> 00:29:34,020
the amount of space
that we are using

597
00:29:34,020 --> 00:29:36,690
is going to be asymptotically
upper bounded by the time

598
00:29:36,690 --> 00:29:39,120
that we're going to
use for the algorithm.

599
00:29:39,120 --> 00:29:42,840
And so generally, we'll ask you
to stay within a time bound,

600
00:29:42,840 --> 00:29:45,900
and not ask you to do
something separate with space,

601
00:29:45,900 --> 00:29:48,960
but there are problems probably
at the end of this unit

602
00:29:48,960 --> 00:29:52,290
where we might talk
about space complexity.

603
00:29:52,290 --> 00:29:55,350
But usually, we will
be very specific

604
00:29:55,350 --> 00:29:58,380
if we want you to
think about space.

605
00:29:58,380 --> 00:30:00,030
Any other questions?

606
00:30:00,030 --> 00:30:02,800
All right, so how do we
implement this swap_ends thing?

607
00:30:02,800 --> 00:30:03,300
Yeah.

608
00:30:03,300 --> 00:30:05,560
This is a pretty easy one.

609
00:30:05,560 --> 00:30:06,430
Yeah?

610
00:30:06,430 --> 00:30:10,140
STUDENT: [INAUDIBLE] say
first equals [INAUDIBLE]

611
00:30:10,140 --> 00:30:14,850
JASON KU: OK, so another
thing about this class--

612
00:30:14,850 --> 00:30:17,010
your colleague
over here is trying

613
00:30:17,010 --> 00:30:23,190
to write code to me, which
is great for a computer,

614
00:30:23,190 --> 00:30:25,510
and that's great if
you're taking 6.009.

615
00:30:25,510 --> 00:30:27,510
It's not great if you're
talking to your friends

616
00:30:27,510 --> 00:30:30,360
or if you're talking to me.

617
00:30:30,360 --> 00:30:34,460
I can't parse code in my head
and compile it all the time.

618
00:30:34,460 --> 00:30:37,303
Sometimes I can, but
not all the time,

619
00:30:37,303 --> 00:30:39,220
especially when it gets
to be a large program.

620
00:30:39,220 --> 00:30:41,430
So I want you to
explain in words to me,

621
00:30:41,430 --> 00:30:46,440
and we want you to explain in
words in your LaTeX submissions

622
00:30:46,440 --> 00:30:49,320
what it is the
algorithm is doing.

623
00:30:49,320 --> 00:30:52,717
So can you start over
with your description?

624
00:30:52,717 --> 00:30:53,828
STUDENT: Words are hard.

625
00:30:53,828 --> 00:30:54,870
JASON KU: Words are hard.

626
00:30:54,870 --> 00:30:55,780
I agree with you.

627
00:30:55,780 --> 00:30:57,530
STUDENT: This is a
computer science class.

628
00:30:57,530 --> 00:31:01,500
STUDENT: I would delete
the last [INAUDIBLE]

629
00:31:01,500 --> 00:31:04,170
and then take that
value [INAUDIBLE]

630
00:31:04,170 --> 00:31:05,010
JASON KU: OK.

631
00:31:05,010 --> 00:31:09,420
So proposal-- we have
a sequence of things.

632
00:31:09,420 --> 00:31:13,410
Again, as Eric was doing
in lecture yesterday,

633
00:31:13,410 --> 00:31:15,090
this isn't
representing an array.

634
00:31:15,090 --> 00:31:16,390
It's representing a sequence.

635
00:31:16,390 --> 00:31:22,440
So this is the front
first I guessed and last.

636
00:31:22,440 --> 00:31:28,860
And what your colleague was
saying was to delete this guy

637
00:31:28,860 --> 00:31:33,870
and stick it on the front,
maybe by using delete last

638
00:31:33,870 --> 00:31:34,710
and insert first.

639
00:31:37,230 --> 00:31:39,570
That sounds pretty good.

640
00:31:39,570 --> 00:31:41,460
Does that do what
swap_ends is doing?

641
00:31:41,460 --> 00:31:44,490
Swap_ends-- swap the first and
last items in the sequence.

642
00:31:46,917 --> 00:31:49,000
STUDENT: It's probably
better if we first store it

643
00:31:49,000 --> 00:31:52,242
in some other variable, so that
way we can get the-- delete

644
00:31:52,242 --> 00:31:54,030
the n [INAUDIBLE]

645
00:31:54,030 --> 00:31:56,250
JASON KU: So what your
colleague is saying is,

646
00:31:56,250 --> 00:31:59,670
well, we've done kind
of half of our work.

647
00:31:59,670 --> 00:32:01,980
The first one's still over here.

648
00:32:01,980 --> 00:32:03,075
That's no good.

649
00:32:03,075 --> 00:32:06,300
Does someone have a
way to modify this?

650
00:32:06,300 --> 00:32:06,810
Yeah?

651
00:32:06,810 --> 00:32:10,440
STUDENT: Before modifying,
you can [INAUDIBLE] to modify.

652
00:32:10,440 --> 00:32:13,085
[INAUDIBLE] about the amount
of things we're storing.

653
00:32:13,085 --> 00:32:13,710
JASON KU: Yeah.

654
00:32:13,710 --> 00:32:16,595
So how much extra space
can we use, for example?

655
00:32:16,595 --> 00:32:17,970
STUDENT: The
easiest way would be

656
00:32:17,970 --> 00:32:21,030
to delete the last
[INAUDIBLE] the first,

657
00:32:21,030 --> 00:32:24,370
and then just, if we have
them already kept [INAUDIBLE]

658
00:32:24,370 --> 00:32:27,232
but I don't know if I can
keep two different variables

659
00:32:27,232 --> 00:32:27,940
at the same time.

660
00:32:27,940 --> 00:32:31,650
JASON KU: Good question--
so the question-- can I

661
00:32:31,650 --> 00:32:32,980
use additional space?

662
00:32:32,980 --> 00:32:35,040
And in general, if
we don't give you

663
00:32:35,040 --> 00:32:40,860
any restrictions on what you
can store, then you can go wild.

664
00:32:40,860 --> 00:32:44,130
Do whatever you want, outside
of this data structure.

665
00:32:44,130 --> 00:32:49,820
One of the things you
could do is remove first

666
00:32:49,820 --> 00:32:54,410
all of these things, store
it and some data structure

667
00:32:54,410 --> 00:32:57,420
you like, manipulate
it as much as you want,

668
00:32:57,420 --> 00:33:00,170
and then insert first
all the way back in

669
00:33:00,170 --> 00:33:01,393
and rewrite the thing.

670
00:33:01,393 --> 00:33:03,560
But that's not going to
give us constant time, which

671
00:33:03,560 --> 00:33:05,390
is what we're asking for.

672
00:33:05,390 --> 00:33:10,047
But if we don't tell you
otherwise, feel free to--

673
00:33:10,047 --> 00:33:12,380
probably, you're only allowed
to store a constant number

674
00:33:12,380 --> 00:33:14,300
of things, since we
have constant time,

675
00:33:14,300 --> 00:33:17,420
but generally, unless
we say, no, you

676
00:33:17,420 --> 00:33:20,690
can't use additional space,
you can use additional space.

677
00:33:20,690 --> 00:33:21,290
OK?

678
00:33:21,290 --> 00:33:22,805
So how would you do that?

679
00:33:22,805 --> 00:33:25,430
STUDENT: I would probably erase
the last one and the first one,

680
00:33:25,430 --> 00:33:27,980
keep them both, then
answer the first one,

681
00:33:27,980 --> 00:33:30,188
answer everything else, and
then answer the last one.

682
00:33:30,188 --> 00:33:31,147
JASON KU: That's great.

683
00:33:31,147 --> 00:33:32,570
So what your
colleague is saying--

684
00:33:32,570 --> 00:33:36,830
we delete both of them, we store
them in temporary variables,

685
00:33:36,830 --> 00:33:39,380
and then, one at a time,
we insert each of them

686
00:33:39,380 --> 00:33:41,512
in their corresponding
place using the functions

687
00:33:41,512 --> 00:33:42,470
that we have available.

688
00:33:42,470 --> 00:33:47,270
OK, so if I were to write
little pseudocode for this,

689
00:33:47,270 --> 00:33:52,010
I might take the first one--

690
00:33:52,010 --> 00:33:59,180
I'd delete first.

691
00:33:59,180 --> 00:34:02,500
I'm really abusing
notation here.

692
00:34:02,500 --> 00:34:03,110
That's OK.

693
00:34:03,110 --> 00:34:05,060
You get what I'm saying.

694
00:34:05,060 --> 00:34:12,350
Delete the last,
and then store them

695
00:34:12,350 --> 00:34:14,389
in their respective places.

696
00:34:14,389 --> 00:34:17,040
Insert at the front--

697
00:34:17,040 --> 00:34:20,380
which one am I going to insert?

698
00:34:20,380 --> 00:34:20,880
What's up?

699
00:34:24,989 --> 00:34:26,440
Speak up, guys.

700
00:34:26,440 --> 00:34:27,120
STUDENT: x2--

701
00:34:27,120 --> 00:34:28,130
JASON KU: x2-- yes.

702
00:34:28,130 --> 00:34:29,739
Thank you.

703
00:34:29,739 --> 00:34:35,500
And insert last, x1--

704
00:34:35,500 --> 00:34:38,159
OK, that's pretty easy.

705
00:34:38,159 --> 00:34:39,425
Yeah?

706
00:34:39,425 --> 00:34:40,800
STUDENT: In this
case, what would

707
00:34:40,800 --> 00:34:43,000
[INAUDIBLE] I think
this might be relevant.

708
00:34:43,000 --> 00:34:45,150
[INAUDIBLE] What would
constitute a pseudocode

709
00:34:45,150 --> 00:34:47,040
versus [INAUDIBLE]
accidentally writing

710
00:34:47,040 --> 00:34:48,360
Python syntax [INAUDIBLE]

711
00:34:48,360 --> 00:34:50,429
JASON KU: All right,
so for this problem,

712
00:34:50,429 --> 00:34:53,310
you'll see the solutions
posted to this later on.

713
00:34:53,310 --> 00:34:56,828
In that one, I wrote
up a description

714
00:34:56,828 --> 00:34:59,370
of what I was going to do, and
then I actually-- because this

715
00:34:59,370 --> 00:35:02,550
was pretty easy, I actually
wrote down some Python code

716
00:35:02,550 --> 00:35:05,410
to do whatever this thing was.

717
00:35:05,410 --> 00:35:08,460
But in general--
and it's actually

718
00:35:08,460 --> 00:35:13,920
OK to write Python or pseudocode
of this form on your problem

719
00:35:13,920 --> 00:35:15,970
sets, or on an exam,
or something like that.

720
00:35:15,970 --> 00:35:20,160
But if we can't understand
what your variables mean,

721
00:35:20,160 --> 00:35:23,910
if we can't understand what
your pseudocode is doing,

722
00:35:23,910 --> 00:35:26,250
then that's not sufficient.

723
00:35:26,250 --> 00:35:28,590
So the reason why
we ask for words

724
00:35:28,590 --> 00:35:33,132
is so that you can
communicate those ideas well.

725
00:35:33,132 --> 00:35:34,590
STUDENT: Just a
follow-up on that--

726
00:35:34,590 --> 00:35:36,270
so can you also
have a combination

727
00:35:36,270 --> 00:35:37,520
of pseudocode and description?

728
00:35:37,520 --> 00:35:37,885
JASON KU: Sure.

729
00:35:37,885 --> 00:35:38,385
STUDENT: OK.

730
00:35:38,385 --> 00:35:40,170
JASON KU: Yeah--
including both of them

731
00:35:40,170 --> 00:35:44,490
can be clarifying
for you, potentially.

732
00:35:44,490 --> 00:35:45,833
Any other questions?

733
00:35:51,810 --> 00:35:55,050
This is not such an
interesting question

734
00:35:55,050 --> 00:35:56,960
from an algorithm standpoint.

735
00:35:56,960 --> 00:36:00,150
This is a constant
size problem kind of.

736
00:36:00,150 --> 00:36:02,520
I have this data structure.

737
00:36:02,520 --> 00:36:03,660
I do two operations.

738
00:36:03,660 --> 00:36:05,580
I need to do something.

739
00:36:05,580 --> 00:36:08,520
And this is so easy that
I'm really not even going

740
00:36:08,520 --> 00:36:10,000
to argue correctness--

741
00:36:10,000 --> 00:36:12,390
I'm not even going to
have to argue correctness

742
00:36:12,390 --> 00:36:14,310
to you, because we're
essentially just doing

743
00:36:14,310 --> 00:36:17,432
exactly what we asked for.

744
00:36:17,432 --> 00:36:19,890
Most of the time in this class,
when you're doing something

745
00:36:19,890 --> 00:36:23,010
non-trivial-- especially when
you're doing something that

746
00:36:23,010 --> 00:36:25,020
has to recurse in
some way-- we do

747
00:36:25,020 --> 00:36:27,690
want you to argue correctness.

748
00:36:27,690 --> 00:36:32,730
But in this case, for example,
the time analysis is very easy.

749
00:36:32,730 --> 00:36:34,320
We do for operations.

750
00:36:34,320 --> 00:36:36,690
They each take constant
time, so this operation

751
00:36:36,690 --> 00:36:37,680
takes constant time--

752
00:36:37,680 --> 00:36:38,550
done.

753
00:36:38,550 --> 00:36:39,450
Yeah?

754
00:36:39,450 --> 00:36:42,810
All right, so how about
the second operation?

755
00:36:42,810 --> 00:36:48,480
Second operation at least allows
us to use a little bit more.

756
00:36:48,480 --> 00:36:49,140
So

757
00:36:49,140 --> 00:36:59,970
Shift_left D, K-- this is the
operation we're supporting now

758
00:36:59,970 --> 00:37:02,610
is we are given this sequence,
and what we want to do is take

759
00:37:02,610 --> 00:37:14,730
the first K, here and stick it
over here at the back so that

760
00:37:14,730 --> 00:37:15,876
the--

761
00:37:15,876 --> 00:37:17,380
these K go here.

762
00:37:17,380 --> 00:37:20,580
So the K-th item ends
up being the last item

763
00:37:20,580 --> 00:37:24,380
and the K plus 1th item
now becomes the first item.

764
00:37:24,380 --> 00:37:25,900
Does that makes sense?

765
00:37:25,900 --> 00:37:26,450
OK.

766
00:37:26,450 --> 00:37:29,650
Again, this is actually not
such an interesting algorithm

767
00:37:29,650 --> 00:37:34,030
from an algorithm standpoint,
but it's hopefully

768
00:37:34,030 --> 00:37:37,220
helpful to talk about from an
instructional point of view.

769
00:37:37,220 --> 00:37:37,750
OK?

770
00:37:37,750 --> 00:37:39,760
So how would I
approach this problem?

771
00:37:39,760 --> 00:37:47,350
I need this operation to
happen in order K time.

772
00:37:47,350 --> 00:37:47,890
Yeah?

773
00:37:47,890 --> 00:37:48,390
STUDENT: OK.

774
00:37:48,390 --> 00:37:50,680
So first, go and delete--

775
00:37:50,680 --> 00:37:55,810
set a variable x1 to be the
d dot delete first element.

776
00:37:55,810 --> 00:38:01,990
Then do d dot insert at the
last x1, write a for loop,

777
00:38:01,990 --> 00:38:03,250
and then do that K times.

778
00:38:03,250 --> 00:38:05,588
And that should take
2K steps, which is OK.

779
00:38:05,588 --> 00:38:06,130
JASON KU: OK.

780
00:38:06,130 --> 00:38:08,020
So what your
colleague was saying

781
00:38:08,020 --> 00:38:12,400
is that we're just going
to delete this guy,

782
00:38:12,400 --> 00:38:16,900
stick it on there,
do it K times.

783
00:38:16,900 --> 00:38:18,160
That sound good?

784
00:38:18,160 --> 00:38:19,390
Yeah.

785
00:38:19,390 --> 00:38:22,180
One of the things in this
class that you have, in terms

786
00:38:22,180 --> 00:38:24,340
of implementation--

787
00:38:24,340 --> 00:38:26,950
usually there are two ways--

788
00:38:26,950 --> 00:38:28,720
at least two ways you
could do something

789
00:38:28,720 --> 00:38:31,210
that takes longer
than constant time.

790
00:38:31,210 --> 00:38:34,180
You could write a four loop
where you could use recursion.

791
00:38:37,070 --> 00:38:40,610
Sometimes approaching a
problem would be good one way,

792
00:38:40,610 --> 00:38:42,440
rather than another.

793
00:38:42,440 --> 00:38:47,030
Why is it that a lot
of computer scientists,

794
00:38:47,030 --> 00:38:49,730
as opposed to coding
engineers, prefer to think

795
00:38:49,730 --> 00:38:51,200
about an algorithm recursively?

796
00:38:51,200 --> 00:38:52,820
Does anyone know why?

797
00:38:52,820 --> 00:38:55,640
At least I do, when
I'm explaining it

798
00:38:55,640 --> 00:38:57,290
from a theory standpoint.

799
00:38:57,290 --> 00:38:59,480
It actually might not be
good from an implementation

800
00:38:59,480 --> 00:39:02,383
standpoint, because your
computer can vectorized

801
00:39:02,383 --> 00:39:04,550
for loops and things like--
but that's not something

802
00:39:04,550 --> 00:39:06,470
we need to talk about.

803
00:39:06,470 --> 00:39:10,250
Why would we want to talk
about a recursive algorithm

804
00:39:10,250 --> 00:39:11,270
maybe more?

805
00:39:11,270 --> 00:39:13,770
STUDENT: It lets you break up
the problem into much smaller,

806
00:39:13,770 --> 00:39:14,960
more manageable pieces.

807
00:39:14,960 --> 00:39:18,320
JASON KU: OK, so recursion
lets you break up the problem

808
00:39:18,320 --> 00:39:20,720
into small measurable pieces.

809
00:39:20,720 --> 00:39:25,670
That's actually true
in some context.

810
00:39:25,670 --> 00:39:28,190
How I like to think about
recursion a lot of times is,

811
00:39:28,190 --> 00:39:31,760
if I have a non-constant amount
of work that I have to do,

812
00:39:31,760 --> 00:39:33,530
usually easy for me--

813
00:39:33,530 --> 00:39:35,810
it's hard for me to hold
a non-constant amount

814
00:39:35,810 --> 00:39:38,317
of information in my head.

815
00:39:38,317 --> 00:39:40,400
What I want to do is think
about a constant amount

816
00:39:40,400 --> 00:39:43,730
of information at any
given point in time,

817
00:39:43,730 --> 00:39:46,220
because that's easier
for me to argue on.

818
00:39:46,220 --> 00:39:51,080
It's easier for me to think
about making arguments, case

819
00:39:51,080 --> 00:39:54,120
analysis on these
small amount of things.

820
00:39:54,120 --> 00:39:56,360
And so one of the
things you can do

821
00:39:56,360 --> 00:40:01,040
is, if you break it down
so that I solve a slightly

822
00:40:01,040 --> 00:40:03,650
smaller problem
recursively, and then

823
00:40:03,650 --> 00:40:09,150
do a constant amount of work
and maintain some invariant,

824
00:40:09,150 --> 00:40:12,600
then it's very easy to
argue things about it.

825
00:40:12,600 --> 00:40:14,990
It's very easy for
me to convince myself

826
00:40:14,990 --> 00:40:17,240
that this thing's correct.

827
00:40:17,240 --> 00:40:21,770
So I'm going to
provide a recursive way

828
00:40:21,770 --> 00:40:23,120
of solving this problem.

829
00:40:23,120 --> 00:40:25,630
Can anyone set up
maybe a recursive way

830
00:40:25,630 --> 00:40:27,380
of thinking about this
problem, instead of

831
00:40:27,380 --> 00:40:30,050
putting this inside a for loop,
like your colleague was saying?

832
00:40:37,810 --> 00:40:39,430
Yeah?

833
00:40:39,430 --> 00:40:40,965
STUDENT: [INAUDIBLE]
people do is

834
00:40:40,965 --> 00:40:45,270
just consider what will happen
when k equals 0 you're not

835
00:40:45,270 --> 00:40:46,328
[INAUDIBLE] it at all.

836
00:40:46,328 --> 00:40:46,870
JASON KU: OK.

837
00:40:46,870 --> 00:40:49,870
STUDENT: [INAUDIBLE]
what it originally was.

838
00:40:49,870 --> 00:40:51,830
And then-- but if that
k is greater than 0,

839
00:40:51,830 --> 00:40:57,010
you just [INAUDIBLE] and
then [INAUDIBLE] k is 1 less

840
00:40:57,010 --> 00:40:59,830
[INAUDIBLE]

841
00:40:59,830 --> 00:41:01,580
JASON KU: So what your
colleague is saying

842
00:41:01,580 --> 00:41:04,760
is setting up the--
a very nice thing.

843
00:41:04,760 --> 00:41:09,590
She's saying that, if we
think about this recursively,

844
00:41:09,590 --> 00:41:11,610
we'll think about a base case--

845
00:41:11,610 --> 00:41:14,300
which, your colleague was
saying maybe K equals 0.

846
00:41:16,820 --> 00:41:19,910
And otherwise, if
we're not at 0,

847
00:41:19,910 --> 00:41:25,220
what we'll do is we'll start
it out, move one of these guys

848
00:41:25,220 --> 00:41:29,740
over, and then we have
an instance where we want

849
00:41:29,740 --> 00:41:32,440
to shift K minus 1 things over.

850
00:41:35,680 --> 00:41:39,050
Want to do the same thing,
but with K minus 1 things.

851
00:41:39,050 --> 00:41:42,160
And so we can just call this
thing for a smaller value

852
00:41:42,160 --> 00:41:43,450
of K. Does that makes sense?

853
00:41:46,010 --> 00:41:47,760
All right, so let's
try to write that out.

854
00:41:54,180 --> 00:41:58,926
The first thing I'm going to
write out is kind of a break.

855
00:41:58,926 --> 00:42:03,480
If I'm at a base case, let's
not do anything to this thing.

856
00:42:03,480 --> 00:42:04,920
And maybe I also
want some bounce

857
00:42:04,920 --> 00:42:07,980
checking to make sure
that we're in range.

858
00:42:07,980 --> 00:42:14,917
OK, so I'm going to say,
if our K is less than 1,

859
00:42:14,917 --> 00:42:17,250
I don't think we should be
doing anything to this array.

860
00:42:17,250 --> 00:42:19,260
So let's just not do anything.

861
00:42:19,260 --> 00:42:26,700
If K is less than
1 or K is bigger

862
00:42:26,700 --> 00:42:32,040
than the length of D minus
1-- so I don't know what

863
00:42:32,040 --> 00:42:36,620
to do if you're asking me to
shift more than the things I

864
00:42:36,620 --> 00:42:39,560
have, so let's not do that.

865
00:42:45,980 --> 00:42:48,980
Yeah-- because if
it was length of D,

866
00:42:48,980 --> 00:42:51,140
we would just not
move anything anyway,

867
00:42:51,140 --> 00:42:52,727
because we'd shift
the whole thing.

868
00:42:52,727 --> 00:42:54,060
So we don't have to do anything.

869
00:42:54,060 --> 00:42:54,410
All right.

870
00:42:54,410 --> 00:42:55,830
If we're in either
of these cases,

871
00:42:55,830 --> 00:43:00,042
we're just going to return,
because I either shouldn't

872
00:43:00,042 --> 00:43:02,000
do anything to the array
or I have no idea what

873
00:43:02,000 --> 00:43:04,100
you're talking about,
if it's negative

874
00:43:04,100 --> 00:43:05,710
or something like that.

875
00:43:05,710 --> 00:43:07,480
OK, so that's the first thing.

876
00:43:07,480 --> 00:43:09,760
Otherwise, what do we do?

877
00:43:09,760 --> 00:43:14,350
We shift one thing over and
then we make a recursive call.

878
00:43:14,350 --> 00:43:16,050
Does that make sense?

879
00:43:16,050 --> 00:43:18,920
OK.

880
00:43:18,920 --> 00:43:27,890
So we'll delete the first
thing as a temporary variable--

881
00:43:27,890 --> 00:43:28,865
delete first.

882
00:43:31,910 --> 00:43:40,220
And then we'll insert last, x.

883
00:43:44,732 --> 00:43:46,770
And then we need to
do the recursive call.

884
00:43:46,770 --> 00:43:49,040
So what's a recursive
call look like?

885
00:43:49,040 --> 00:43:49,540
Yeah?

886
00:43:49,540 --> 00:43:51,995
STUDENT: Shift_left
D, K minus 1--

887
00:43:51,995 --> 00:43:52,620
JASON KU: Yeah.

888
00:43:52,620 --> 00:44:00,540
So shift_left D, K minus 1--

889
00:44:00,540 --> 00:44:02,550
OK?

890
00:44:02,550 --> 00:44:04,808
And then we can return.

891
00:44:04,808 --> 00:44:06,600
This thing doesn't need
to return anything.

892
00:44:06,600 --> 00:44:08,310
It's just doing
stuff to the thing.

893
00:44:08,310 --> 00:44:09,910
Right?

894
00:44:09,910 --> 00:44:13,090
And whenever we
get this K, we make

895
00:44:13,090 --> 00:44:17,830
a call, that gets down
to 0, we will terminate

896
00:44:17,830 --> 00:44:19,780
because we will return.

897
00:44:19,780 --> 00:44:22,180
We're in this range
somewhere between we--

898
00:44:22,180 --> 00:44:24,860
have an input after this line.

899
00:44:24,860 --> 00:44:30,070
We know that K is somewhere
between 1 and n minus 1.

900
00:44:30,070 --> 00:44:33,160
And what we'll do is, every
time through this recursion,

901
00:44:33,160 --> 00:44:36,800
we will subtract 1
from K. So this is

902
00:44:36,800 --> 00:44:40,270
a nice, well-ordered sequence.

903
00:44:40,270 --> 00:44:45,150
We do the correct thing
obviously in the base case,

904
00:44:45,150 --> 00:44:48,270
and as long as this thing
was correct for a smaller

905
00:44:48,270 --> 00:44:52,650
value of K, this thing also
does the correct thing,

906
00:44:52,650 --> 00:44:55,710
because we're shifting
over one, as we are asked,

907
00:44:55,710 --> 00:44:59,460
and we're letting this
do the work of the rest.

908
00:44:59,460 --> 00:45:01,110
I don't have to
think about that.

909
00:45:01,110 --> 00:45:04,990
I just have to think about
this one loop, this one part

910
00:45:04,990 --> 00:45:06,520
of the thing that I'm doing.

911
00:45:06,520 --> 00:45:08,890
Constant amount of work
is done in this section.

912
00:45:08,890 --> 00:45:12,430
And how many times
do I call a function?

913
00:45:12,430 --> 00:45:13,545
STUDENT: [INAUDIBLE]

914
00:45:13,545 --> 00:45:14,170
JASON KU: Yeah.

915
00:45:14,170 --> 00:45:15,818
I think K minus 1 times, or--

916
00:45:15,818 --> 00:45:16,360
I don't know.

917
00:45:16,360 --> 00:45:16,900
I forget.

918
00:45:16,900 --> 00:45:18,940
But it's ordered
K for sure, right?

919
00:45:18,940 --> 00:45:22,090
And we do a constant
amount of work per call,

920
00:45:22,090 --> 00:45:24,340
ignoring this extra call.

921
00:45:24,340 --> 00:45:26,230
Does that make sense?

922
00:45:26,230 --> 00:45:31,330
So this thing runs in
order K, as desired.

923
00:45:31,330 --> 00:45:32,140
OK?

924
00:45:32,140 --> 00:45:33,700
Does that make sense?

925
00:45:33,700 --> 00:45:34,900
All right.

926
00:45:34,900 --> 00:45:39,090
So now we will move
on to question 3.

927
00:45:43,000 --> 00:45:45,190
Any questions about question 2?

928
00:45:45,190 --> 00:45:48,190
That one's really probably
one of the easiest problems

929
00:45:48,190 --> 00:45:51,490
we've ever had on a problem set.

930
00:45:51,490 --> 00:45:54,750
Sorry to scare you.

931
00:45:54,750 --> 00:45:55,950
So problem 3--

932
00:45:55,950 --> 00:46:00,000
OK, so this is a little
block of text right here.

933
00:46:00,000 --> 00:46:02,430
A dynamic array can support
a sequence interface

934
00:46:02,430 --> 00:46:04,380
supporting worst case
constant time indexing

935
00:46:04,380 --> 00:46:06,210
as well as insertion
and removal of items

936
00:46:06,210 --> 00:46:09,570
at the back of the array
in amortized constant time.

937
00:46:09,570 --> 00:46:12,420
So this is what we did
yesterday in lecture, right?

938
00:46:12,420 --> 00:46:14,670
We showed how a dynamic array--

939
00:46:14,670 --> 00:46:19,800
it's fast to do dynamic
operations at the end.

940
00:46:19,800 --> 00:46:20,610
OK.

941
00:46:20,610 --> 00:46:22,620
However, insertion and
deletion at the front

942
00:46:22,620 --> 00:46:25,360
is not very efficient because,
if you tried to do that,

943
00:46:25,360 --> 00:46:27,150
you'd have to shift
everything over.

944
00:46:27,150 --> 00:46:28,440
That makes sense?

945
00:46:28,440 --> 00:46:30,960
All right, on the other hand,
what we talked about yesterday

946
00:46:30,960 --> 00:46:32,790
was linked lists.

947
00:46:32,790 --> 00:46:37,530
They can be made to support
insertion and deletion

948
00:46:37,530 --> 00:46:38,998
at both ends in constant time.

949
00:46:38,998 --> 00:46:41,040
OK, so that's a little
foreshadowing of something

950
00:46:41,040 --> 00:46:43,470
you're going to do on Pset1.

951
00:46:43,470 --> 00:46:47,880
But in lecture, we talked
about that operation--

952
00:46:47,880 --> 00:46:50,280
that data structure,
a singly linked list,

953
00:46:50,280 --> 00:46:53,760
being good at dynamic operations
at the front of the list,

954
00:46:53,760 --> 00:46:55,440
because essentially,
we could just

955
00:46:55,440 --> 00:46:57,030
remember where the
front of the list

956
00:46:57,030 --> 00:47:01,050
was and swap things
in as needed.

957
00:47:01,050 --> 00:47:01,852
That makes sense?

958
00:47:01,852 --> 00:47:03,810
So on your problem set,
what you're going to do

959
00:47:03,810 --> 00:47:09,120
is make end operations good
on the linked list as well,

960
00:47:09,120 --> 00:47:13,320
as well as supporting
another operation.

961
00:47:13,320 --> 00:47:17,340
But what's the problem
with linked lists,

962
00:47:17,340 --> 00:47:20,890
as compared to dynamic arrays?

963
00:47:20,890 --> 00:47:21,390
Yeah?

964
00:47:21,390 --> 00:47:25,110
STUDENT: Linked list lookups
can take up to linear time.

965
00:47:25,110 --> 00:47:26,610
JASON KU: Yeah,
linked lists lookups

966
00:47:26,610 --> 00:47:29,220
can take linear time,
because I have no--

967
00:47:29,220 --> 00:47:32,520
I don't have the benefit of
an array, where I can randomly

968
00:47:32,520 --> 00:47:36,480
access something in the middle
by essentially just doing

969
00:47:36,480 --> 00:47:38,820
one arithmetic
offset calculation

970
00:47:38,820 --> 00:47:43,920
from the front address and be
able to find this thing further

971
00:47:43,920 --> 00:47:47,520
down in constant time using
our model of computation

972
00:47:47,520 --> 00:47:49,770
of the random net
access machine.

973
00:47:49,770 --> 00:47:51,510
In a linked list,
these things could

974
00:47:51,510 --> 00:47:53,220
be stored all over
the place in memory,

975
00:47:53,220 --> 00:47:57,810
and I have to traverse those
pointers until I get to the one

976
00:47:57,810 --> 00:47:59,790
that I'm looking for.

977
00:47:59,790 --> 00:48:03,030
That's a benefit of
an array-based data

978
00:48:03,030 --> 00:48:07,170
structure versus a
linked, pointer-based one.

979
00:48:07,170 --> 00:48:11,280
OK, so then we get to the
meat of this question.

980
00:48:11,280 --> 00:48:14,250
Show that we can have
the best of both worlds--

981
00:48:14,250 --> 00:48:17,250
we can have a data
structure that

982
00:48:17,250 --> 00:48:20,700
supports worst case
constant time lookup, just

983
00:48:20,700 --> 00:48:25,790
like an array, but amortized
constant time dynamic

984
00:48:25,790 --> 00:48:31,220
operations from the back and
the front of the sequence.

985
00:48:31,220 --> 00:48:33,220
Does that make sense?

986
00:48:33,220 --> 00:48:34,420
All right.

987
00:48:34,420 --> 00:48:35,630
Is this question or a--

988
00:48:35,630 --> 00:48:36,130
OK.

989
00:48:36,130 --> 00:48:38,088
STUDENT: Can you define
amortize one more time?

990
00:48:38,088 --> 00:48:39,070
JASON KU: Yes.

991
00:48:39,070 --> 00:48:40,540
Sorry about that.

992
00:48:40,540 --> 00:48:42,550
Can I define amortize
one more time?

993
00:48:42,550 --> 00:48:50,260
OK, so this is a tough
thing to define in general,

994
00:48:50,260 --> 00:48:52,090
but not that much.

995
00:48:52,090 --> 00:48:56,602
All right, so amortization
usually you put in--

996
00:48:56,602 --> 00:48:58,060
at least in this
class, we're going

997
00:48:58,060 --> 00:49:00,520
to put in terms of
a data structure.

998
00:49:00,520 --> 00:49:02,110
So you have this thing.

999
00:49:02,110 --> 00:49:03,880
It supports some
operations, and you're

1000
00:49:03,880 --> 00:49:06,850
going to do a bunch of
operations on that thing.

1001
00:49:06,850 --> 00:49:09,100
There's not really a reason
to have a data structure,

1002
00:49:09,100 --> 00:49:11,740
unless you're going to
do lots of things to it.

1003
00:49:11,740 --> 00:49:14,530
Otherwise, you just
write a single algorithm

1004
00:49:14,530 --> 00:49:18,745
to do whatever it is
that you want to do.

1005
00:49:18,745 --> 00:49:20,830
The value of the
data structure is

1006
00:49:20,830 --> 00:49:23,590
that you can do
some work up front

1007
00:49:23,590 --> 00:49:28,090
by making this thing make some
of these operations faster.

1008
00:49:28,090 --> 00:49:28,720
OK?

1009
00:49:28,720 --> 00:49:33,100
So what amortization
means is, OK,

1010
00:49:33,100 --> 00:49:36,790
if I have, say, a
dynamic array, where

1011
00:49:36,790 --> 00:49:42,190
I'm going to be inserting
things at the end,

1012
00:49:42,190 --> 00:49:45,070
sometimes, when I
add something, I'm

1013
00:49:45,070 --> 00:49:47,430
going to spend a lot of
time to add that thing.

1014
00:49:47,430 --> 00:49:49,540
I'm going to spend linear time.

1015
00:49:49,540 --> 00:49:51,992
But what's the
point of this data

1016
00:49:51,992 --> 00:49:53,200
structure in the first place?

1017
00:49:53,200 --> 00:49:56,500
The point is that I want to
be able to potentially add

1018
00:49:56,500 --> 00:49:58,330
a lot of things to this thing.

1019
00:49:58,330 --> 00:50:00,430
Does that make sense?

1020
00:50:00,430 --> 00:50:03,310
Amortization is saying
that, even though sometimes

1021
00:50:03,310 --> 00:50:09,007
this operation will be bad,
averaged over many operations,

1022
00:50:09,007 --> 00:50:10,840
this is going to have
a better running time.

1023
00:50:10,840 --> 00:50:11,840
That's the amortization.

1024
00:50:11,840 --> 00:50:14,590
So more formally, what
that's going to say is,

1025
00:50:14,590 --> 00:50:17,920
if I have an operation, the
definition of it running

1026
00:50:17,920 --> 00:50:23,850
in amortized some amount
of time-- say K time or--

1027
00:50:23,850 --> 00:50:30,080
yeah, sure-- that means
that, if I do n operations,

1028
00:50:30,080 --> 00:50:32,870
generally for large N--

1029
00:50:32,870 --> 00:50:36,380
if I do that operation n
times, the total time it takes

1030
00:50:36,380 --> 00:50:39,410
me to do all of those
operations is not

1031
00:50:39,410 --> 00:50:42,290
going to be more than n
times K. So on average,

1032
00:50:42,290 --> 00:50:44,300
it's going to take me K time.

1033
00:50:44,300 --> 00:50:48,230
Now, in O-4-6 you'll get a
more formal definition of that

1034
00:50:48,230 --> 00:50:52,640
and you'll get a lot of
ways of analyzing things,

1035
00:50:52,640 --> 00:50:55,680
like a potential function and--

1036
00:50:55,680 --> 00:50:58,130
we're going to use in what
we call charging arguments

1037
00:50:58,130 --> 00:51:01,430
even today.

1038
00:51:01,430 --> 00:51:05,370
So it's a much broader
analysis paradigm

1039
00:51:05,370 --> 00:51:06,870
than what we're
going to talk about.

1040
00:51:06,870 --> 00:51:08,245
We're only going
to talk about it

1041
00:51:08,245 --> 00:51:10,880
for this material
with dynamic arrays,

1042
00:51:10,880 --> 00:51:12,320
and we'll just kind of--

1043
00:51:12,320 --> 00:51:14,488
it's just kind of an
introduction to that.

1044
00:51:14,488 --> 00:51:15,530
But does that make sense?

1045
00:51:15,530 --> 00:51:16,072
STUDENT: Yes.

1046
00:51:16,072 --> 00:51:19,790
JASON KU: Amortized as
a financial term, if you

1047
00:51:19,790 --> 00:51:24,690
know from financial term,
means over the long term,

1048
00:51:24,690 --> 00:51:26,030
this is what it is on average.

1049
00:51:26,030 --> 00:51:27,110
You can think about--

1050
00:51:27,110 --> 00:51:29,090
but that's different
than running time.

1051
00:51:29,090 --> 00:51:33,380
That's average running
time of an algorithm.

1052
00:51:33,380 --> 00:51:35,330
It's a much different concept.

1053
00:51:35,330 --> 00:51:38,000
What is an average running time?

1054
00:51:38,000 --> 00:51:40,310
Well, that's hard to
define, because it's

1055
00:51:40,310 --> 00:51:44,315
talking about an average over
all possible inputs, and then--

1056
00:51:44,315 --> 00:51:47,660
OK, so maybe some inputs
are more likely than others,

1057
00:51:47,660 --> 00:51:49,670
and so you've got a
distribution on the inputs

1058
00:51:49,670 --> 00:51:53,330
and you're trying to average
the running time of--

1059
00:51:53,330 --> 00:51:55,160
this has nothing
to do with that.

1060
00:51:55,160 --> 00:51:58,280
Amortization means that
you have a-- usually a data

1061
00:51:58,280 --> 00:52:00,650
structure that
you're operating on,

1062
00:52:00,650 --> 00:52:03,080
and you're doing an
operation multiple times,

1063
00:52:03,080 --> 00:52:05,390
and you're getting a
benefit because you're doing

1064
00:52:05,390 --> 00:52:07,200
that operation lots of times.

1065
00:52:07,200 --> 00:52:11,120
And so when you are
instantiating a Python list

1066
00:52:11,120 --> 00:52:15,590
and you're doing push and
pop operations on the back,

1067
00:52:15,590 --> 00:52:16,250
that's--

1068
00:52:16,250 --> 00:52:17,370
or is it append--

1069
00:52:17,370 --> 00:52:18,203
STUDENT: [INAUDIBLE]

1070
00:52:18,203 --> 00:52:19,880
JASON KU: Append and pop?

1071
00:52:19,880 --> 00:52:20,420
OK.

1072
00:52:20,420 --> 00:52:25,820
I've been writing JavaScript
a little bit recently.

1073
00:52:25,820 --> 00:52:28,250
But so append and pop--

1074
00:52:28,250 --> 00:52:32,660
those operations, while
not cheap all the time,

1075
00:52:32,660 --> 00:52:37,070
are cheap well enough that, when
we analyze an entire algorithm

1076
00:52:37,070 --> 00:52:42,350
that might do a linear number
of appends to this list,

1077
00:52:42,350 --> 00:52:44,450
all of those appends
added together

1078
00:52:44,450 --> 00:52:46,352
will only take linear
time, because I've

1079
00:52:46,352 --> 00:52:47,560
done a linear number of them.

1080
00:52:47,560 --> 00:52:48,140
Does that make sense?

1081
00:52:48,140 --> 00:52:48,490
STUDENT: Yeah.

1082
00:52:48,490 --> 00:52:49,190
Thank you.

1083
00:52:49,190 --> 00:52:52,520
JASON KU: OK-- long-winded
answer to your question.

1084
00:52:52,520 --> 00:52:54,350
Sorry about that.

1085
00:52:54,350 --> 00:52:57,730
Any other questions
before we get going?

1086
00:52:57,730 --> 00:52:59,500
All right.

1087
00:52:59,500 --> 00:53:02,200
Anyone have any
ideas of how we can

1088
00:53:02,200 --> 00:53:07,330
use the ideas of a dynamic array
and make it good for operations

1089
00:53:07,330 --> 00:53:08,826
on both ends?

1090
00:53:08,826 --> 00:53:11,690
I'll let someone else answer.

1091
00:53:11,690 --> 00:53:14,350
I'll give a second, and
then go to you in a sec.

1092
00:53:14,350 --> 00:53:15,574
Yeah?

1093
00:53:15,574 --> 00:53:19,438
STUDENT: So [INAUDIBLE] dynamic
[INAUDIBLE] left true on one

1094
00:53:19,438 --> 00:53:20,750
end [INAUDIBLE]

1095
00:53:20,750 --> 00:53:21,480
JASON KU: Sure.

1096
00:53:21,480 --> 00:53:24,250
STUDENT: [INAUDIBLE] here we
could leave some [INAUDIBLE]

1097
00:53:24,250 --> 00:53:28,100
JASON KU: That's
an excellent idea.

1098
00:53:28,100 --> 00:53:31,390
We're going to talk about
two ways of doing this.

1099
00:53:31,390 --> 00:53:31,890
Right.

1100
00:53:31,890 --> 00:53:34,730
So what your colleague was
saying was that, in lecture,

1101
00:53:34,730 --> 00:53:37,730
when we're talking about
dynamic ways and we want to make

1102
00:53:37,730 --> 00:53:41,720
operations on the
right side-- the end--

1103
00:53:41,720 --> 00:53:46,100
fast, what we did was we
allocated some extra space

1104
00:53:46,100 --> 00:53:49,152
at the end, and then,
when we added things,

1105
00:53:49,152 --> 00:53:50,360
we didn't have to reallocate.

1106
00:53:50,360 --> 00:53:52,700
We had space to
put those things.

1107
00:53:52,700 --> 00:53:55,850
So what your colleague
was saying was,

1108
00:53:55,850 --> 00:53:58,730
let's just do the same
thing on both ends.

1109
00:53:58,730 --> 00:54:01,970
Let's leave some extra space
on the front and extra space

1110
00:54:01,970 --> 00:54:04,490
on the back when we
instantiate this thing,

1111
00:54:04,490 --> 00:54:09,650
and then we can rebuild
less frequently than if we

1112
00:54:09,650 --> 00:54:11,140
didn't have that extra space.

1113
00:54:11,140 --> 00:54:12,140
Does that makes sense?

1114
00:54:12,140 --> 00:54:18,000
OK, so what we had for,
let's say, down here--

1115
00:54:18,000 --> 00:54:20,000
so this is question 3--

1116
00:54:20,000 --> 00:54:22,640
the idea of the
dynamic array right

1117
00:54:22,640 --> 00:54:29,600
was that we left some
extra space here at the end

1118
00:54:29,600 --> 00:54:34,700
so that, sure, we allocated
more than we needed to,

1119
00:54:34,700 --> 00:54:38,570
but when we insert
things now, it's cheap.

1120
00:54:38,570 --> 00:54:42,410
And we don't have to allocate
more space for this thing

1121
00:54:42,410 --> 00:54:46,130
until we've done a linear
number of insertions.

1122
00:54:46,130 --> 00:54:47,510
This was n.

1123
00:54:47,510 --> 00:54:48,410
This was n.

1124
00:54:48,410 --> 00:54:51,200
Really any constant
factor will do here.

1125
00:54:51,200 --> 00:54:52,910
But if you had n
things here, we'd

1126
00:54:52,910 --> 00:54:55,700
be assured that I
wouldn't need to rebuild

1127
00:54:55,700 --> 00:54:59,870
this thing until I've done a
linear number of operations.

1128
00:54:59,870 --> 00:55:04,970
And so in a sense, I can charge
the linear time operation

1129
00:55:04,970 --> 00:55:09,140
of re-expanding this thing to
each one of those operations.

1130
00:55:09,140 --> 00:55:11,180
And so on average,
it'll be constant.

1131
00:55:11,180 --> 00:55:12,300
Does that makes sense?

1132
00:55:12,300 --> 00:55:12,800
Right.

1133
00:55:12,800 --> 00:55:16,430
So instead, what your
colleague was saying--

1134
00:55:16,430 --> 00:55:19,550
let's instantiate this
thing with some extra space

1135
00:55:19,550 --> 00:55:21,870
on both sides.

1136
00:55:21,870 --> 00:55:23,100
OK?

1137
00:55:23,100 --> 00:55:27,060
So now, as I insert thing here,
insert thing here-- blah, blah,

1138
00:55:27,060 --> 00:55:28,470
blah, blah, blah--

1139
00:55:28,470 --> 00:55:32,430
I'll definitely know that, after
a linear number of insertions,

1140
00:55:32,430 --> 00:55:34,170
when I rebuild this
thing, I'll have

1141
00:55:34,170 --> 00:55:37,170
done enough operations to pay
for that expensive operation.

1142
00:55:37,170 --> 00:55:38,860
Does that makes sense?

1143
00:55:38,860 --> 00:55:43,890
So that's the idea behind
expanding this dynamic array

1144
00:55:43,890 --> 00:55:48,520
to be kind of this dynamic deck.

1145
00:55:48,520 --> 00:55:51,120
It's a doubly ended
queue kind of system

1146
00:55:51,120 --> 00:55:55,670
where I can do dynamic
operations efficiently

1147
00:55:55,670 --> 00:55:57,170
on both ends.

1148
00:55:57,170 --> 00:56:01,890
So one of the things that
we talked about yesterday

1149
00:56:01,890 --> 00:56:06,290
was also removing
right at the end.

1150
00:56:06,290 --> 00:56:11,620
Removing items from
the back of this thing

1151
00:56:11,620 --> 00:56:14,290
will decrease the number of
items we're storing, right?

1152
00:56:14,290 --> 00:56:17,340
That makes sense.

1153
00:56:17,340 --> 00:56:19,970
And maybe we're just
fine with that right.

1154
00:56:23,210 --> 00:56:27,260
As a programmer, why
might you not like

1155
00:56:27,260 --> 00:56:30,710
just removing items
until you got to nothing,

1156
00:56:30,710 --> 00:56:32,940
and just leaving the
space where it is?

1157
00:56:32,940 --> 00:56:33,440
Yeah?

1158
00:56:33,440 --> 00:56:35,480
STUDENT: Might lock up a
lot of memory [INAUDIBLE]

1159
00:56:35,480 --> 00:56:36,105
JASON KU: Yeah.

1160
00:56:36,105 --> 00:56:38,670
So let's say, over the
course of my program,

1161
00:56:38,670 --> 00:56:40,580
I use this data structure.

1162
00:56:40,580 --> 00:56:43,310
I'm just trying to
fill it up with stuff,

1163
00:56:43,310 --> 00:56:47,570
and then I remove all
but like two things,

1164
00:56:47,570 --> 00:56:48,980
and then I go about my business.

1165
00:56:48,980 --> 00:56:50,270
I run through the program.

1166
00:56:50,270 --> 00:56:53,690
But I'm never really using
any but those two things

1167
00:56:53,690 --> 00:56:56,330
for the rest of my program.

1168
00:56:56,330 --> 00:56:57,350
But now I've got--

1169
00:56:57,350 --> 00:57:00,500
I don't know-- maybe I did
put 1,000, or a million,

1170
00:57:00,500 --> 00:57:03,335
or a billion things in that
thing, and then, when I--

1171
00:57:03,335 --> 00:57:08,160
as I decreased, as I removed
things from that item,

1172
00:57:08,160 --> 00:57:10,760
I still have all that
space there being taken up

1173
00:57:10,760 --> 00:57:14,780
by essentially nothing, because
I've removed everything from

1174
00:57:14,780 --> 00:57:15,620
it--

1175
00:57:15,620 --> 00:57:18,230
at least in my conception.

1176
00:57:18,230 --> 00:57:22,700
So what I would really like
to maintain with this data

1177
00:57:22,700 --> 00:57:26,060
structure is that
at no point in time

1178
00:57:26,060 --> 00:57:30,370
am I using more than a
linear amount of space

1179
00:57:30,370 --> 00:57:34,530
with respect to the number of
things that are stored in it.

1180
00:57:34,530 --> 00:57:37,100
Does that make sense?

1181
00:57:37,100 --> 00:57:43,780
So in a dynamic
array, what we do

1182
00:57:43,780 --> 00:57:51,260
is, when we get small enough,
let's resize this thing down

1183
00:57:51,260 --> 00:57:52,610
so that we have--

1184
00:57:52,610 --> 00:57:53,825
we're using less space.

1185
00:57:57,080 --> 00:57:59,330
As I'm decreasing,
as I'm popping things

1186
00:57:59,330 --> 00:58:03,030
from the end of this
thing, at what point

1187
00:58:03,030 --> 00:58:06,870
do you think I should
rebuild my array?

1188
00:58:06,870 --> 00:58:10,140
When I'm no longer
a linear amount?

1189
00:58:10,140 --> 00:58:13,560
Well, that's a little hard to
tell what that is in real life,

1190
00:58:13,560 --> 00:58:15,480
because our ends
aren't arbitrary.

1191
00:58:15,480 --> 00:58:21,420
We need to actually have a time
at which we need to transition

1192
00:58:21,420 --> 00:58:22,710
over and copy things over.

1193
00:58:22,710 --> 00:58:25,030
So when might we
want to do that?

1194
00:58:25,030 --> 00:58:26,267
STUDENT: [INAUDIBLE]

1195
00:58:26,267 --> 00:58:27,100
JASON KU: Say again.

1196
00:58:27,100 --> 00:58:29,440
STUDENT: After n/2 [INAUDIBLE]

1197
00:58:29,440 --> 00:58:31,840
JASON KU: After n/2 removals--

1198
00:58:31,840 --> 00:58:32,620
OK.

1199
00:58:32,620 --> 00:58:35,890
So I remove n/2 things.

1200
00:58:35,890 --> 00:58:40,570
OK, so now we're kind
of at a n/4 fill--

1201
00:58:40,570 --> 00:58:44,140
so we're using a
fourth of the space.

1202
00:58:44,140 --> 00:58:45,250
And now-- great.

1203
00:58:45,250 --> 00:58:46,390
So you're saying rebuild.

1204
00:58:46,390 --> 00:58:51,490
OK, so I'll stick everything
in something that's now--

1205
00:58:51,490 --> 00:58:52,870
this is m.

1206
00:58:52,870 --> 00:58:54,910
I'm going to call
this m, and now we're

1207
00:58:54,910 --> 00:58:59,200
sticking it into something
that has size m/4.

1208
00:58:59,200 --> 00:59:01,020
Sound good?

1209
00:59:01,020 --> 00:59:01,520
Yeah?

1210
00:59:04,270 --> 00:59:04,853
Yeah?

1211
00:59:04,853 --> 00:59:05,770
Everyone OK with this?

1212
00:59:05,770 --> 00:59:09,200
STUDENT: [INAUDIBLE]
m/4 [INAUDIBLE]

1213
00:59:09,200 --> 00:59:10,660
JASON KU: Oh, OK.

1214
00:59:10,660 --> 00:59:14,050
So what you're saying
is that we actually

1215
00:59:14,050 --> 00:59:17,470
want to keep some
extra space back here.

1216
00:59:17,470 --> 00:59:18,280
And why is that?

1217
00:59:21,630 --> 00:59:25,470
Because imagine if we just
allocated this amount of space,

1218
00:59:25,470 --> 00:59:30,720
and I removed the m/4
plus 1th item here,

1219
00:59:30,720 --> 00:59:34,040
we resized down to
this thing, and then I

1220
00:59:34,040 --> 00:59:35,290
want to do an insertion again.

1221
00:59:37,820 --> 00:59:41,300
Well, then I have to re expand
out to something like this,

1222
00:59:41,300 --> 00:59:44,495
and that's maybe not
going to be a good thing.

1223
00:59:44,495 --> 00:59:46,370
We might have to bounce
back and forth a lot.

1224
00:59:46,370 --> 00:59:50,000
That's hard for me to think
about what we're going to do.

1225
00:59:50,000 --> 00:59:55,340
But if we always resize
to a fill ratio that

1226
00:59:55,340 --> 00:59:58,550
includes a linear amount
of things on the end,

1227
00:59:58,550 --> 01:00:02,810
then I know that,
when I resize down,

1228
01:00:02,810 --> 01:00:05,780
I'll be doing either a
linear number of deletions

1229
01:00:05,780 --> 01:00:09,890
or a linear number of insertions
before I have to rebuild again.

1230
01:00:09,890 --> 01:00:11,807
So this charging
argument again--

1231
01:00:11,807 --> 01:00:13,640
I have to do a linear
number of cheap things

1232
01:00:13,640 --> 01:00:15,930
before I have to do an
expensive thing again.

1233
01:00:15,930 --> 01:00:16,790
OK?

1234
01:00:16,790 --> 01:00:20,300
So I resize down to be--

1235
01:00:20,300 --> 01:00:23,660
still keep a linear amount
of extra space at the end.

1236
01:00:23,660 --> 01:00:26,960
And with the double
ended thing, you

1237
01:00:26,960 --> 01:00:29,900
can write the same
kind of policy.

1238
01:00:29,900 --> 01:00:32,930
With the extra space, as
your colleague was saying,

1239
01:00:32,930 --> 01:00:39,920
we can just resize down always
to shift these things to be

1240
01:00:39,920 --> 01:00:44,865
placed in the middle with a
linear amount of extra space

1241
01:00:44,865 --> 01:00:45,365
on the ends.

1242
01:00:48,390 --> 01:00:51,390
Does that make sense?

1243
01:00:51,390 --> 01:00:53,180
No questions?

1244
01:00:53,180 --> 01:00:54,600
All right.

1245
01:00:54,600 --> 01:00:58,650
That was a way in which
we had to redefine

1246
01:00:58,650 --> 01:01:01,380
an entirely new data structure.

1247
01:01:01,380 --> 01:01:04,770
We took the ideas
behind dynamic arrays

1248
01:01:04,770 --> 01:01:08,340
and we extended those ideas
to make this thing have

1249
01:01:08,340 --> 01:01:09,660
extra space on both ends.

1250
01:01:09,660 --> 01:01:12,480
But we kind of had to do
that re-implementation

1251
01:01:12,480 --> 01:01:13,530
all by ourselves.

1252
01:01:13,530 --> 01:01:17,700
If we were doing code, that
would be kind of gnarly.

1253
01:01:17,700 --> 01:01:21,480
But what if someone just
gave us a dynamic array?

1254
01:01:21,480 --> 01:01:23,640
What if someone gave
you a Python list,

1255
01:01:23,640 --> 01:01:27,810
and you wanted
this functionality?

1256
01:01:27,810 --> 01:01:29,700
I don't want to reimplement
a dynamic array,

1257
01:01:29,700 --> 01:01:31,590
but I want this
behavior, so how--

1258
01:01:31,590 --> 01:01:34,080
any way that I could
do that by reducing

1259
01:01:34,080 --> 01:01:37,860
to using a dynamic array--

1260
01:01:37,860 --> 01:01:39,110
get this kind of running time?

1261
01:01:42,890 --> 01:01:43,520
No?

1262
01:01:43,520 --> 01:01:46,630
No one thinks that
we can do this.

1263
01:01:46,630 --> 01:01:48,760
This is impossible.

1264
01:01:48,760 --> 01:01:49,260
No?

1265
01:01:49,260 --> 01:01:49,950
No ideas?

1266
01:01:53,500 --> 01:01:57,640
No ideas-- let's say I had--

1267
01:01:57,640 --> 01:02:05,690
I have a dynamic array
that's good on one side.

1268
01:02:08,400 --> 01:02:11,393
Is there anything I can do
to support dynamic operations

1269
01:02:11,393 --> 01:02:12,560
on both sides of a sequence?

1270
01:02:15,070 --> 01:02:15,570
Yeah?

1271
01:02:15,570 --> 01:02:24,450
STUDENT: Are we able
to just use [INAUDIBLE]

1272
01:02:24,450 --> 01:02:27,000
JASON KU: Oh, that's
supposed to be empty, right?

1273
01:02:30,590 --> 01:02:31,090
Yeah.

1274
01:02:31,090 --> 01:02:34,170
So what your colleague is
saying-- yeah, let's do that.

1275
01:02:34,170 --> 01:02:35,740
Let's have one
pointing forwards,

1276
01:02:35,740 --> 01:02:37,090
one pointing backwards.

1277
01:02:37,090 --> 01:02:39,550
This is the first
of a certain thing.

1278
01:02:39,550 --> 01:02:42,970
When we were doing just
a dynamic array here,

1279
01:02:42,970 --> 01:02:44,920
where we had to
rebuild everything,

1280
01:02:44,920 --> 01:02:46,720
it was important
that we kept track

1281
01:02:46,720 --> 01:02:52,630
of where the front thing was so
that we could do time indexing.

1282
01:02:52,630 --> 01:02:55,540
As this thing
changed, we would now

1283
01:02:55,540 --> 01:02:58,450
have to compute where our
index was in this thing

1284
01:02:58,450 --> 01:03:02,280
by adding it to
where the front was.

1285
01:03:02,280 --> 01:03:05,760
On this one, we've got
some similar problems.

1286
01:03:05,760 --> 01:03:07,260
So what I'm going
to do is I'm going

1287
01:03:07,260 --> 01:03:09,690
to divide the
sequence I'm trying

1288
01:03:09,690 --> 01:03:17,050
to store up into two sections,
maybe about the same size.

1289
01:03:17,050 --> 01:03:19,922
So each of these contains
a linear number of items.

1290
01:03:19,922 --> 01:03:21,380
That's how I'm
going to instantiate

1291
01:03:21,380 --> 01:03:24,710
my thing with a linear amount
of extra space on both ends.

1292
01:03:24,710 --> 01:03:28,160
So now, as I insert
on either side

1293
01:03:28,160 --> 01:03:30,980
or delete from either side,
it's going to work just

1294
01:03:30,980 --> 01:03:32,720
like a dynamic array.

1295
01:03:32,720 --> 01:03:36,290
I have to do some arithmetic
here to figure out where--

1296
01:03:36,290 --> 01:03:38,720
if I was trying to
access these items,

1297
01:03:38,720 --> 01:03:42,530
I'd have to subtract from
wherever this thing--

1298
01:03:42,530 --> 01:03:46,250
I have to do some index
arithmetic, but that's tedious,

1299
01:03:46,250 --> 01:03:49,400
but you could do it.

1300
01:03:49,400 --> 01:03:50,450
OK.

1301
01:03:50,450 --> 01:03:53,480
There's one caveat,
one problem that you

1302
01:03:53,480 --> 01:03:56,400
run into in using
something like this.

1303
01:03:56,400 --> 01:03:58,540
And what would that be?

1304
01:03:58,540 --> 01:03:59,110
Yeah?

1305
01:03:59,110 --> 01:04:01,400
STUDENT: I'm not
sure, but you store

1306
01:04:01,400 --> 01:04:06,430
things in the second
half of a dynamic array.

1307
01:04:06,430 --> 01:04:07,180
JASON KU: In here?

1308
01:04:07,180 --> 01:04:08,560
STUDENT: In the first one.

1309
01:04:08,560 --> 01:04:09,310
JASON KU: In here?

1310
01:04:09,310 --> 01:04:10,343
STUDENT: [INAUDIBLE]

1311
01:04:10,343 --> 01:04:11,010
JASON KU: Right.

1312
01:04:11,010 --> 01:04:12,670
So what I'm doing
here is actually,

1313
01:04:12,670 --> 01:04:17,290
I'm thinking of this
as two dynamic arrays,

1314
01:04:17,290 --> 01:04:20,980
but I'm viewing
this one in reverse.

1315
01:04:20,980 --> 01:04:26,530
So this is actually the
last of this dynamic array.

1316
01:04:26,530 --> 01:04:27,740
Does that make sense?

1317
01:04:27,740 --> 01:04:28,480
All right.

1318
01:04:28,480 --> 01:04:33,370
So if that's the
situation I'm in, is--

1319
01:04:33,370 --> 01:04:34,440
am I done?

1320
01:04:34,440 --> 01:04:38,060
Do I have to care
about anything else?

1321
01:04:38,060 --> 01:04:39,920
You guys are all
like, we're done,

1322
01:04:39,920 --> 01:04:43,178
and I would not give
you full points.

1323
01:04:43,178 --> 01:04:43,970
Why aren't we done?

1324
01:04:48,230 --> 01:04:48,730
Yeah?

1325
01:04:48,730 --> 01:04:59,953
STUDENT: [INAUDIBLE]

1326
01:04:59,953 --> 01:05:02,120
JASON KU: OK, so what your
colleague is saying is we

1327
01:05:02,120 --> 01:05:04,440
somehow got to merge
these into one array.

1328
01:05:04,440 --> 01:05:08,000
So we're getting around that
by keeping indexes to here

1329
01:05:08,000 --> 01:05:11,630
and being able to do index
arithmetic to kind of simulate

1330
01:05:11,630 --> 01:05:13,280
an array underneath.

1331
01:05:13,280 --> 01:05:17,880
So we can compute where
these indices should be.

1332
01:05:17,880 --> 01:05:22,005
Anyone have another problem
with an underspecified data

1333
01:05:22,005 --> 01:05:22,630
structure here?

1334
01:05:22,630 --> 01:05:23,130
Yeah?

1335
01:05:23,130 --> 01:05:29,263
STUDENT: [INAUDIBLE] it
could be that [INAUDIBLE]

1336
01:05:29,263 --> 01:05:29,930
JASON KU: I see.

1337
01:05:29,930 --> 01:05:31,560
So what your
colleague is saying,

1338
01:05:31,560 --> 01:05:33,300
which is exactly correct--

1339
01:05:33,300 --> 01:05:35,390
if I were removing
things, removing things,

1340
01:05:35,390 --> 01:05:39,230
removing things, I have
nothing else in here.

1341
01:05:39,230 --> 01:05:40,993
If I try to pop
from this end again,

1342
01:05:40,993 --> 01:05:43,410
I'm going to have to pop from
the beginning of this thing,

1343
01:05:43,410 --> 01:05:45,350
which I don't really--

1344
01:05:45,350 --> 01:05:47,998
that's going to break
something of what I'm doing.

1345
01:05:47,998 --> 01:05:49,790
It's not maintaining
the invariants of what

1346
01:05:49,790 --> 01:05:51,540
I want on my data structure.

1347
01:05:51,540 --> 01:05:55,190
And so the only caveat here
is that, when I reduce down

1348
01:05:55,190 --> 01:05:59,180
to one of these is
empty, what do I do?

1349
01:05:59,180 --> 01:06:01,960
STUDENT: You have to cut the
other one in half [INAUDIBLE]

1350
01:06:01,960 --> 01:06:05,553
JASON KU: You cut this thing in
half, move these elements over.

1351
01:06:05,553 --> 01:06:07,720
But that's going to leave
these things in the middle

1352
01:06:07,720 --> 01:06:09,990
here, right?

1353
01:06:09,990 --> 01:06:12,270
The nice thing that
happens here is

1354
01:06:12,270 --> 01:06:14,880
I've done a linear
number of options--

1355
01:06:14,880 --> 01:06:16,965
operations.

1356
01:06:16,965 --> 01:06:21,420
I now have an
amortized cost build-up

1357
01:06:21,420 --> 01:06:25,860
that I can spend to now rebuild
the entire data structure.

1358
01:06:25,860 --> 01:06:27,390
Does that make sense?

1359
01:06:27,390 --> 01:06:30,630
I can now, once I get down
to this thing, take whatever

1360
01:06:30,630 --> 01:06:33,000
the remaining things
are, split it in half,

1361
01:06:33,000 --> 01:06:36,210
put it into two entirely new
arrays, copy them all over,

1362
01:06:36,210 --> 01:06:39,190
and now I've restored my
invariant, where I'm, again,

1363
01:06:39,190 --> 01:06:41,310
a linear amount
of operations away

1364
01:06:41,310 --> 01:06:45,690
from having to do an
expensive operation again.

1365
01:06:45,690 --> 01:06:48,400
Does that make sense?

1366
01:06:48,400 --> 01:06:52,470
So while we were able to reduce
to using these dynamic arrays

1367
01:06:52,470 --> 01:06:56,130
for a lot of the
cases, we actually

1368
01:06:56,130 --> 01:07:01,140
had to do a little bit more
work to make this work out.

1369
01:07:01,140 --> 01:07:03,090
That make sense?

1370
01:07:03,090 --> 01:07:08,430
OK, cool-- so that's two ways
of approaching problem 3.

1371
01:07:08,430 --> 01:07:11,340
In the last little
bit, we're going

1372
01:07:11,340 --> 01:07:14,900
to talk about the last problem.

1373
01:07:14,900 --> 01:07:16,450
All right, that makes sense.

1374
01:07:16,450 --> 01:07:18,420
I'm going to erase this picture,
if that's all right with you

1375
01:07:18,420 --> 01:07:18,920
guys.

1376
01:07:21,570 --> 01:07:22,457
STUDENT: [INAUDIBLE]

1377
01:07:22,457 --> 01:07:23,290
JASON KU: What's up?

1378
01:07:23,290 --> 01:07:24,940
It's not all right?

1379
01:07:24,940 --> 01:07:28,270
Well, too bad-- watch the video.

1380
01:07:28,270 --> 01:07:31,240
OK, so problem 4--

1381
01:07:31,240 --> 01:07:39,940
also a fairly accessible,
shall we say, coding question--

1382
01:07:39,940 --> 01:07:41,770
what we're doing on
problem 4 is we've

1383
01:07:41,770 --> 01:07:44,890
got this nice little story
at the beginning, which

1384
01:07:44,890 --> 01:07:48,250
is about this woman
Jen and her friend

1385
01:07:48,250 --> 01:07:51,370
Barry, who are trying to sell
ice cream to elementary school

1386
01:07:51,370 --> 01:07:52,100
kids.

1387
01:07:52,100 --> 01:07:54,010
They're basically lined
up at Jen's truck,

1388
01:07:54,010 --> 01:07:56,650
and she's like, oh, there's
too many students here.

1389
01:07:56,650 --> 01:07:58,075
So she calls up
her friend Barry.

1390
01:07:58,075 --> 01:08:02,050
He has another ice cream truck,
parts at the end of the line,

1391
01:08:02,050 --> 01:08:03,760
and the students--
what they want to do

1392
01:08:03,760 --> 01:08:06,160
is, to make it more
fair, is they're

1393
01:08:06,160 --> 01:08:08,530
going to take the
last half of the line,

1394
01:08:08,530 --> 01:08:12,070
reverse it to make it more fair.

1395
01:08:12,070 --> 01:08:12,670
I don't know.

1396
01:08:12,670 --> 01:08:16,330
It's a stupid situation, but
the underlying thing is what

1397
01:08:16,330 --> 01:08:20,529
we're doing is-- part
A here is we have--

1398
01:08:20,529 --> 01:08:23,410
we're giving you a linked list--

1399
01:08:23,410 --> 01:08:31,000
a singly linked list, and
what I want you to do--

1400
01:08:31,000 --> 01:08:32,500
the singly linked list--

1401
01:08:32,500 --> 01:08:37,810
all it has is a notion
of size, how long it is.

1402
01:08:37,810 --> 01:08:42,819
It has a size and it
has a head this list--

1403
01:08:42,819 --> 01:08:46,750
it has a size and it has a head.

1404
01:08:46,750 --> 01:08:48,790
And this head is a
pointer to a node,

1405
01:08:48,790 --> 01:08:52,890
and the node has just one--

1406
01:08:52,890 --> 01:08:54,680
two things stored in it.

1407
01:08:54,680 --> 01:08:59,580
It has who-- the name of
the child that's there,

1408
01:08:59,580 --> 01:09:01,950
and the next pointer
to the next node.

1409
01:09:01,950 --> 01:09:03,510
That's what a singly
linked list is.

1410
01:09:03,510 --> 01:09:10,843
So node has an item
key and a next pointer.

1411
01:09:10,843 --> 01:09:13,260
This next pointer points to
the next node in the sequence.

1412
01:09:13,260 --> 01:09:14,990
OK?

1413
01:09:14,990 --> 01:09:22,229
And the question is asking, if
we give you a linked list that

1414
01:09:22,229 --> 01:09:28,330
has 2n nodes, I want you
to take the last n nodes,

1415
01:09:28,330 --> 01:09:33,910
and reverse their order, and
do this to the data structure.

1416
01:09:33,910 --> 01:09:38,020
You're not going to return
a new data structure.

1417
01:09:38,020 --> 01:09:40,149
You're going to modify
the existing nodes.

1418
01:09:40,149 --> 01:09:42,805
And actually, here is--
goes back to your question.

1419
01:09:46,510 --> 01:09:50,229
What are we limited to in
how we approach this problem?

1420
01:09:50,229 --> 01:09:53,200
What this problem serves as
your algorithm should not

1421
01:09:53,200 --> 01:09:57,370
make any new linked list nodes
or instantiate any new non

1422
01:09:57,370 --> 01:09:59,390
constant sized data structures.

1423
01:09:59,390 --> 01:10:03,580
So it's not like I can write
through this whole thing,

1424
01:10:03,580 --> 01:10:06,820
find out where the
n plus 1th node is,

1425
01:10:06,820 --> 01:10:09,940
read out all of those
names, store them

1426
01:10:09,940 --> 01:10:14,230
in an array somewhere, and
then rewrite them back out.

1427
01:10:14,230 --> 01:10:17,410
I'm not allowed to store
more than a constant amount

1428
01:10:17,410 --> 01:10:19,390
of stuff outside of
this linked list,

1429
01:10:19,390 --> 01:10:21,430
and I'm not able to
make any new nodes.

1430
01:10:21,430 --> 01:10:24,400
Essentially, I just have to
probably keep these items

1431
01:10:24,400 --> 01:10:27,040
where they are and
move around the nodes.

1432
01:10:27,040 --> 01:10:27,867
Yeah?

1433
01:10:27,867 --> 01:10:29,695
STUDENT: Can you use
non-constant space

1434
01:10:29,695 --> 01:10:32,440
without creating
a data structure?

1435
01:10:32,440 --> 01:10:36,280
JASON KU: So if you're
using non-constant space,

1436
01:10:36,280 --> 01:10:38,470
you're instantiating some
kind of data structure,

1437
01:10:38,470 --> 01:10:41,380
whether it be in an array or--

1438
01:10:41,380 --> 01:10:46,150
STUDENT: [INAUDIBLE]

1439
01:10:46,150 --> 01:10:46,840
JASON KU: Sure.

1440
01:10:46,840 --> 01:10:49,630
I'm wanting you not to do that.

1441
01:10:49,630 --> 01:10:50,130
Yeah.

1442
01:10:54,600 --> 01:10:58,250
Any other questions?

1443
01:10:58,250 --> 01:11:03,590
So how are we going
to do this problem?

1444
01:11:08,940 --> 01:11:10,740
Anybody?

1445
01:11:10,740 --> 01:11:13,590
Anyone have approach for how
I might approach this problem?

1446
01:11:13,590 --> 01:11:15,330
Yeah?

1447
01:11:15,330 --> 01:11:18,000
STUDENT: In order to
get to the second half

1448
01:11:18,000 --> 01:11:21,095
you don't have to do
all of that [INAUDIBLE]

1449
01:11:21,095 --> 01:11:21,720
JASON KU: Sure.

1450
01:11:21,720 --> 01:11:22,803
STUDENT: Could you start--

1451
01:11:25,410 --> 01:11:27,120
probably start
counting backwards so

1452
01:11:27,120 --> 01:11:29,310
that you can get them
in the back order,

1453
01:11:29,310 --> 01:11:31,783
and then meet it in the
middle so [INAUDIBLE]

1454
01:11:31,783 --> 01:11:32,700
JASON KU: Interesting.

1455
01:11:32,700 --> 01:11:36,103
So there's a lot of things--

1456
01:11:36,103 --> 01:11:37,020
let's break this down.

1457
01:11:37,020 --> 01:11:38,580
So a lot of times,
when we're asking

1458
01:11:38,580 --> 01:11:42,710
you to construct an
algorithm-- a lot of times,

1459
01:11:42,710 --> 01:11:45,650
it makes sense to develop
an outline or a game

1460
01:11:45,650 --> 01:11:48,980
plan of constituent
parts that you might want

1461
01:11:48,980 --> 01:11:51,050
to approach this problem with.

1462
01:11:51,050 --> 01:11:53,810
So the first thing that your
colleague over here was saying

1463
01:11:53,810 --> 01:11:56,000
was, at some point, we
need to find out where

1464
01:11:56,000 --> 01:11:58,306
the middle of this thing is.

1465
01:11:58,306 --> 01:12:00,320
Does that makes sense?

1466
01:12:00,320 --> 01:12:06,350
So maybe the first thing we want
to do to approach this problem

1467
01:12:06,350 --> 01:12:12,890
is, one, find n-th node.

1468
01:12:15,410 --> 01:12:18,180
That's the end of the
first set of children.

1469
01:12:18,180 --> 01:12:18,680
OK?

1470
01:12:22,400 --> 01:12:28,812
Then I have a second
thing that I want to do.

1471
01:12:28,812 --> 01:12:30,270
What's the next
thing I have to do?

1472
01:12:30,270 --> 01:12:33,870
I have to reverse the
pointers of everything

1473
01:12:33,870 --> 01:12:36,030
after the n-th node, right?

1474
01:12:36,030 --> 01:12:40,080
OK, so second thing--

1475
01:12:40,080 --> 01:12:58,470
reverse, I guess, next pointers
of everything after the n-th

1476
01:12:58,470 --> 01:13:00,810
node--

1477
01:13:00,810 --> 01:13:03,345
the nodes n plus 1 to 2n.

1478
01:13:03,345 --> 01:13:04,220
Does that make sense?

1479
01:13:06,980 --> 01:13:10,850
And after I reversed all of
those things, what do I have?

1480
01:13:10,850 --> 01:13:13,690
I have a first block.

1481
01:13:13,690 --> 01:13:15,310
This points like that.

1482
01:13:15,310 --> 01:13:20,380
And now we've got this
thing, and we've reversed

1483
01:13:20,380 --> 01:13:24,880
all the pointers like this.

1484
01:13:27,460 --> 01:13:30,160
That's after step 2.

1485
01:13:30,160 --> 01:13:31,750
Is that what we want?

1486
01:13:35,060 --> 01:13:35,560
Yeah?

1487
01:13:35,560 --> 01:13:44,020
STUDENT: Step 3
would be [INAUDIBLE]

1488
01:13:44,020 --> 01:13:47,170
JASON KU: So this is my new end.

1489
01:13:47,170 --> 01:13:52,810
I'm going to call this
node a, and this node b,

1490
01:13:52,810 --> 01:13:58,658
and this node C. So tell
me, in terms of a, b,

1491
01:13:58,658 --> 01:13:59,950
and c, what I'm supposed to do.

1492
01:13:59,950 --> 01:14:00,310
Yeah?

1493
01:14:00,310 --> 01:14:01,893
STUDENT: Quick
question-- how would we

1494
01:14:01,893 --> 01:14:04,410
reverse the next pointer?

1495
01:14:04,410 --> 01:14:05,770
I get what you're saying, but--

1496
01:14:05,770 --> 01:14:06,437
JASON KU: Right.

1497
01:14:06,437 --> 01:14:08,170
STUDENT: --to actually
made that happen--

1498
01:14:08,170 --> 01:14:08,795
JASON KU: Yeah.

1499
01:14:08,795 --> 01:14:12,190
So to actually make that happen,
this thing has an next pointer.

1500
01:14:12,190 --> 01:14:15,160
It's pointed to--
pointing to some node.

1501
01:14:15,160 --> 01:14:17,710
I'm needing to relink it
to the thing before me,

1502
01:14:17,710 --> 01:14:20,380
so I better remember
what was before me

1503
01:14:20,380 --> 01:14:25,380
so I can set node b.next
equals the thing before me,

1504
01:14:25,380 --> 01:14:26,630
instead of the thing after me.

1505
01:14:26,630 --> 01:14:27,590
Does that make sense?

1506
01:14:27,590 --> 01:14:28,600
So that would be relinking the--

1507
01:14:28,600 --> 01:14:30,220
STUDENT: And then it
disconnects the linked list.

1508
01:14:30,220 --> 01:14:31,887
JASON KU: It disconnects
the linked list

1509
01:14:31,887 --> 01:14:32,993
possibly temporarily.

1510
01:14:32,993 --> 01:14:33,660
STUDENT: Oh, OK.

1511
01:14:33,660 --> 01:14:36,250
It's temporary, and therefore,
it still works out [INAUDIBLE]

1512
01:14:36,250 --> 01:14:38,530
JASON KU: Well, we have
to relink everything

1513
01:14:38,530 --> 01:14:40,050
to make sure it's temporary.

1514
01:14:42,870 --> 01:14:45,510
It's very possible, when
you're dealing with linked data

1515
01:14:45,510 --> 01:14:49,080
structures, to unlink something
and not have a reference back

1516
01:14:49,080 --> 01:14:51,570
to it, and now this
thing is in memory

1517
01:14:51,570 --> 01:14:55,110
that your garbage collector
hopefully will pick up.

1518
01:14:55,110 --> 01:14:56,880
But if you're writing
in a language that's

1519
01:14:56,880 --> 01:15:01,290
not garbage collected, then
that's called a memory leak.

1520
01:15:01,290 --> 01:15:03,500
That's no good.

1521
01:15:03,500 --> 01:15:05,930
OK, so how do I
relink these things?

1522
01:15:11,380 --> 01:15:13,480
This is the picture
that I have right now.

1523
01:15:13,480 --> 01:15:16,588
How do I make this into
a linked list, where

1524
01:15:16,588 --> 01:15:17,755
it's here and then reversed?

1525
01:15:20,610 --> 01:15:21,830
Yeah?

1526
01:15:21,830 --> 01:15:25,795
STUDENT: You can link
a to c [INAUDIBLE]

1527
01:15:25,795 --> 01:15:26,420
JASON KU: Yeah.

1528
01:15:26,420 --> 01:15:29,270
So I replace this
pointer from a to b

1529
01:15:29,270 --> 01:15:32,120
to make it point to
c instead, and then,

1530
01:15:32,120 --> 01:15:33,800
whatever my pointer is to b--

1531
01:15:33,800 --> 01:15:36,590
from b-- b is reversed--
it's pointing to a--

1532
01:15:36,590 --> 01:15:39,480
let's set that equal to none.

1533
01:15:39,480 --> 01:15:48,480
So basically, the last
step here is clean up ends.

1534
01:15:48,480 --> 01:15:53,430
And in LaTeX
write-up, you'd want

1535
01:15:53,430 --> 01:15:57,600
to specify, what are the
things that you're relinking?

1536
01:15:57,600 --> 01:16:00,480
But this was a coding
question, and so we actually

1537
01:16:00,480 --> 01:16:02,910
gave you code to work with.

1538
01:16:02,910 --> 01:16:08,400
So I'm going to see whether
I can live code this for you

1539
01:16:08,400 --> 01:16:09,180
in front of you.

1540
01:16:13,740 --> 01:16:14,240
OK.

1541
01:16:14,240 --> 01:16:21,050
So here was our code
submission site from last term.

1542
01:16:21,050 --> 01:16:25,580
And what I have here is my
template from last term, Pset1.

1543
01:16:25,580 --> 01:16:27,410
It opens this folder.

1544
01:16:27,410 --> 01:16:30,020
It's got a bunch
of things in it,

1545
01:16:30,020 --> 01:16:32,330
the LaTeX template
that you have,

1546
01:16:32,330 --> 01:16:34,790
and then a bunch of
these Python files.

1547
01:16:34,790 --> 01:16:37,050
So I'm going to--

1548
01:16:37,050 --> 01:16:38,340
where is it?

1549
01:16:38,340 --> 01:16:38,840
Here.

1550
01:16:38,840 --> 01:16:41,630
OK, so these are the files
that are in my directory.

1551
01:16:41,630 --> 01:16:45,650
I've given you a version of
this linked list sequence.

1552
01:16:45,650 --> 01:16:48,290
And then we have two more
code questions-- a tests file

1553
01:16:48,290 --> 01:16:50,570
and a reorder_students file.

1554
01:16:50,570 --> 01:16:54,950
So reorder_students look
something like this.

1555
01:16:54,950 --> 01:16:57,260
It has a template of
the code that we're

1556
01:16:57,260 --> 01:16:59,630
going to want you to write,
with inputs and outputs.

1557
01:16:59,630 --> 01:17:02,000
And you're putting
your code here.

1558
01:17:02,000 --> 01:17:04,340
And this function doesn't
need to return anything.

1559
01:17:04,340 --> 01:17:06,290
All right, and then
we also give you

1560
01:17:06,290 --> 01:17:08,210
this linked list
implementation, which

1561
01:17:08,210 --> 01:17:11,960
is what's in your
recitation handout.

1562
01:17:11,960 --> 01:17:14,210
I'm actually going to
ignore most of this stuff--

1563
01:17:14,210 --> 01:17:18,290
really just that this thing
contains an item in next

1564
01:17:18,290 --> 01:17:19,640
in your node--

1565
01:17:19,640 --> 01:17:21,950
I'm not actually going to
look at the items at all--

1566
01:17:21,950 --> 01:17:25,470
and a head and size in my
linked list at the top level.

1567
01:17:25,470 --> 01:17:26,300
OK?

1568
01:17:26,300 --> 01:17:29,300
But this is just to tell
you what's in there.

1569
01:17:29,300 --> 01:17:32,030
So that's what's going
to be input to my thing,

1570
01:17:32,030 --> 01:17:36,470
and if I go here
and I run the tests

1571
01:17:36,470 --> 01:17:38,775
document that you
gave me, it fails

1572
01:17:38,775 --> 01:17:40,025
because I don't have anything.

1573
01:17:40,025 --> 01:17:41,990
It didn't do
anything to the list.

1574
01:17:41,990 --> 01:17:43,300
OK?

1575
01:17:43,300 --> 01:17:44,690
All right.

1576
01:17:44,690 --> 01:17:52,404
And in fact, if I go into
here to the tests and I--

1577
01:17:52,404 --> 01:17:53,110
what is it?

1578
01:17:53,110 --> 01:17:54,580
It's reordering
the students here.

1579
01:17:54,580 --> 01:17:58,600
I print the linked
list that you gave me.

1580
01:17:58,600 --> 01:18:02,930
I'm going to have
a line break here.

1581
01:18:02,930 --> 01:18:09,280
What we can see is,
when I do this--

1582
01:18:09,280 --> 01:18:10,780
here are my test cases.

1583
01:18:10,780 --> 01:18:12,830
Here's a linked list.

1584
01:18:12,830 --> 01:18:14,580
And what's happening
is it's just spitting

1585
01:18:14,580 --> 01:18:15,780
out the same linked lists.

1586
01:18:15,780 --> 01:18:18,630
I haven't done anything to it.

1587
01:18:18,630 --> 01:18:21,090
All right, so we need
to do something to it.

1588
01:18:21,090 --> 01:18:22,740
How are we going to do that?

1589
01:18:22,740 --> 01:18:25,200
All right, so let's
implement this function.

1590
01:18:25,200 --> 01:18:28,193
And I'm going to get rid
of this stuff, because--

1591
01:18:28,193 --> 01:18:28,860
get rid of that.

1592
01:18:28,860 --> 01:18:31,113
All right, so we need
to reorder the students.

1593
01:18:31,113 --> 01:18:33,030
So I'm going to break
this up into three parts

1594
01:18:33,030 --> 01:18:33,780
that we have here.

1595
01:18:33,780 --> 01:18:36,510
We're going to
find the n-th node.

1596
01:18:36,510 --> 01:18:40,230
So how do we find the n-th node?

1597
01:18:40,230 --> 01:18:42,840
This thing has a size
on it, so let's at least

1598
01:18:42,840 --> 01:18:44,210
figure out what n is.

1599
01:18:44,210 --> 01:18:47,880
So let's set n equal to--

1600
01:18:47,880 --> 01:18:50,557
I think I can use
length, because I've

1601
01:18:50,557 --> 01:18:52,140
implemented that on
my thing, and it's

1602
01:18:52,140 --> 01:18:53,890
going to be whatever
the length is over 2.

1603
01:18:53,890 --> 01:18:55,590
And I'm defined by
the problem statement

1604
01:18:55,590 --> 01:18:58,530
that I'm only going
to have even inputs.

1605
01:18:58,530 --> 01:19:08,205
And I'm going to set, at first,
my a to be the starting place.

1606
01:19:08,205 --> 01:19:10,580
I'm going to just have a little
temporary variable that's

1607
01:19:10,580 --> 01:19:14,480
going to say this is going to
be equal to the head of my list.

1608
01:19:14,480 --> 01:19:17,300
And what I'm going to do is
what your colleague was saying--

1609
01:19:17,300 --> 01:19:20,540
is I'm just going to
loop through n times

1610
01:19:20,540 --> 01:19:23,060
until I reach the n-th thing.

1611
01:19:23,060 --> 01:19:24,560
Actually, how many
times do I have

1612
01:19:24,560 --> 01:19:29,170
to travel through next
pointers to get to node a?

1613
01:19:29,170 --> 01:19:31,050
n minus 1, actually-- yep.

1614
01:19:31,050 --> 01:19:32,760
So this is going to be for.

1615
01:19:32,760 --> 01:19:35,680
I don't care about
this loop variable,

1616
01:19:35,680 --> 01:19:40,483
so I'm going to just use
that n minus 1 times.

1617
01:19:40,483 --> 01:19:41,400
What am I going to do?

1618
01:19:41,400 --> 01:19:44,960
I want to replace a with
the thing it's pointed to,

1619
01:19:44,960 --> 01:19:47,790
so I'm going to just walk down
this thing. a equals a.next.

1620
01:19:51,060 --> 01:19:56,430
And now, after the end
of this loop, what is a?

1621
01:19:56,430 --> 01:19:58,930
a is the n-th node.

1622
01:19:58,930 --> 01:20:03,190
I've now made it the
n-th node-- fantastic.

1623
01:20:03,190 --> 01:20:06,700
And now I'm going to say that
b is going to be the next one.

1624
01:20:06,700 --> 01:20:09,790
Just in terms of my write-up,
I labeled these things

1625
01:20:09,790 --> 01:20:13,150
as a, and b, and c,
and so in my mind,

1626
01:20:13,150 --> 01:20:15,880
I'm going to want to use
the same kind of notation

1627
01:20:15,880 --> 01:20:17,900
here so that I can
understand my code.

1628
01:20:17,900 --> 01:20:20,690
OK, so b is going to
be the next thing.

1629
01:20:23,420 --> 01:20:26,340
And now, in this process, as
I'm going to flip things around,

1630
01:20:26,340 --> 01:20:27,715
what I'm going to
do is I'm going

1631
01:20:27,715 --> 01:20:29,420
to keep track of three nodes.

1632
01:20:29,420 --> 01:20:33,500
I'm going to keep track of
x, which is the node that I'm

1633
01:20:33,500 --> 01:20:35,182
going to be relinking.

1634
01:20:35,182 --> 01:20:36,890
And what else do I
need to keep track of?

1635
01:20:40,310 --> 01:20:40,975
If I'm--

1636
01:20:40,975 --> 01:20:42,350
STUDENT: [INAUDIBLE]
destination.

1637
01:20:42,350 --> 01:20:43,820
JASON KU: Yeah,
where I came from

1638
01:20:43,820 --> 01:20:46,520
and where I'm going
to, because that's what

1639
01:20:46,520 --> 01:20:47,900
I'm going to need to relink.

1640
01:20:47,900 --> 01:20:51,000
In particular, I'm going to
have someone pointing to me,

1641
01:20:51,000 --> 01:20:55,050
which I'm going to
call next previous--

1642
01:20:55,050 --> 01:20:58,250
or the x previous.

1643
01:20:58,250 --> 01:21:01,470
When I'm going to label it,
it's going to be the next thing.

1644
01:21:01,470 --> 01:21:01,970
All right?

1645
01:21:01,970 --> 01:21:03,380
Does that make sense?

1646
01:21:03,380 --> 01:21:08,850
So in my first situation, I'm--

1647
01:21:08,850 --> 01:21:10,340
the first thing I
need to relink is

1648
01:21:10,340 --> 01:21:13,160
b, so that's going to be my x.

1649
01:21:13,160 --> 01:21:15,500
And x previous is going to be a.

1650
01:21:15,500 --> 01:21:16,560
Does that makes sense?

1651
01:21:16,560 --> 01:21:19,470
So I'm going to instantiate
those two variables.

1652
01:21:19,470 --> 01:21:24,950
x and x_p are going
to be b and a.

1653
01:21:24,950 --> 01:21:25,490
Sorry.

1654
01:21:25,490 --> 01:21:26,630
That's right.

1655
01:21:26,630 --> 01:21:27,320
Yeah.

1656
01:21:27,320 --> 01:21:32,900
Maybe it makes more sense to
have x previous and x equal ab.

1657
01:21:32,900 --> 01:21:36,380
All right, that's
in the right order.

1658
01:21:36,380 --> 01:21:38,040
Either way is fine.

1659
01:21:38,040 --> 01:21:40,160
And then I want to
go through a loop.

1660
01:21:40,160 --> 01:21:41,630
I'm going to be
doing a loop way.

1661
01:21:41,630 --> 01:21:44,540
You can do it a recursive
way, if you want.

1662
01:21:44,540 --> 01:21:46,820
Here's a loop way, in
which I'm just going

1663
01:21:46,820 --> 01:21:48,470
to loop through how many times?

1664
01:21:48,470 --> 01:21:54,520
How many pointers am I going to
relink as I go down this thing?

1665
01:21:54,520 --> 01:21:57,430
I need to relink the pointers
of all of these guys.

1666
01:21:57,430 --> 01:21:58,590
How many are there?

1667
01:21:58,590 --> 01:21:59,590
STUDENT: [INAUDIBLE]

1668
01:21:59,590 --> 01:22:00,382
JASON KU: How many?

1669
01:22:00,382 --> 01:22:01,400
STUDENT: [INAUDIBLE]

1670
01:22:01,400 --> 01:22:03,040
JASON KU: n-- there
are n of them.

1671
01:22:03,040 --> 01:22:08,160
So for-- I don't care about
the loop variable here either.

1672
01:22:08,160 --> 01:22:10,080
I'm going to do this n times.

1673
01:22:10,080 --> 01:22:11,440
And what am I going to do?

1674
01:22:11,440 --> 01:22:16,320
I'm going to first figure
out who my next guy is.

1675
01:22:16,320 --> 01:22:21,610
I'm going to set x_n
equals what? x.next--

1676
01:22:21,610 --> 01:22:25,450
all right, so now I know
who's next to me right,

1677
01:22:25,450 --> 01:22:29,080
so I can go there later
after I relink my pointer.

1678
01:22:29,080 --> 01:22:31,510
I'm remembering that.

1679
01:22:31,510 --> 01:22:37,990
Now, I don't care about what's
stored in x.next, because I've

1680
01:22:37,990 --> 01:22:39,610
stored it locally.

1681
01:22:39,610 --> 01:22:40,900
That makes sense.

1682
01:22:40,900 --> 01:22:45,100
All right, so now I am free
to relink that next pointer

1683
01:22:45,100 --> 01:22:46,450
to my previous guy.

1684
01:22:50,510 --> 01:22:56,790
And now I can essentially
shift my perspective over,

1685
01:22:56,790 --> 01:23:01,560
so the thing that I'm going
to relink now is the next one.

1686
01:23:01,560 --> 01:23:09,660
So x previous and x
now equals x, x_next.

1687
01:23:09,660 --> 01:23:11,930
Does that make sense?

1688
01:23:11,930 --> 01:23:15,130
Just relinked things over--

1689
01:23:15,130 --> 01:23:16,840
so that's the end of step 2.

1690
01:23:16,840 --> 01:23:21,160
Now, as I got down this at
the end of this for loop,

1691
01:23:21,160 --> 01:23:22,030
where is x?

1692
01:23:25,240 --> 01:23:29,260
What is x_p, x, and
x_next-- or x_n?

1693
01:23:29,260 --> 01:23:33,170
Really, I'm only keeping
track of x and x_p here.

1694
01:23:33,170 --> 01:23:36,100
So what are x_p and x
at the end of this loop?

1695
01:23:39,630 --> 01:23:41,940
I've done this n times.

1696
01:23:41,940 --> 01:23:44,925
I started with b at x.

1697
01:23:49,698 --> 01:23:50,960
So what is x?

1698
01:23:50,960 --> 01:23:53,840
Yeah?

1699
01:23:53,840 --> 01:23:57,260
So we have a vote that x is c.

1700
01:23:57,260 --> 01:23:59,411
STUDENT: [INAUDIBLE]

1701
01:23:59,411 --> 01:24:01,730
JASON KU: So this is
a little interesting.

1702
01:24:01,730 --> 01:24:03,050
All right.

1703
01:24:03,050 --> 01:24:08,750
I will tell you that c
is either x_p, x, or x_n.

1704
01:24:08,750 --> 01:24:10,310
So we have one vote for x.

1705
01:24:10,310 --> 01:24:11,420
Who says something else?

1706
01:24:16,840 --> 01:24:18,130
Eric doesn't like x.

1707
01:24:21,790 --> 01:24:24,310
There are only
two other choices.

1708
01:24:24,310 --> 01:24:27,400
Does someone say something?

1709
01:24:27,400 --> 01:24:31,220
x_p-- I will argue
that it is x_p.

1710
01:24:31,220 --> 01:24:31,720
Why?

1711
01:24:31,720 --> 01:24:33,880
Because I'm at b.

1712
01:24:33,880 --> 01:24:36,040
There are n things.

1713
01:24:36,040 --> 01:24:41,590
I did n operations, and every
operation, I move 1 over.

1714
01:24:41,590 --> 01:24:46,180
So when I've done n minus 1
things, I'm at c, the n-th one.

1715
01:24:46,180 --> 01:24:48,310
Now x is none, because
there's null pointer

1716
01:24:48,310 --> 01:24:49,670
at the end of the list.

1717
01:24:49,670 --> 01:24:55,465
So x_p is c, so I'm going to
set p equal to x_p, which is--

1718
01:24:55,465 --> 01:24:58,360
it's just for me to remember
what these things are.

1719
01:24:58,360 --> 01:25:01,150
And I just relink
these two pointers.

1720
01:25:01,150 --> 01:25:08,710
a.next should be c and
b.next should be none.

1721
01:25:12,490 --> 01:25:13,990
Does that make sense, everybody?

1722
01:25:13,990 --> 01:25:15,520
Let's see if we did it right.

1723
01:25:15,520 --> 01:25:22,510
So we save that thing and we
run Python on the test cases,

1724
01:25:22,510 --> 01:25:26,950
and it did the right
thing apparently-- maybe.

1725
01:25:26,950 --> 01:25:29,290
Let's see-- ran
five test cases--

1726
01:25:29,290 --> 01:25:30,880
OK.

1727
01:25:30,880 --> 01:25:32,740
All right, so let's
take a look at this.

1728
01:25:32,740 --> 01:25:35,170
We had this linked list--

1729
01:25:35,170 --> 01:25:38,820
Lilly, Sally, Cindy,
Maisy, Sammy, Davey.

1730
01:25:38,820 --> 01:25:43,648
And what it turns into is Lilly,
Sally, Cindy, which is correct.

1731
01:25:43,648 --> 01:25:45,690
And then it reverses this
last part of the list--

1732
01:25:45,690 --> 01:25:50,830
Danny, Sammy, Maisy--
cool, awesome.

1733
01:25:50,830 --> 01:25:53,560
But these are the test
cases we gave you.

1734
01:25:53,560 --> 01:25:56,430
So let's try this
against our code checker.

1735
01:25:56,430 --> 01:25:58,630
So I select the file.

1736
01:25:58,630 --> 01:25:59,410
Where do I go?

1737
01:25:59,410 --> 01:26:04,390
I think I'm in my desktop here
in session 1, and template,

1738
01:26:04,390 --> 01:26:06,130
and reorder students.

1739
01:26:06,130 --> 01:26:07,600
I submit it.

1740
01:26:07,600 --> 01:26:08,110
Please work.

1741
01:26:08,110 --> 01:26:08,610
Please work.

1742
01:26:08,610 --> 01:26:09,578
Please work.

1743
01:26:15,390 --> 01:26:19,140
And 100%-- and now we're
happy, and we can go party.

1744
01:26:19,140 --> 01:26:20,580
OK.

1745
01:26:20,580 --> 01:26:23,250
All right, so that's
the first problem.

1746
01:26:23,250 --> 01:26:25,380
Hopefully this was
helpful to you.

1747
01:26:25,380 --> 01:26:31,580
We will release problem set 1
tomorrow, and good luck on it.