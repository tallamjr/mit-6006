1
00:00:00,000 --> 00:00:01,964
[SQUEAKING]

2
00:00:01,964 --> 00:00:03,928
[RUSTLING]

3
00:00:03,928 --> 00:00:06,383
[CLICKING]

4
00:00:12,780 --> 00:00:14,130
JASON KU: All right.

5
00:00:14,130 --> 00:00:16,020
Welcome, everybody.

6
00:00:16,020 --> 00:00:17,580
Everyone ready for the quiz?

7
00:00:17,580 --> 00:00:18,540
AUDIENCE: No.

8
00:00:18,540 --> 00:00:19,710
JASON KU: Quiz next week.

9
00:00:19,710 --> 00:00:20,280
Yes.

10
00:00:20,280 --> 00:00:22,530
I hope you all are
here because you know

11
00:00:22,530 --> 00:00:23,790
that there's a quiz next week.

12
00:00:23,790 --> 00:00:24,300
OK.

13
00:00:24,300 --> 00:00:26,250
So what is this quiz about?

14
00:00:26,250 --> 00:00:27,870
It's about what
we've talked about so

15
00:00:27,870 --> 00:00:29,430
far in this class of course.

16
00:00:29,430 --> 00:00:31,080
What is this class about?

17
00:00:31,080 --> 00:00:34,090
Someone remember from
my first lecture?

18
00:00:34,090 --> 00:00:35,160
What is this class about?

19
00:00:35,160 --> 00:00:37,243
What are we trying to
test you in this class?

20
00:00:37,243 --> 00:00:38,160
AUDIENCE: Algorithims.

21
00:00:38,160 --> 00:00:39,035
JASON KU: Algorithms.

22
00:00:39,035 --> 00:00:39,780
Great.

23
00:00:39,780 --> 00:00:40,655
Also data structures.

24
00:00:40,655 --> 00:00:41,155
Right?

25
00:00:41,155 --> 00:00:42,750
That's what the first
part of this is.

26
00:00:42,750 --> 00:00:45,870
But really it's to get you to
solve computational problems.

27
00:00:45,870 --> 00:00:47,790
That's the first thing.

28
00:00:47,790 --> 00:00:52,000
Be able to argue to someone else
that you actually did solve it.

29
00:00:52,000 --> 00:00:52,500
Right?

30
00:00:52,500 --> 00:00:53,280
It's correct.

31
00:00:53,280 --> 00:00:54,000
Right?

32
00:00:54,000 --> 00:00:56,010
That you chose something that's
better than other things,

33
00:00:56,010 --> 00:00:56,910
that it's efficient.

34
00:00:56,910 --> 00:00:57,690
Right?

35
00:00:57,690 --> 00:01:00,240
And that you can communicate
those things to other people.

36
00:01:00,240 --> 00:01:00,750
Right?

37
00:01:00,750 --> 00:01:04,890
Those are my big four that I try
to get you guys to internalize.

38
00:01:04,890 --> 00:01:06,960
And so that's what
our quizzes are going

39
00:01:06,960 --> 00:01:08,870
to try to evaluate you on.

40
00:01:08,870 --> 00:01:09,470
OK.

41
00:01:09,470 --> 00:01:15,570
And so aside from some
nitty gritty kind of stuff

42
00:01:15,570 --> 00:01:17,280
that we do at the
beginning of the term

43
00:01:17,280 --> 00:01:21,010
like talking about our
model of computation.

44
00:01:21,010 --> 00:01:21,510
Right?

45
00:01:21,510 --> 00:01:26,620
Our model-- and asymptotics.

46
00:01:26,620 --> 00:01:31,500
Asym-- sym-- totics.

47
00:01:31,500 --> 00:01:33,900
Is that right?

48
00:01:33,900 --> 00:01:37,470
Recurrences right?

49
00:01:37,470 --> 00:01:39,990
Aside from these
kind of basics, we

50
00:01:39,990 --> 00:01:42,720
delve straight into algorithms.

51
00:01:42,720 --> 00:01:43,830
Right?

52
00:01:43,830 --> 00:01:48,060
These are kind of like
almost definitions.

53
00:01:48,060 --> 00:01:49,920
We don't rely on these
things very much.

54
00:01:49,920 --> 00:01:52,213
I mean, we rely on these
things all the time.

55
00:01:52,213 --> 00:01:53,880
But it's kind of the
mathematics that we

56
00:01:53,880 --> 00:01:54,930
use to talk about things.

57
00:01:54,930 --> 00:01:55,440
Right?

58
00:01:55,440 --> 00:01:57,180
How can we even say
how long this stuff

59
00:01:57,180 --> 00:01:58,860
takes unless we can reason--

60
00:01:58,860 --> 00:02:01,260
we can abstract a way
that this stuff is not

61
00:02:01,260 --> 00:02:02,730
on a real computer.

62
00:02:02,730 --> 00:02:04,650
This is kind of in our
minds, in a computer.

63
00:02:04,650 --> 00:02:06,483
And we're reasoning
about these things based

64
00:02:06,483 --> 00:02:09,300
on the number of
constant time operations

65
00:02:09,300 --> 00:02:12,237
this magical
computer might have,

66
00:02:12,237 --> 00:02:14,070
which is a pretty good
representation of any

67
00:02:14,070 --> 00:02:16,990
of the computers you have
for certain assumptions.

68
00:02:16,990 --> 00:02:17,490
Right?

69
00:02:17,490 --> 00:02:20,430
We're not-- I mean, there's not
a lot of problem set questions

70
00:02:20,430 --> 00:02:23,790
we had you talk about.

71
00:02:23,790 --> 00:02:27,497
These things--
specifically-- usually they

72
00:02:27,497 --> 00:02:28,830
were part of some other problem.

73
00:02:28,830 --> 00:02:29,340
Right?

74
00:02:29,340 --> 00:02:33,000
You had to describe the
running time of this thing.

75
00:02:33,000 --> 00:02:34,975
And you might have had
to solve a recurrence.

76
00:02:34,975 --> 00:02:36,600
And you might have
uses master theorem.

77
00:02:36,600 --> 00:02:37,380
That kind of thing.

78
00:02:37,380 --> 00:02:37,880
Right?

79
00:02:37,880 --> 00:02:39,780
Or you use asymptotics
all the time.

80
00:02:39,780 --> 00:02:41,820
Or you need to
remember in our model,

81
00:02:41,820 --> 00:02:44,550
oh, it kind of matters
how big of an integer

82
00:02:44,550 --> 00:02:47,530
I can store and do arithmetic
on in constant time.

83
00:02:47,530 --> 00:02:48,030
Right?

84
00:02:48,030 --> 00:02:50,190
So for that p-set
3 question you had

85
00:02:50,190 --> 00:02:54,410
at the end of the
coding question,

86
00:02:54,410 --> 00:02:56,370
you wanted to hash things.

87
00:02:56,370 --> 00:02:59,070
And you need to argue
that those things fit

88
00:02:59,070 --> 00:03:02,070
in a constant number
of words so that

89
00:03:02,070 --> 00:03:03,390
could be done in constant time.

90
00:03:03,390 --> 00:03:06,090
A lot of you guys
found canonicalizations

91
00:03:06,090 --> 00:03:11,620
basically mapping to things
that were exponentially large.

92
00:03:11,620 --> 00:03:14,530
So maybe multiplying a
product of primes or something

93
00:03:14,530 --> 00:03:15,030
like that.

94
00:03:15,030 --> 00:03:17,560
And that would not be
a good representation.

95
00:03:17,560 --> 00:03:18,060
OK.

96
00:03:18,060 --> 00:03:21,930
So these things come up, but
they're not the main focus

97
00:03:21,930 --> 00:03:23,070
of the problems we solve.

98
00:03:23,070 --> 00:03:24,720
What are the main focus of the--

99
00:03:24,720 --> 00:03:27,240
how do we solve a computational
problem in this class?

100
00:03:27,240 --> 00:03:30,600
I gave you two ways at
the beginning of the term.

101
00:03:30,600 --> 00:03:33,750
Do you guys remember?

102
00:03:33,750 --> 00:03:45,270
We can solve-- how to solve a
computational-- computational

103
00:03:45,270 --> 00:03:45,770
problem.

104
00:03:51,548 --> 00:03:52,340
One's the hard way.

105
00:03:52,340 --> 00:03:53,930
One's the easy way.

106
00:03:53,930 --> 00:03:54,890
AUDIENCE: Brute force.

107
00:03:54,890 --> 00:03:55,520
JASON KU: Brute force.

108
00:03:55,520 --> 00:03:56,020
OK.

109
00:03:56,020 --> 00:03:58,910
So you're describing
to me a technique

110
00:03:58,910 --> 00:04:00,440
for making your own algorithm.

111
00:04:00,440 --> 00:04:01,160
Right?

112
00:04:01,160 --> 00:04:05,840
I can just design my new
algorithm from scratch.

113
00:04:05,840 --> 00:04:07,690
One way I could do
that is brute force it.

114
00:04:07,690 --> 00:04:08,190
Right?

115
00:04:08,190 --> 00:04:10,910
Look at all the possible
outputs and see which one works.

116
00:04:10,910 --> 00:04:11,780
Right?

117
00:04:11,780 --> 00:04:14,192
Or I could reduce to something
like divide and conquer

118
00:04:14,192 --> 00:04:15,150
or something like that.

119
00:04:15,150 --> 00:04:16,490
That's generally a
hard thing to do--

120
00:04:16,490 --> 00:04:17,615
to make your own algorithm.

121
00:04:17,615 --> 00:04:18,860
Right?

122
00:04:18,860 --> 00:04:21,380
That's why we don't ask you
to do it a lot in this class.

123
00:04:21,380 --> 00:04:22,580
It's an 046 kind of thing.

124
00:04:22,580 --> 00:04:23,080
Right?

125
00:04:23,080 --> 00:04:31,100
So the first thing you could do
is write design a new algorithm

126
00:04:31,100 --> 00:04:33,410
from scratch.

127
00:04:33,410 --> 00:04:35,190
Usually it's not from scratch.

128
00:04:35,190 --> 00:04:35,690
Right?

129
00:04:35,690 --> 00:04:38,360
Usually you're reducing to
some kind of algorithmic design

130
00:04:38,360 --> 00:04:40,940
paradigm that you've
maybe heard of.

131
00:04:40,940 --> 00:04:44,480
You'll talk a lot more about it
in 046 and at the end of this

132
00:04:44,480 --> 00:04:46,490
term when we talk about
dynamic programming.

133
00:04:46,490 --> 00:04:48,980
But generally, that's
a hard thing to do.

134
00:04:48,980 --> 00:04:50,270
Right?

135
00:04:50,270 --> 00:04:52,400
You're trying to think
of a recursive algorithm.

136
00:04:52,400 --> 00:04:53,060
Right?

137
00:04:53,060 --> 00:04:55,280
You're trying to prove
that it's correct--

138
00:04:55,280 --> 00:04:57,440
all these nitty gritty--
we have actually,

139
00:04:57,440 --> 00:04:59,270
throughout the
class in lectures,

140
00:04:59,270 --> 00:05:02,330
have been showing
you the algorithms.

141
00:05:02,330 --> 00:05:05,300
But we're not really expecting
you to make those algorithms.

142
00:05:05,300 --> 00:05:08,660
What are we expecting you
to do most of the time.

143
00:05:08,660 --> 00:05:09,710
Yeah?

144
00:05:09,710 --> 00:05:12,810
To reduce it to a problem that
we showed you how to solve.

145
00:05:12,810 --> 00:05:13,310
Right?

146
00:05:19,940 --> 00:05:21,830
I'm going to say
thing here, but really

147
00:05:21,830 --> 00:05:25,250
what I mean is an algorithm
that we've taught you to--

148
00:05:25,250 --> 00:05:28,790
basically here-- reduced
to a known thing--

149
00:05:28,790 --> 00:05:31,940
to known thing.

150
00:05:31,940 --> 00:05:36,440
Usually that means there's
a problem or an interface

151
00:05:36,440 --> 00:05:38,540
that we've given you.

152
00:05:38,540 --> 00:05:41,720
And in general, we've shown
you multiple different ways

153
00:05:41,720 --> 00:05:43,770
to solve that
problem or interface.

154
00:05:43,770 --> 00:05:44,270
Right?

155
00:05:44,270 --> 00:05:48,770
So we've shown you many
ways on how to sort things.

156
00:05:48,770 --> 00:05:51,050
And we've shown you many
ways on how to implement

157
00:05:51,050 --> 00:05:53,840
sequence and set interfaces.

158
00:05:53,840 --> 00:05:55,340
Remember?

159
00:05:55,340 --> 00:05:59,690
And a lot of times
the types of problems

160
00:05:59,690 --> 00:06:03,710
that we're asking you to do
is to just use as a black box

161
00:06:03,710 --> 00:06:05,040
some of the things that we did.

162
00:06:05,040 --> 00:06:08,340
But you need, as a programmer,
as a computer scientist,

163
00:06:08,340 --> 00:06:12,350
you need to tell me when
I should use what went.

164
00:06:12,350 --> 00:06:12,850
Right?

165
00:06:12,850 --> 00:06:13,310
Yeah?

166
00:06:13,310 --> 00:06:15,980
AUDIENCE: Could you clarify what
you mean by use as a black box?

167
00:06:15,980 --> 00:06:16,970
JASON KU: Use as a black box.

168
00:06:16,970 --> 00:06:17,470
Exactly.

169
00:06:17,470 --> 00:06:18,230
Right.

170
00:06:18,230 --> 00:06:20,690
So this is a phrase that
I use and a lot of people

171
00:06:20,690 --> 00:06:21,920
in computer science use.

172
00:06:21,920 --> 00:06:26,030
It's basically you import
a library into your code.

173
00:06:26,030 --> 00:06:26,990
Right?

174
00:06:26,990 --> 00:06:27,810
What do I have?

175
00:06:27,810 --> 00:06:29,120
I have an API.

176
00:06:29,120 --> 00:06:31,520
I have a way to
interact with that code.

177
00:06:31,520 --> 00:06:32,960
I don't actually
know what's going

178
00:06:32,960 --> 00:06:35,990
on inside of that library.

179
00:06:35,990 --> 00:06:37,670
I'm using it as a black box.

180
00:06:37,670 --> 00:06:38,990
It's opaque to me.

181
00:06:38,990 --> 00:06:40,640
I cannot look inside--

182
00:06:40,640 --> 00:06:43,550
I can actually probably could
look inside what their code is,

183
00:06:43,550 --> 00:06:44,750
but I'm not going to.

184
00:06:44,750 --> 00:06:46,760
The thing that makes
it useful to me

185
00:06:46,760 --> 00:06:49,460
is that has this
useful API that I

186
00:06:49,460 --> 00:06:52,150
trust it to do the
things that you told me

187
00:06:52,150 --> 00:06:53,150
that it was going to do.

188
00:06:53,150 --> 00:06:53,690
Right?

189
00:06:53,690 --> 00:06:56,000
And so there's kind of--

190
00:06:56,000 --> 00:06:58,490
I'm going to jump around a
little bit here actually,

191
00:06:58,490 --> 00:07:02,100
because that's a great question.

192
00:07:02,100 --> 00:07:08,330
So here I think of there's three
different types of problems

193
00:07:08,330 --> 00:07:11,630
that we talk about, that
we give you in this class.

194
00:07:11,630 --> 00:07:13,790
You might have seen
this on the problem set.

195
00:07:13,790 --> 00:07:14,690
Right?

196
00:07:14,690 --> 00:07:18,650
I like to categorize them into
three different categories

197
00:07:18,650 --> 00:07:19,230
here.

198
00:07:19,230 --> 00:07:24,380
One is you have to understand
the internals of a data

199
00:07:24,380 --> 00:07:26,630
structure, an
algorithm that we know.

200
00:07:26,630 --> 00:07:29,810
You have to be able to look
inside and, I don't know,

201
00:07:29,810 --> 00:07:32,900
given a node in a balanced
binary search tree--

202
00:07:32,900 --> 00:07:34,460
an AVL tree--

203
00:07:34,460 --> 00:07:35,870
how can I do a rotation?

204
00:07:35,870 --> 00:07:36,530
Right?

205
00:07:36,530 --> 00:07:38,660
Or how do I do an insert?

206
00:07:38,660 --> 00:07:43,370
Or something about the
structure of this thing--

207
00:07:43,370 --> 00:07:46,250
a binary heap--
where are the top k

208
00:07:46,250 --> 00:07:49,700
things in a max binary heap,
which is on your problem set.

209
00:07:49,700 --> 00:07:54,830
Those things require me to very
much not black box these data

210
00:07:54,830 --> 00:07:55,430
structures.

211
00:07:55,430 --> 00:07:56,630
It's a white box.

212
00:07:56,630 --> 00:07:57,170
Right?

213
00:07:57,170 --> 00:07:59,940
I need to know what's inside of
that to answer that question.

214
00:07:59,940 --> 00:08:00,440
Right?

215
00:08:00,440 --> 00:08:02,240
I need to know about the
internals of that data

216
00:08:02,240 --> 00:08:02,740
structure.

217
00:08:02,740 --> 00:08:03,740
Right?

218
00:08:03,740 --> 00:08:06,463
And there are other types of
problems where it's like, oh,

219
00:08:06,463 --> 00:08:08,630
I don't need to know what
the internals of this data

220
00:08:08,630 --> 00:08:09,950
structure is.

221
00:08:09,950 --> 00:08:14,450
I can just operate with
knowledge of the API

222
00:08:14,450 --> 00:08:17,150
and try to hook it in to
the problem that I need.

223
00:08:17,150 --> 00:08:20,020
And that's what I call a
reduction type problem.

224
00:08:20,020 --> 00:08:22,880
This is how does the core
material we presented

225
00:08:22,880 --> 00:08:25,280
to you in lecture work?

226
00:08:25,280 --> 00:08:28,580
This is how do I apply
that core material?

227
00:08:28,580 --> 00:08:31,940
And harder than
both of those things

228
00:08:31,940 --> 00:08:34,788
is what I might call a
modification type of--

229
00:08:34,788 --> 00:08:36,080
these aren't really good names.

230
00:08:36,080 --> 00:08:38,100
I came up with
these this morning.

231
00:08:38,100 --> 00:08:40,440
But it's trying
to get at the idea

232
00:08:40,440 --> 00:08:44,400
here that it's possible that you
need to know what the API is,

233
00:08:44,400 --> 00:08:46,515
and you need to know what's
going on inside to be

234
00:08:46,515 --> 00:08:47,640
able to answer the problem.

235
00:08:47,640 --> 00:08:51,660
Things like adapting a
divide and conquer algorithm.

236
00:08:51,660 --> 00:08:56,970
Or making-- instead of
using a dynamic array that

237
00:08:56,970 --> 00:08:58,950
has extra space on
one end, maybe I

238
00:08:58,950 --> 00:09:01,560
have to put extra space in the
middle or something like that.

239
00:09:01,560 --> 00:09:02,060
Right?

240
00:09:02,060 --> 00:09:04,800
I'm adapting something that
was from the core material.

241
00:09:04,800 --> 00:09:05,850
It's pretty close.

242
00:09:05,850 --> 00:09:07,350
But I have to modify
it in some way.

243
00:09:07,350 --> 00:09:08,490
Augmentation right?

244
00:09:08,490 --> 00:09:12,570
I have to take the vanilla
said AVL tree that I might

245
00:09:12,570 --> 00:09:15,480
have given you and put some
other property on the nodes

246
00:09:15,480 --> 00:09:18,870
and you need to tell me
how to maintain that.

247
00:09:18,870 --> 00:09:21,880
How can I compute that subtree
property from its children?

248
00:09:21,880 --> 00:09:23,500
Does that make sense?

249
00:09:23,500 --> 00:09:26,490
So this is the
harder of the things.

250
00:09:26,490 --> 00:09:27,000
Right?

251
00:09:27,000 --> 00:09:29,530
If you can identify
which one of these--

252
00:09:29,530 --> 00:09:31,750
a problem that you
look at on an exam--

253
00:09:31,750 --> 00:09:34,050
[INAUDIBLE] under--
maybe that can help you

254
00:09:34,050 --> 00:09:36,930
conceptualize what should I use.

255
00:09:36,930 --> 00:09:38,860
For a reduction type problem--

256
00:09:38,860 --> 00:09:41,310
I'm going to talk about
this in a second--

257
00:09:41,310 --> 00:09:43,950
but a lot of times it's
useful to reduce it

258
00:09:43,950 --> 00:09:50,910
to a problem or an interface
rather than an algorithm

259
00:09:50,910 --> 00:09:52,980
or a data structure.

260
00:09:52,980 --> 00:09:56,070
What does that mean?

261
00:09:56,070 --> 00:10:01,620
If I can solve the problem by
saying reducing to sorting,

262
00:10:01,620 --> 00:10:03,720
I can argue to you that
that algorithm is correct.

263
00:10:03,720 --> 00:10:05,680
I just use sorting
as a black box.

264
00:10:05,680 --> 00:10:07,560
Now it might not be efficient.

265
00:10:07,560 --> 00:10:11,640
My choice of sorting
algorithm that I chose matters

266
00:10:11,640 --> 00:10:12,505
for efficiency.

267
00:10:12,505 --> 00:10:14,130
But for correctness,
it doesn't matter.

268
00:10:14,130 --> 00:10:15,000
Right?

269
00:10:15,000 --> 00:10:18,420
For a data structures
problem I might

270
00:10:18,420 --> 00:10:22,410
reduce to using two set
data structures and sequence

271
00:10:22,410 --> 00:10:24,840
data structure or
something like that.

272
00:10:24,840 --> 00:10:30,930
But it will be correct if I
reduce it to those things.

273
00:10:30,930 --> 00:10:36,300
I can define the operations
in terms of those interfaces.

274
00:10:36,300 --> 00:10:38,100
I don't have to make
that choice until I

275
00:10:38,100 --> 00:10:39,100
talk about running time.

276
00:10:39,100 --> 00:10:39,600
Right?

277
00:10:39,600 --> 00:10:40,950
Until I talk about efficiency.

278
00:10:40,950 --> 00:10:44,820
And the name of the game
on the quiz to get points--

279
00:10:44,820 --> 00:10:48,390
we can't give you points
for an incorrect algorithm

280
00:10:48,390 --> 00:10:50,340
or something that's
pretty close to correct.

281
00:10:50,340 --> 00:10:51,990
Right?

282
00:10:51,990 --> 00:10:53,790
And we can't give
you full points

283
00:10:53,790 --> 00:10:57,840
unless the correct algorithm
you give us is efficient

284
00:10:57,840 --> 00:11:00,570
and that you've argued things
like correctness and running

285
00:11:00,570 --> 00:11:02,430
time and things like that.

286
00:11:02,430 --> 00:11:07,260
Your algorithm could be
correct and efficient,

287
00:11:07,260 --> 00:11:10,090
but you analyzed the
running time incorrectly

288
00:11:10,090 --> 00:11:11,700
so we mark you
points off for there.

289
00:11:11,700 --> 00:11:15,450
Or most of the time what
you do is you present us

290
00:11:15,450 --> 00:11:17,790
with an inefficient algorithm.

291
00:11:17,790 --> 00:11:19,500
And then you analyze
the running time

292
00:11:19,500 --> 00:11:22,050
as if it's the target running
time that we gave you.

293
00:11:22,050 --> 00:11:22,650
Right?

294
00:11:22,650 --> 00:11:24,310
That's bad on two fronts.

295
00:11:24,310 --> 00:11:24,970
Right?

296
00:11:24,970 --> 00:11:25,470
OK.

297
00:11:25,470 --> 00:11:27,220
So try not to fall
into these traps.

298
00:11:27,220 --> 00:11:27,720
OK.

299
00:11:27,720 --> 00:11:30,060
So some general test
taking strategies when

300
00:11:30,060 --> 00:11:31,840
you're looking at your quiz.

301
00:11:31,840 --> 00:11:35,250
I really strongly urge you to
read through the entire exam

302
00:11:35,250 --> 00:11:38,760
before you start because
some of the problems

303
00:11:38,760 --> 00:11:40,780
will be easier for
you than others.

304
00:11:40,780 --> 00:11:44,100
And if you're trying
to maximize points

305
00:11:44,100 --> 00:11:49,050
on here as all of you, I'm
sure, are trying to do,

306
00:11:49,050 --> 00:11:53,160
it's useful to make that initial
pass through the problems

307
00:11:53,160 --> 00:11:55,530
to see which ones
are easiest for you.

308
00:11:55,530 --> 00:11:58,440
And then you can tackle
them in the order

309
00:11:58,440 --> 00:11:59,790
in which you have confidence.

310
00:11:59,790 --> 00:12:05,370
Now in actuality, the average
on say quiz one of this class

311
00:12:05,370 --> 00:12:09,180
tends to be around, I don't
know, between 60 and 80.

312
00:12:09,180 --> 00:12:11,970
I don't think it's ever been 80.

313
00:12:11,970 --> 00:12:15,210
But it's not 100.

314
00:12:15,210 --> 00:12:21,690
So doing 50% of the
problems well is probably

315
00:12:21,690 --> 00:12:24,510
going to be better for you
in terms of time management

316
00:12:24,510 --> 00:12:28,290
and those kinds of things
than doing all of the--

317
00:12:28,290 --> 00:12:30,390
attempting all of
the problems and not

318
00:12:30,390 --> 00:12:33,840
doing great on any of
them in terms of point--

319
00:12:33,840 --> 00:12:35,880
you have to, in
computer science,

320
00:12:35,880 --> 00:12:39,690
you have to be pretty close to
a correct answer to get points.

321
00:12:39,690 --> 00:12:40,410
Right?

322
00:12:40,410 --> 00:12:43,960
It basically needs to be almost
correct or you don't get--

323
00:12:43,960 --> 00:12:46,590
if you've seen how
your problem sets are

324
00:12:46,590 --> 00:12:48,510
being graded-- sometimes
our problem set

325
00:12:48,510 --> 00:12:50,310
graders make mistakes.

326
00:12:50,310 --> 00:12:56,110
Sometimes they give you points
for an incorrect solution.

327
00:12:56,110 --> 00:12:56,610
Right?

328
00:12:56,610 --> 00:12:59,730
It's really on you to take
a look at your problem sets

329
00:12:59,730 --> 00:13:02,370
that you gave us and our
solutions that we gave you.

330
00:13:02,370 --> 00:13:06,090
We spent a lot of time writing
good solutions for you guys.

331
00:13:06,090 --> 00:13:09,460
You need to make sure
that the material.

332
00:13:09,460 --> 00:13:12,330
Don't come up to us
at the end of an exam

333
00:13:12,330 --> 00:13:16,440
and say, oh, I said the same
thing on my problem set.

334
00:13:16,440 --> 00:13:19,050
It was marked correct and
you guys marked it wrong.

335
00:13:19,050 --> 00:13:20,370
Well, yeah.

336
00:13:20,370 --> 00:13:21,780
The staff knows
a little bit more

337
00:13:21,780 --> 00:13:25,050
about algorithms than your
graders on your problem sets.

338
00:13:25,050 --> 00:13:26,950
And we grade your exams.

339
00:13:26,950 --> 00:13:29,190
So unfortunately,
that's not an excuse.

340
00:13:29,190 --> 00:13:31,020
It's on you to
know the material.

341
00:13:31,020 --> 00:13:31,800
Yep?

342
00:13:31,800 --> 00:13:33,780
AUDIENCE: So are
most of the problems

343
00:13:33,780 --> 00:13:36,180
on the exams multiple
part things where

344
00:13:36,180 --> 00:13:37,740
we need to have a
good understanding

345
00:13:37,740 --> 00:13:39,553
and do the first
few parts in order

346
00:13:39,553 --> 00:13:41,470
to get even partial
credit on the other parts?

347
00:13:41,470 --> 00:13:42,765
Or is it like [INAUDIBLE]?

348
00:13:42,765 --> 00:13:43,390
JASON KU: Yeah.

349
00:13:43,390 --> 00:13:48,400
So the question
is, are questions

350
00:13:48,400 --> 00:13:53,020
built on top of each other so
that you're kind of at a wall

351
00:13:53,020 --> 00:13:54,670
if you missed the first part?

352
00:13:54,670 --> 00:13:56,750
We try not to design
exams that way.

353
00:13:56,750 --> 00:13:57,250
OK.

354
00:13:57,250 --> 00:13:59,770
You can actually take a
look at the practice exam

355
00:13:59,770 --> 00:14:02,500
that's already been posted.

356
00:14:02,500 --> 00:14:04,900
Our problems tend to
be self-contained.

357
00:14:04,900 --> 00:14:07,450
And if they are multiple
parts, the parts

358
00:14:07,450 --> 00:14:10,300
are usually independent.

359
00:14:10,300 --> 00:14:13,420
Usually you don't need to
have done A correctly in order

360
00:14:13,420 --> 00:14:14,710
to do B correctly.

361
00:14:14,710 --> 00:14:16,090
All right?

362
00:14:16,090 --> 00:14:18,730
And that's how our problem
sets try to be written as well.

363
00:14:18,730 --> 00:14:23,163
For your last coding
question and 4

364
00:14:23,163 --> 00:14:24,580
you had this problem
where you had

365
00:14:24,580 --> 00:14:26,830
to design this data structure.

366
00:14:26,830 --> 00:14:29,410
But C said use
that as a black box

367
00:14:29,410 --> 00:14:31,360
essentially and
solve the problem.

368
00:14:31,360 --> 00:14:32,380
Right?

369
00:14:32,380 --> 00:14:34,000
So you actually
don't need to show--

370
00:14:34,000 --> 00:14:36,970
we've given you this interface.

371
00:14:36,970 --> 00:14:38,680
You can just use
that interface to be

372
00:14:38,680 --> 00:14:42,550
able to answer C, the
algorithms question,

373
00:14:42,550 --> 00:14:45,610
without even solving the data
structures question correctly.

374
00:14:45,610 --> 00:14:47,300
Does that make sense?

375
00:14:47,300 --> 00:14:49,180
And actually, the
algorithms question

376
00:14:49,180 --> 00:14:52,150
was the easier one there, I
think, from what I remember.

377
00:14:52,150 --> 00:14:52,780
Yeah?

378
00:14:52,780 --> 00:14:54,460
AUDIENCE: Do we have to
write code on the exam?

379
00:14:54,460 --> 00:14:56,460
JASON KU: Do you have to
write code on the exam?

380
00:14:59,170 --> 00:15:04,360
I've never given an exam where
you've had to write code.

381
00:15:04,360 --> 00:15:07,660
I have written exams where
you have to read code.

382
00:15:07,660 --> 00:15:08,170
OK?

383
00:15:08,170 --> 00:15:11,410
So pseudocode or Python--

384
00:15:11,410 --> 00:15:13,330
since Python's a
prerequisite for this class,

385
00:15:13,330 --> 00:15:15,370
it's completely fair
game that we give you

386
00:15:15,370 --> 00:15:16,930
small snippets of
Python code and you

387
00:15:16,930 --> 00:15:21,370
have to be able to
understand what's going on.

388
00:15:21,370 --> 00:15:22,870
Yeah?

389
00:15:22,870 --> 00:15:24,640
AUDIENCE: You
listed amortization

390
00:15:24,640 --> 00:15:27,310
under the modification
[INAUDIBLE]..

391
00:15:27,310 --> 00:15:31,305
Does that mean we're using
an amortized [INAUDIBLE]??

392
00:15:31,305 --> 00:15:31,930
JASON KU: Yeah.

393
00:15:31,930 --> 00:15:34,330
What I mean here--

394
00:15:34,330 --> 00:15:37,720
amortization certainly
appears in here or here--

395
00:15:37,720 --> 00:15:39,460
these kinds of things.

396
00:15:39,460 --> 00:15:41,590
Oftentimes if I'm
using a dynamic array,

397
00:15:41,590 --> 00:15:44,440
if I'm using a binary heap,
if I'm using a hash table,

398
00:15:44,440 --> 00:15:47,710
amortization will appear
here in our running times

399
00:15:47,710 --> 00:15:49,090
for those dynamic operations.

400
00:15:49,090 --> 00:15:51,040
What I mean here
in amortization--

401
00:15:51,040 --> 00:15:53,950
I mean if I'm asking you
to generalize something

402
00:15:53,950 --> 00:15:57,940
that we've done like with
dynamic arrays where instead

403
00:15:57,940 --> 00:16:00,100
of adding additional
space at the end,

404
00:16:00,100 --> 00:16:02,020
I'm putting additional
space in the middle

405
00:16:02,020 --> 00:16:04,580
or at the beginning or
something like that.

406
00:16:04,580 --> 00:16:08,050
And you're having to do some
kind of amortized analysis.

407
00:16:08,050 --> 00:16:13,940
Now, often it's
unnecessary to do this in--

408
00:16:13,940 --> 00:16:16,900
when we talked about
a problem where

409
00:16:16,900 --> 00:16:19,990
we did do our own
amoritized analysis

410
00:16:19,990 --> 00:16:22,150
and making a double ended deck--

411
00:16:22,150 --> 00:16:24,630
I mean a double ended queue--

412
00:16:24,630 --> 00:16:26,830
you could actually
solve it by reducing

413
00:16:26,830 --> 00:16:31,090
to using two dynamic arrays.

414
00:16:31,090 --> 00:16:32,020
Right?

415
00:16:32,020 --> 00:16:37,540
So there's a lot of
ways in which you

416
00:16:37,540 --> 00:16:39,280
could reduce to using things.

417
00:16:39,280 --> 00:16:41,500
But you might have to do
some additional bookkeeping

418
00:16:41,500 --> 00:16:42,430
at the end.

419
00:16:42,430 --> 00:16:46,750
But what this is saying
is that these are more--

420
00:16:46,750 --> 00:16:48,400
you're not using
things as a black box.

421
00:16:48,400 --> 00:16:51,650
You're changing something about
the boxes that we gave you.

422
00:16:51,650 --> 00:16:52,150
Right?

423
00:16:52,150 --> 00:16:53,560
Does that make sense.

424
00:16:53,560 --> 00:16:54,340
Yeah?

425
00:16:54,340 --> 00:16:56,980
AUDIENCE: If you tell us to
write an algorithm that does

426
00:16:56,980 --> 00:17:00,610
something like O(log n)
time, and we can think only

427
00:17:00,610 --> 00:17:03,060
of an algorithm that does
something inefficiently like

428
00:17:03,060 --> 00:17:03,968
O(n) at end time.

429
00:17:03,968 --> 00:17:04,510
JASON KU: OK.

430
00:17:04,510 --> 00:17:06,470
AUDIENCE: Then is there
any point writing that?

431
00:17:06,470 --> 00:17:07,095
JASON KU: Sure.

432
00:17:07,095 --> 00:17:11,589
So let's actually
move on for a second.

433
00:17:11,589 --> 00:17:19,430
I actually-- I'm going to
answer your question very soon.

434
00:17:19,430 --> 00:17:20,329
OK.

435
00:17:20,329 --> 00:17:22,339
But I'm going to get
to it in a second.

436
00:17:22,339 --> 00:17:23,750
OK?

437
00:17:23,750 --> 00:17:26,960
If I don't answer that question
in five minutes, please let me

438
00:17:26,960 --> 00:17:27,619
know.

439
00:17:27,619 --> 00:17:28,730
OK?

440
00:17:28,730 --> 00:17:30,500
So the first thing,
when I'm approaching

441
00:17:30,500 --> 00:17:33,260
a problem on the
exam, I might try

442
00:17:33,260 --> 00:17:35,730
to ask some questions
about the problem.

443
00:17:35,730 --> 00:17:36,230
OK.

444
00:17:36,230 --> 00:17:38,360
It's going to help me
decide what to use.

445
00:17:38,360 --> 00:17:39,260
Right?

446
00:17:39,260 --> 00:17:41,600
Different than
your problems sets.

447
00:17:41,600 --> 00:17:43,610
Your problem sets--
basically, what

448
00:17:43,610 --> 00:17:47,150
do you use is what did we talk
about in lecture that week.

449
00:17:47,150 --> 00:17:49,280
On a quiz you have
eight lectures

450
00:17:49,280 --> 00:17:51,030
that you've talked about.

451
00:17:51,030 --> 00:17:52,940
And so this is going
to be a harder thing

452
00:17:52,940 --> 00:17:56,030
for you to do because you don't
know which of the eight lecture

453
00:17:56,030 --> 00:17:57,950
material is going to
apply to this problem.

454
00:17:57,950 --> 00:18:00,020
And it could be a
combination of them actually.

455
00:18:00,020 --> 00:18:03,260
And so I'm trying to give
you ways of answering

456
00:18:03,260 --> 00:18:04,290
that question faster.

457
00:18:04,290 --> 00:18:04,790
OK?

458
00:18:04,790 --> 00:18:07,578
So is this a
mechanical reduction

459
00:18:07,578 --> 00:18:08,870
or a modification type problem?

460
00:18:08,870 --> 00:18:11,433
That's just going to help
me determine the difficulty

461
00:18:11,433 --> 00:18:12,350
level of what this is.

462
00:18:12,350 --> 00:18:14,240
You might not be
able to answer it.

463
00:18:14,240 --> 00:18:17,000
But it can give you a sense
for what kind of problem it is.

464
00:18:17,000 --> 00:18:20,840
Is this a problem about data
structures sorting both?

465
00:18:20,840 --> 00:18:22,460
Right?

466
00:18:22,460 --> 00:18:24,860
If it's about data
structures, do I

467
00:18:24,860 --> 00:18:26,780
need to support
sequence type operations

468
00:18:26,780 --> 00:18:30,620
or do I need to store an
extrinsic order on something?

469
00:18:30,620 --> 00:18:34,970
Or is it a thing where I care
about what the objects are?

470
00:18:34,970 --> 00:18:37,850
I'm trying to look things
up by what they are.

471
00:18:37,850 --> 00:18:39,110
Or maybe both?

472
00:18:39,110 --> 00:18:40,580
Or maybe some combination?

473
00:18:40,580 --> 00:18:42,920
If I have a bunch of
different types of keys

474
00:18:42,920 --> 00:18:44,900
that I might want
a query on, I might

475
00:18:44,900 --> 00:18:48,080
have to use at least two
set type of data structures.

476
00:18:48,080 --> 00:18:48,588
Right?

477
00:18:48,588 --> 00:18:50,630
You could get very
complicated with these things.

478
00:18:50,630 --> 00:18:52,790
But putting it in
terms of well, I'm

479
00:18:52,790 --> 00:18:59,150
going to need to do this kind
of operation on these names.

480
00:18:59,150 --> 00:19:01,550
Then I can think, oh, I need
a set data structure there.

481
00:19:01,550 --> 00:19:03,530
I'll think about how to
implement that later.

482
00:19:03,530 --> 00:19:04,490
Should I use a hash table?

483
00:19:04,490 --> 00:19:05,657
Should I use a sorted array?

484
00:19:05,657 --> 00:19:07,550
Should I use a AVL tree?

485
00:19:07,550 --> 00:19:11,780
But thinking about it first
at the abstract level of I

486
00:19:11,780 --> 00:19:15,200
need a set data structure here
can help you compartmentalize

487
00:19:15,200 --> 00:19:17,150
correctness versus efficiency.

488
00:19:17,150 --> 00:19:18,530
Does that make sense?

489
00:19:18,530 --> 00:19:19,610
OK.

490
00:19:19,610 --> 00:19:23,480
If you're stuck, this
is your question.

491
00:19:23,480 --> 00:19:27,590
If you're stuck, write
down a correct algorithm

492
00:19:27,590 --> 00:19:29,540
that's inefficient.

493
00:19:29,540 --> 00:19:32,000
We can give you points for
a correct algorithm that's

494
00:19:32,000 --> 00:19:32,600
inefficient.

495
00:19:32,600 --> 00:19:34,050
At least it's a
correct algorithm.

496
00:19:34,050 --> 00:19:35,510
That's better than other things.

497
00:19:35,510 --> 00:19:36,470
Right?

498
00:19:36,470 --> 00:19:41,150
Now, if it's
exponential time, you

499
00:19:41,150 --> 00:19:44,570
might be limited to 10%
or 20% of the points.

500
00:19:44,570 --> 00:19:47,300
But if it's a log factor--

501
00:19:47,300 --> 00:19:50,360
worse, or linear factor-- worse.

502
00:19:50,360 --> 00:19:52,070
Maybe that's OK.

503
00:19:52,070 --> 00:19:56,270
On a data structures problem,
if any operation takes order n

504
00:19:56,270 --> 00:19:59,405
time, that's probably not going
to give you a lot of points

505
00:19:59,405 --> 00:20:01,280
because the whole point
of the data structure

506
00:20:01,280 --> 00:20:04,520
is to make those
operations fast.

507
00:20:04,520 --> 00:20:08,570
But if it solves the problem,
you'll get some points.

508
00:20:08,570 --> 00:20:10,190
You won't get 0 points.

509
00:20:10,190 --> 00:20:11,000
Yeah?

510
00:20:11,000 --> 00:20:12,458
AUDIENCE: Will we
get any questions

511
00:20:12,458 --> 00:20:14,250
that are like how fast
can you make this?

512
00:20:14,250 --> 00:20:15,350
Make this as fast as possible.

513
00:20:15,350 --> 00:20:15,975
JASON KU: Yeah.

514
00:20:15,975 --> 00:20:19,590
So a lot of times we'll say,
give us an efficient algorithm.

515
00:20:19,590 --> 00:20:20,090
OK.

516
00:20:20,090 --> 00:20:22,820
It's like, whoa, I don't know
if it's efficient or not.

517
00:20:22,820 --> 00:20:25,170
Well, that just means that
faster running times are

518
00:20:25,170 --> 00:20:26,540
going to give you more points.

519
00:20:26,540 --> 00:20:27,110
OK?

520
00:20:27,110 --> 00:20:31,580
So in questions like
that, it's mostly

521
00:20:31,580 --> 00:20:34,370
trying to play this game of--

522
00:20:34,370 --> 00:20:37,850
usually, we'll put an efficient
one in not in terms of a data

523
00:20:37,850 --> 00:20:40,850
structure because usually,
the data structures problem--

524
00:20:40,850 --> 00:20:44,270
it's important in
your implementation

525
00:20:44,270 --> 00:20:47,180
that these data structure
operations be fast.

526
00:20:47,180 --> 00:20:50,090
And we want to tell
you how fast is.

527
00:20:50,090 --> 00:20:50,630
Right?

528
00:20:50,630 --> 00:20:57,200
So data structures questions
in general, there's

529
00:20:57,200 --> 00:20:59,960
usually a trade-off
between running times

530
00:20:59,960 --> 00:21:01,430
of these different operations.

531
00:21:01,430 --> 00:21:04,170
And it's really important how
they relate to each other.

532
00:21:04,170 --> 00:21:05,750
And so for data
structures problem,

533
00:21:05,750 --> 00:21:08,790
it's kind of about getting
those running times.

534
00:21:08,790 --> 00:21:09,290
OK?

535
00:21:09,290 --> 00:21:13,310
With an algorithms problem
where we ask you to do one thing

536
00:21:13,310 --> 00:21:15,590
and we try to do it
as fast as possible,

537
00:21:15,590 --> 00:21:16,610
try to get linear time.

538
00:21:16,610 --> 00:21:17,110
Right?

539
00:21:17,110 --> 00:21:20,570
Most of the time you can't
get better than linear time

540
00:21:20,570 --> 00:21:23,660
if you have to read the
entire input at some point

541
00:21:23,660 --> 00:21:26,180
if I want to find the
things in my data.

542
00:21:26,180 --> 00:21:28,880
And if you can't think of
a linear time algorithm,

543
00:21:28,880 --> 00:21:31,940
think of an n squared thing
or think of n log n thing.

544
00:21:31,940 --> 00:21:32,750
Right?

545
00:21:32,750 --> 00:21:36,950
Maybe that's a little hard for
you guys to think of right now.

546
00:21:36,950 --> 00:21:40,987
But that's why I'm saying start
with any correct algorithm

547
00:21:40,987 --> 00:21:42,320
and then maybe you can optimize.

548
00:21:42,320 --> 00:21:44,000
Maybe you can use a
better data structure

549
00:21:44,000 --> 00:21:45,083
to make it more efficient.

550
00:21:45,083 --> 00:21:46,920
Does that make sense?

551
00:21:46,920 --> 00:21:48,900
Any other questions?

552
00:21:48,900 --> 00:21:50,150
OK.

553
00:21:50,150 --> 00:21:52,260
Moving right along.

554
00:21:52,260 --> 00:21:52,760
OK.

555
00:21:52,760 --> 00:21:55,490
Here's some downsides.

556
00:21:55,490 --> 00:21:56,270
OK.

557
00:21:56,270 --> 00:22:00,410
If you find yourself doing one
of these things three things,

558
00:22:00,410 --> 00:22:01,257
take a step back.

559
00:22:01,257 --> 00:22:02,840
You're probably doing
something wrong.

560
00:22:02,840 --> 00:22:04,070
OK?

561
00:22:04,070 --> 00:22:08,060
So question yourself if you're
trying to compute decimals,

562
00:22:08,060 --> 00:22:10,430
rationals, or real numbers.

563
00:22:10,430 --> 00:22:11,900
I can't store
those things on a--

564
00:22:11,900 --> 00:22:15,060
I mean, I can store decimals
to finite precision.

565
00:22:15,060 --> 00:22:16,710
But if you're doing
finite precision,

566
00:22:16,710 --> 00:22:21,255
you might as well multiply your
numbers by that fixed precision

567
00:22:21,255 --> 00:22:22,380
and deal with the integers.

568
00:22:22,380 --> 00:22:23,340
Right?

569
00:22:23,340 --> 00:22:24,810
We only have taught
you how to deal

570
00:22:24,810 --> 00:22:25,980
with the integers in this class.

571
00:22:25,980 --> 00:22:26,490
Right?

572
00:22:26,490 --> 00:22:30,180
We haven't even shown you
how to efficiently compute

573
00:22:30,180 --> 00:22:32,440
on rationals and real numbers.

574
00:22:32,440 --> 00:22:36,060
We have told you if you have
a denominator and a numerator

575
00:22:36,060 --> 00:22:39,150
of a fraction, I can
take two fractions

576
00:22:39,150 --> 00:22:41,430
and compare them
right in constant time

577
00:22:41,430 --> 00:22:43,140
by doing cross multiplication.

578
00:22:43,140 --> 00:22:49,770
But if I'm trying to actually
do this division to arbitrary

579
00:22:49,770 --> 00:22:54,550
precision, that's not
happy because I can't even

580
00:22:54,550 --> 00:22:56,550
represent that on my
computer in a finite number

581
00:22:56,550 --> 00:22:59,850
of decimal points for
some of these things.

582
00:23:02,670 --> 00:23:05,350
If you're trying to use
Radix sort for every answer,

583
00:23:05,350 --> 00:23:07,620
it's probably wrong.

584
00:23:07,620 --> 00:23:11,700
One of the things that we
try to do on our quizzes--

585
00:23:11,700 --> 00:23:15,210
we're not just giving you a
bunch of problems randomly.

586
00:23:15,210 --> 00:23:17,010
We probably are
making problems that

587
00:23:17,010 --> 00:23:19,740
cover the material in some way.

588
00:23:19,740 --> 00:23:22,350
We do want to test you
on all of the things.

589
00:23:22,350 --> 00:23:26,670
And so if you find that
you're using the same thing

590
00:23:26,670 --> 00:23:29,640
four or five times
on the exam, that

591
00:23:29,640 --> 00:23:33,300
might be a sign that you're
using it too many times.

592
00:23:33,300 --> 00:23:34,342
It's not always the case.

593
00:23:34,342 --> 00:23:34,842
Right?

594
00:23:34,842 --> 00:23:36,360
Sometimes hashing
is super useful,

595
00:23:36,360 --> 00:23:38,140
so you want to use
it all the time.

596
00:23:38,140 --> 00:23:41,940
But in particular,
everyone tries

597
00:23:41,940 --> 00:23:45,090
to use Radix sort when
it's inappropriate.

598
00:23:45,090 --> 00:23:48,300
And they love because
it gets linear time.

599
00:23:48,300 --> 00:23:49,140
Right?

600
00:23:49,140 --> 00:23:55,080
But if you write merge sort for
something where Radix sort will

601
00:23:55,080 --> 00:23:57,840
apply, you'll get some points
because it's correct but not

602
00:23:57,840 --> 00:24:01,080
efficient.

603
00:24:01,080 --> 00:24:03,370
And it's inefficient
by a log factor.

604
00:24:03,370 --> 00:24:04,530
Right?

605
00:24:04,530 --> 00:24:08,790
If you're trying to use
Radix sort in a situation

606
00:24:08,790 --> 00:24:11,340
where comparisons are the
answer and you don't have

607
00:24:11,340 --> 00:24:13,770
a bound on the integers,
if I don't have

608
00:24:13,770 --> 00:24:15,330
a bound on the size
of the integers,

609
00:24:15,330 --> 00:24:19,380
then this may be taking
a huge amount of time.

610
00:24:19,380 --> 00:24:21,870
So I might not
even think of that

611
00:24:21,870 --> 00:24:26,095
as being correct because it
could be exponential time.

612
00:24:26,095 --> 00:24:26,970
I mean, I don't know.

613
00:24:26,970 --> 00:24:28,512
I don't know how
big my word size is.

614
00:24:28,512 --> 00:24:30,850
It could be arbitrarily bad.

615
00:24:30,850 --> 00:24:32,340
OK.

616
00:24:32,340 --> 00:24:34,170
And then if you're
trying to augment

617
00:24:34,170 --> 00:24:37,470
a binary tree with something
that's not a subtree property--

618
00:24:37,470 --> 00:24:40,350
something that can't be
computed from the augmentations

619
00:24:40,350 --> 00:24:41,730
of its two children--

620
00:24:41,730 --> 00:24:43,050
you're doing something bad.

621
00:24:43,050 --> 00:24:48,240
Every exam we have
30% of students

622
00:24:48,240 --> 00:24:58,410
say augment by my index in the
entire tree or augment by--

623
00:24:58,410 --> 00:25:00,150
here's one that's fun--

624
00:25:00,150 --> 00:25:03,195
augment by the size
of my left subtree--

625
00:25:07,090 --> 00:25:09,610
the number of nodes
in my left subtree.

626
00:25:09,610 --> 00:25:10,390
How can I--

627
00:25:14,010 --> 00:25:17,920
I'm not sure how I can maintain
that with rotations and things

628
00:25:17,920 --> 00:25:20,420
like that.

629
00:25:20,420 --> 00:25:21,700
Let's see.

630
00:25:21,700 --> 00:25:24,910
In order for me to keep
track of the augmentation

631
00:25:24,910 --> 00:25:30,430
of my left tree from the
augmentation of my left tree,

632
00:25:30,430 --> 00:25:33,310
I have to do a logarithmic
walk all the way down the thing

633
00:25:33,310 --> 00:25:35,260
to figure out how many
things were there.

634
00:25:35,260 --> 00:25:37,540
So that's not a maintainable
thing in constant time.

635
00:25:37,540 --> 00:25:39,910
If I want to augment
something of my left subtree,

636
00:25:39,910 --> 00:25:42,910
just augment the thing
itself and just look

637
00:25:42,910 --> 00:25:45,250
at your left subtree and
look at its augmentation.

638
00:25:45,250 --> 00:25:46,720
Does that make sense?

639
00:25:46,720 --> 00:25:47,252
Yeah?

640
00:25:47,252 --> 00:25:49,460
AUDIENCE: If you had say,
augmented it with a subtree

641
00:25:49,460 --> 00:25:52,030
and then augmented it again with
[INAUDIBLE] subtree and then

642
00:25:52,030 --> 00:25:52,240
use that--

643
00:25:52,240 --> 00:25:53,240
JASON KU: You could do that.

644
00:25:53,240 --> 00:25:53,920
AUDIENCE: --does
that still count as--

645
00:25:53,920 --> 00:25:54,670
JASON KU: You could do that.

646
00:25:54,670 --> 00:25:55,010
Yeah.

647
00:25:55,010 --> 00:25:56,552
So you could do that
in constant time

648
00:25:56,552 --> 00:25:58,750
by augmenting by subtree size.

649
00:25:58,750 --> 00:25:59,470
Right?

650
00:25:59,470 --> 00:26:01,360
AUDIENCE: And then have another
augmentation in [INAUDIBLE]..

651
00:26:01,360 --> 00:26:03,943
JASON KU: You could have another
augmentation because then you

652
00:26:03,943 --> 00:26:06,580
could just look at-- but then
just look at your left subtree

653
00:26:06,580 --> 00:26:07,350
please.

654
00:26:07,350 --> 00:26:08,473
Yeah.

655
00:26:08,473 --> 00:26:09,640
No reason to store it again.

656
00:26:09,640 --> 00:26:10,140
Right?

657
00:26:10,140 --> 00:26:12,070
You just do one constant time--

658
00:26:12,070 --> 00:26:13,570
look to your left.

659
00:26:13,570 --> 00:26:14,410
OK.

660
00:26:14,410 --> 00:26:15,830
Don't do that.

661
00:26:15,830 --> 00:26:16,450
OK.

662
00:26:16,450 --> 00:26:19,310
So that is-- cool.

663
00:26:19,310 --> 00:26:20,740
I'm not that far behind.

664
00:26:20,740 --> 00:26:25,540
Those are my tips on
solving questions.

665
00:26:25,540 --> 00:26:26,830
Oh, there's one more page.

666
00:26:26,830 --> 00:26:27,330
Yeah?

667
00:26:27,330 --> 00:26:29,270
AUDIENCE: So when
defining an augmentation,

668
00:26:29,270 --> 00:26:32,470
[INAUDIBLE] do the formula and
argue that it's [INAUDIBLE]..

669
00:26:32,470 --> 00:26:33,220
JASON KU: Exactly.

670
00:26:33,220 --> 00:26:33,720
Right.

671
00:26:33,720 --> 00:26:41,320
So the idea is if you give an
augmentation that's not a--

672
00:26:41,320 --> 00:26:43,210
we're going to talk
about our standard things

673
00:26:43,210 --> 00:26:45,460
you can reduce to in a second.

674
00:26:45,460 --> 00:26:49,390
If you're saying, I'm
going to take a set AVL

675
00:26:49,390 --> 00:26:52,990
tree or a sequence AVL tree--

676
00:26:52,990 --> 00:26:55,130
and for example, at
the end of lecture,

677
00:26:55,130 --> 00:26:59,530
we were talking about how
a sequence AVL tree could

678
00:26:59,530 --> 00:27:02,260
be modified to
support priority queue

679
00:27:02,260 --> 00:27:05,650
operations in the same
running times as binary heaps.

680
00:27:05,650 --> 00:27:06,190
Right?

681
00:27:06,190 --> 00:27:10,150
And that was saying we
store our subtree maxes--

682
00:27:10,150 --> 00:27:12,490
the max thing in my subtree.

683
00:27:12,490 --> 00:27:14,800
Right?

684
00:27:14,800 --> 00:27:16,660
And so that's a
different augmentation

685
00:27:16,660 --> 00:27:20,960
than what's already augmented
on the sequence AVL tree.

686
00:27:20,960 --> 00:27:25,400
What are the augmentations
on a sequence AVL tree?

687
00:27:25,400 --> 00:27:26,320
AUDIENCE: Size.

688
00:27:26,320 --> 00:27:27,444
JASON KU: Size.

689
00:27:27,444 --> 00:27:29,038
AUDIENCE: Count.

690
00:27:29,038 --> 00:27:31,330
JASON KU: So counts is the
same thing as how many nodes

691
00:27:31,330 --> 00:27:32,080
are in my subtree.

692
00:27:32,080 --> 00:27:32,590
And?

693
00:27:32,590 --> 00:27:33,100
AUDIENCE: Height.

694
00:27:33,100 --> 00:27:33,808
JASON KU: Height.

695
00:27:33,808 --> 00:27:35,410
Right because it's an AVL tree.

696
00:27:35,410 --> 00:27:36,730
Right?

697
00:27:36,730 --> 00:27:40,690
So if I'm augmenting
by max in my subtree,

698
00:27:40,690 --> 00:27:43,210
that's not part of my
standard interface.

699
00:27:43,210 --> 00:27:44,595
So you need to tell me that.

700
00:27:44,595 --> 00:27:45,970
Even though we've
done it before,

701
00:27:45,970 --> 00:27:47,710
it should be very easy for you.

702
00:27:47,710 --> 00:27:49,930
Just say, I'm
augmenting by my max.

703
00:27:49,930 --> 00:27:53,260
Max can be computed
as the max between me

704
00:27:53,260 --> 00:27:55,300
and my left and right
subtree if they exist.

705
00:27:55,300 --> 00:27:55,840
Done.

706
00:27:55,840 --> 00:27:56,620
Right?

707
00:27:56,620 --> 00:27:58,270
But just do that.

708
00:27:58,270 --> 00:27:59,560
You have to tell me--

709
00:27:59,560 --> 00:28:01,270
and it takes
constant time, so it

710
00:28:01,270 --> 00:28:05,450
can be maintained at constant
time when I'm doing my stuff.

711
00:28:05,450 --> 00:28:07,840
Does that makes sense?

712
00:28:07,840 --> 00:28:08,560
OK.

713
00:28:08,560 --> 00:28:11,470
So the last thing,
I guess especially

714
00:28:11,470 --> 00:28:14,380
on the data
structures problems, I

715
00:28:14,380 --> 00:28:17,380
would suggest that you
approach these things

716
00:28:17,380 --> 00:28:23,000
by solving these problems just
in terms of the interfaces

717
00:28:23,000 --> 00:28:24,250
first.

718
00:28:24,250 --> 00:28:27,370
Because then at least you
get something that's correct.

719
00:28:27,370 --> 00:28:31,210
And then choose the
algorithms or data structures

720
00:28:31,210 --> 00:28:35,140
that you use to implement
those interfaces afterwards.

721
00:28:35,140 --> 00:28:37,280
One gets you to a
correct algorithm.

722
00:28:37,280 --> 00:28:39,070
The other is for efficiency.

723
00:28:39,070 --> 00:28:42,070
Decoupling these might help
you in solving the problem.

724
00:28:42,070 --> 00:28:45,290
If it doesn't help you, don't.

725
00:28:45,290 --> 00:28:48,310
If you're like, whenever I
see a set data structure,

726
00:28:48,310 --> 00:28:53,710
I'm going to probably use a hash
table, that's probably fine.

727
00:28:53,710 --> 00:28:55,900
But if we're looking for
worst case time bounds,

728
00:28:55,900 --> 00:28:57,300
that's probably not fun.

729
00:28:57,300 --> 00:28:58,990
So you just--

730
00:29:02,090 --> 00:29:07,300
I'm suggesting that you separate
these things so that you

731
00:29:07,300 --> 00:29:08,980
concentrate on solving
the problem first

732
00:29:08,980 --> 00:29:10,240
and then optimize it later.

733
00:29:10,240 --> 00:29:10,960
Yeah?

734
00:29:10,960 --> 00:29:12,510
AUDIENCE: Just a question
in regards to worst case

735
00:29:12,510 --> 00:29:13,030
time bounds.

736
00:29:13,030 --> 00:29:13,750
JASON KU: Mm-hmm.

737
00:29:13,750 --> 00:29:15,140
AUDIENCE: So for a hash table.

738
00:29:15,140 --> 00:29:15,580
JASON KU: Mm-hmm.

739
00:29:15,580 --> 00:29:16,705
AUDIENCE: Given that's
a code one expected.

740
00:29:16,705 --> 00:29:17,920
JASON KU: Mm-hmm.

741
00:29:17,920 --> 00:29:20,227
AUDIENCE: That also implies
that's O of n worst case.

742
00:29:20,227 --> 00:29:21,310
So could you --technically

743
00:29:21,310 --> 00:29:22,643
JASON KU: It doesn't imply that.

744
00:29:22,643 --> 00:29:24,160
It is that.

745
00:29:24,160 --> 00:29:26,770
So, I mean, you could have
a data structure whose

746
00:29:26,770 --> 00:29:30,130
expected time bound is constant,
but it's a worst case bound

747
00:29:30,130 --> 00:29:31,400
is n log n.

748
00:29:31,400 --> 00:29:34,720
It just happens to be the
fact that for a hash table,

749
00:29:34,720 --> 00:29:37,990
those worst case
operations are linear.

750
00:29:37,990 --> 00:29:41,740
But if I --had we had a
question up here beforehand,

751
00:29:41,740 --> 00:29:45,190
if I had a running time
bound that I did something

752
00:29:45,190 --> 00:29:51,040
to a hash table in constant
expected time, I did a look up,

753
00:29:51,040 --> 00:29:56,020
and then I queried an a AVL tree
for the predecessor of a node

754
00:29:56,020 --> 00:29:58,030
or something like
that, and I did

755
00:29:58,030 --> 00:30:03,850
that in O of log n time,
what's the worst case running

756
00:30:03,850 --> 00:30:04,420
time of that?

757
00:30:04,420 --> 00:30:05,320
AUDIENCE: O of n.

758
00:30:05,320 --> 00:30:07,090
JASON KU: O of n.

759
00:30:07,090 --> 00:30:09,977
What's the expected
running time of this thing?

760
00:30:09,977 --> 00:30:11,440
AUDIENCE: Log n.

761
00:30:11,440 --> 00:30:12,610
JASON KU: Log n.

762
00:30:12,610 --> 00:30:14,050
Expected log n.

763
00:30:14,050 --> 00:30:15,920
Because it's possible
that in the worst case

764
00:30:15,920 --> 00:30:16,712
it could be higher.

765
00:30:16,712 --> 00:30:18,810
Does that makes sense?

766
00:30:18,810 --> 00:30:19,310
OK.

767
00:30:23,960 --> 00:30:25,370
--so OK.

768
00:30:25,370 --> 00:30:29,030
The second bullet is just
setting up a data structures

769
00:30:29,030 --> 00:30:29,680
problem.

770
00:30:29,680 --> 00:30:31,175
There's a lot of moving parts.

771
00:30:31,175 --> 00:30:33,050
We're going to do two
data structures problem

772
00:30:33,050 --> 00:30:35,810
at the end of this session.

773
00:30:35,810 --> 00:30:41,120
Describe all of the data
structures you're using,

774
00:30:41,120 --> 00:30:42,620
including what they store.

775
00:30:42,620 --> 00:30:44,510
If you're storing a
set data structure,

776
00:30:44,510 --> 00:30:47,150
you better tell me what
the things you're stored

777
00:30:47,150 --> 00:30:49,340
are keyed on.

778
00:30:49,340 --> 00:30:51,170
Usually the things
that we're storing

779
00:30:51,170 --> 00:30:53,450
contain a bunch of
information, and if you just

780
00:30:53,450 --> 00:30:57,920
say I'm storing all of
the toppings of my pizza

781
00:30:57,920 --> 00:31:01,323
in the set data structure,
and that's all you tell me,

782
00:31:01,323 --> 00:31:02,990
I have no idea what
you're talking about

783
00:31:02,990 --> 00:31:04,940
because I don't know what
the semantics of your data

784
00:31:04,940 --> 00:31:05,523
structure are.

785
00:31:05,523 --> 00:31:06,830
What is it keyed on?

786
00:31:06,830 --> 00:31:09,260
I have to say,
oh, it's keyed on,

787
00:31:09,260 --> 00:31:14,140
I don't know the y's
or something like that.

788
00:31:14,140 --> 00:31:14,930
OK.

789
00:31:14,930 --> 00:31:16,140
And there are invariants.

790
00:31:16,140 --> 00:31:18,920
How we're setting up these
data structures problem,

791
00:31:18,920 --> 00:31:22,880
usually how I solve these when
I'm writing the solutions,

792
00:31:22,880 --> 00:31:28,250
I set up a state of what
this data structure could

793
00:31:28,250 --> 00:31:29,600
be at some instance.

794
00:31:29,600 --> 00:31:31,880
I'm going to say,
this data structure

795
00:31:31,880 --> 00:31:35,090
stores all of the
things less than --k

796
00:31:35,090 --> 00:31:37,340
with key less than
k, blah, blah, blah.

797
00:31:37,340 --> 00:31:41,600
And this one stores
the extrinsic order

798
00:31:41,600 --> 00:31:45,320
of the items based
on blah, blah, blah.

799
00:31:45,320 --> 00:31:46,100
OK.

800
00:31:46,100 --> 00:31:50,450
So actually, me stating
what they store in that way

801
00:31:50,450 --> 00:31:53,690
is actually imposing some kind
of invariant on these data

802
00:31:53,690 --> 00:31:56,480
structures that I'm
wanting to maintain.

803
00:31:56,480 --> 00:31:59,150
But what I need to do to prove
that this thing is correct

804
00:31:59,150 --> 00:32:04,280
is that based on the assumption
that those invariants held

805
00:32:04,280 --> 00:32:07,820
before my operation.

806
00:32:07,820 --> 00:32:09,920
Then I can prove that
an operation is correct

807
00:32:09,920 --> 00:32:15,620
if all of those invariants
are maintained before, then

808
00:32:15,620 --> 00:32:16,920
after the operation.

809
00:32:16,920 --> 00:32:19,610
That's kind of how I'm proving
that this thing is correct.

810
00:32:19,610 --> 00:32:22,100
And then when I'm querying,
I'm doing some kind of lookup

811
00:32:22,100 --> 00:32:25,280
on this data structure, I
can rely on those invariants.

812
00:32:25,280 --> 00:32:27,460
I know that those
things are good,

813
00:32:27,460 --> 00:32:29,780
those things have
been maintained,

814
00:32:29,780 --> 00:32:32,420
and so I can rely on
those to look up what's

815
00:32:32,420 --> 00:32:34,250
the largest k of this thing.

816
00:32:34,250 --> 00:32:35,408
Does that make sense?

817
00:32:35,408 --> 00:32:36,950
If this is very
abstract, we're going

818
00:32:36,950 --> 00:32:40,650
to get a little bit more
concrete in just a second.

819
00:32:40,650 --> 00:32:44,060
And then implement
every operation.

820
00:32:44,060 --> 00:32:45,950
You have no idea
how many solutions

821
00:32:45,950 --> 00:32:50,570
we read on the quizzes,
which we give you

822
00:32:50,570 --> 00:32:55,400
three operations to implement
and you don't even mention one.

823
00:32:55,400 --> 00:32:57,260
And it's usually
the easiest one.

824
00:32:57,260 --> 00:32:59,990
It's like inserted into
your data structure.

825
00:32:59,990 --> 00:33:02,330
It's like, come
on, just say that.

826
00:33:02,330 --> 00:33:05,630
We can't give you points unless
you mention that operation.

827
00:33:05,630 --> 00:33:07,480
Does that make sense?

828
00:33:07,480 --> 00:33:10,520
And then it's going
to help --us happy

829
00:33:10,520 --> 00:33:12,740
graders give you more points.

830
00:33:12,740 --> 00:33:17,840
Not really, but if
your solution is

831
00:33:17,840 --> 00:33:21,200
well-organized and well-labeled
and things like that,

832
00:33:21,200 --> 00:33:24,760
then we're going to be able to
comprehend your solution better

833
00:33:24,760 --> 00:33:26,510
and we'll be able to
give you more points.

834
00:33:26,510 --> 00:33:30,510
Remember, part of this class
is about communication.

835
00:33:30,510 --> 00:33:37,040
If your thing is correct but we
can't tell what you're saying,

836
00:33:37,040 --> 00:33:38,035
then it's not correct.

837
00:33:42,020 --> 00:33:44,280
OK.

838
00:33:44,280 --> 00:33:44,780
All right.

839
00:33:44,780 --> 00:33:48,470
So now we get --to
any questions on that?

840
00:33:48,470 --> 00:33:49,242
Yeah.

841
00:33:49,242 --> 00:33:51,020
AUDIENCE: Just a
question on invariants.

842
00:33:51,020 --> 00:33:52,760
So one of the data
structures that we've

843
00:33:52,760 --> 00:33:54,135
discussed in the
class previously

844
00:33:54,135 --> 00:33:55,750
to state like what
the invariants are,

845
00:33:55,750 --> 00:33:57,243
like the set AVL tree rule.

846
00:33:57,243 --> 00:33:57,910
JASON KU: Right.

847
00:33:57,910 --> 00:33:59,950
So if it's the
standard things, we

848
00:33:59,950 --> 00:34:04,240
were going to talk about what
the standard things are now.

849
00:34:04,240 --> 00:34:07,330
Then you don't need to
re-argue or --restate

850
00:34:07,330 --> 00:34:10,600
I mean, you can
basically say like,

851
00:34:10,600 --> 00:34:14,962
because the set and sequence
interfaces are defined

852
00:34:14,962 --> 00:34:16,420
that way, these
things are correct,

853
00:34:16,420 --> 00:34:22,000
like --almost you
can --basically

854
00:34:22,000 --> 00:34:25,719
you're trying to convince
us that why it's correct.

855
00:34:25,719 --> 00:34:28,600
If you're correctly using
a set or sequence data

856
00:34:28,600 --> 00:34:32,710
structure in these data
structures-type problems, then

857
00:34:32,710 --> 00:34:38,239
unless you're using it
in a way that is unusual,

858
00:34:38,239 --> 00:34:41,080
usually you can just
rely on the properties

859
00:34:41,080 --> 00:34:43,790
of the set and sequence data
structures that we gave you.

860
00:34:43,790 --> 00:34:48,070
I do want you to mention that
you thought about correctness.

861
00:34:48,070 --> 00:34:54,790
Like this data structure
is correct because.

862
00:34:54,790 --> 00:34:58,840
Just write a sentence
saying that and arguing

863
00:34:58,840 --> 00:35:01,480
that you're
basically maintaining

864
00:35:01,480 --> 00:35:03,460
the invariance of your
data structure kind

865
00:35:03,460 --> 00:35:04,960
of at the upper level.

866
00:35:04,960 --> 00:35:08,590
What kinds of things is
this data structure storing?

867
00:35:08,590 --> 00:35:14,320
What things about the
global data structure

868
00:35:14,320 --> 00:35:16,900
are we relying on to
make query operations?

869
00:35:16,900 --> 00:35:22,000
As long as you are convincing
that after a dynamic operation

870
00:35:22,000 --> 00:35:25,210
when modifying the data
structure that those invariant

871
00:35:25,210 --> 00:35:29,830
stay the --same that are
still satisfied, then

872
00:35:29,830 --> 00:35:32,770
that's really all
you need to say.

873
00:35:32,770 --> 00:35:36,160
These invariants are
satisfied because

874
00:35:36,160 --> 00:35:39,670
of the definitions of a set
and sequence data structure.

875
00:35:39,670 --> 00:35:42,550
A lot of times it doesn't
require a lot of thought

876
00:35:42,550 --> 00:35:45,310
for --the we're not
--asking the reason

877
00:35:45,310 --> 00:35:48,850
why we do reduction
problems is so you

878
00:35:48,850 --> 00:35:51,490
don't have to do a lot of
work to prove to us that it's

879
00:35:51,490 --> 00:35:52,480
correct.

880
00:35:52,480 --> 00:35:54,610
We have these really
nice black boxes.

881
00:35:54,610 --> 00:35:55,480
They are correct.

882
00:35:55,480 --> 00:35:57,970
We proved them to you
that they're correct,

883
00:35:57,970 --> 00:36:01,480
and so you don't have
to redo that work.

884
00:36:01,480 --> 00:36:07,420
So now we're going to go
through the core material I like

885
00:36:07,420 --> 00:36:09,610
to think about in this class.

886
00:36:09,610 --> 00:36:11,350
The first part of
this class, aside

887
00:36:11,350 --> 00:36:16,960
from these mathematical
tools that we developed

888
00:36:16,960 --> 00:36:18,460
at the beginning
of the course, it's

889
00:36:18,460 --> 00:36:21,670
mostly about solving problems
involving data structures.

890
00:36:21,670 --> 00:36:24,310
And we motivated this
problem of sorting

891
00:36:24,310 --> 00:36:27,070
by saying that a sorted array
is a data structure that's

892
00:36:27,070 --> 00:36:28,720
actually pretty useful.

893
00:36:28,720 --> 00:36:31,030
But how do we sort those things?

894
00:36:31,030 --> 00:36:35,350
Well, we showed you a
bunch of ways to do that.

895
00:36:35,350 --> 00:36:37,900
And this is that nice table.

896
00:36:37,900 --> 00:36:40,540
Lots of stuff.

897
00:36:40,540 --> 00:36:42,500
Why do we show you so
many sorting algorithms?

898
00:36:42,500 --> 00:36:45,694
Why don't we just give
you one algorithm?

899
00:36:45,694 --> 00:36:46,790
Hmm?

900
00:36:46,790 --> 00:36:47,290
Yeah?

901
00:36:47,290 --> 00:36:49,270
AUDIENCE: --run times.

902
00:36:49,270 --> 00:36:50,830
JASON KU: Different run times.

903
00:36:50,830 --> 00:36:51,850
AUDIENCE: Better for --different

904
00:36:51,850 --> 00:36:52,915
JASON KU: Better for
different scenarios.

905
00:36:52,915 --> 00:36:53,260
AUDIENCE: Yeah.

906
00:36:53,260 --> 00:36:55,107
They each have their
own individual points,

907
00:36:55,107 --> 00:36:55,940
then they do better.

908
00:36:55,940 --> 00:36:56,565
JASON KU: Yeah.

909
00:36:56,565 --> 00:37:00,820
You'll notice in
this table, there's

910
00:37:00,820 --> 00:37:05,260
not blue all the way across
for any of these things.

911
00:37:05,260 --> 00:37:07,720
So some of them are better
for different scenarios.

912
00:37:07,720 --> 00:37:12,250
And actually, these comments
list some special cases where

913
00:37:12,250 --> 00:37:14,200
these things might be better.

914
00:37:14,200 --> 00:37:17,920
In actuality, this
ultra-blue thing

915
00:37:17,920 --> 00:37:20,710
is saying like this
could be linear time.

916
00:37:20,710 --> 00:37:22,270
That's better.

917
00:37:22,270 --> 00:37:26,470
But in some cases this is worse
than all the other things.

918
00:37:26,470 --> 00:37:31,570
So be a little wary of
this blue color here.

919
00:37:31,570 --> 00:37:35,620
Generally we're trying to get
you further down in this chart

920
00:37:35,620 --> 00:37:37,900
if you can.

921
00:37:37,900 --> 00:37:45,100
And in general, like for
example, merge sort, AVL sort,

922
00:37:45,100 --> 00:37:48,580
these are really the same in
terms of asymptotic complexity

923
00:37:48,580 --> 00:37:51,460
and the way in which you
interact with these sorting

924
00:37:51,460 --> 00:37:53,110
rooms.

925
00:37:53,110 --> 00:37:54,910
But there are
special cases where

926
00:37:54,910 --> 00:37:58,900
you might use insertion sort
or selection --sort actually,

927
00:37:58,900 --> 00:38:01,450
I'm not sure about
insertion sort.

928
00:38:01,450 --> 00:38:07,750
You had in your
recitation two days ago--

929
00:38:07,750 --> 00:38:11,350
I think you guys
showed how to do

930
00:38:11,350 --> 00:38:14,890
if you had a k-proximate array
where things are not more

931
00:38:14,890 --> 00:38:16,450
than k away from each other.

932
00:38:16,450 --> 00:38:18,643
Insertion sort actually
runs in n times k,

933
00:38:18,643 --> 00:38:20,560
and so if k is small,
then that's really good,

934
00:38:20,560 --> 00:38:22,390
that's kind of like linear.

935
00:38:22,390 --> 00:38:24,640
But you can actually
do even better

936
00:38:24,640 --> 00:38:28,270
with a binary heap, which you
saw in recitation, hopefully,

937
00:38:28,270 --> 00:38:32,470
where you can get that down to
n log k by --keeping maintaining

938
00:38:32,470 --> 00:38:37,840
a heap as you go across and
finding the max that way.

939
00:38:37,840 --> 00:38:40,780
So insertion sort
maybe is not so great.

940
00:38:40,780 --> 00:38:43,840
But selection sort,
the name of the game

941
00:38:43,840 --> 00:38:50,290
there is that if
my reads are cheap

942
00:38:50,290 --> 00:38:54,120
but my writes are
expensive, selection sort

943
00:38:54,120 --> 00:38:56,670
it actually does pretty
well, because I only have--

944
00:38:56,670 --> 00:38:57,540
sorry.

945
00:38:57,540 --> 00:39:00,450
Reads are cheap and my
writes are expensive.

946
00:39:00,450 --> 00:39:02,675
Selection sort does a
linear number of swaps.

947
00:39:02,675 --> 00:39:04,800
It's looking down, finding
the max, swapping it in,

948
00:39:04,800 --> 00:39:06,240
and keep it going.

949
00:39:06,240 --> 00:39:08,460
And so in such cases,
that's actually

950
00:39:08,460 --> 00:39:11,770
better than any of these other
algorithms that we've got.

951
00:39:11,770 --> 00:39:12,270
Yeah?

952
00:39:12,270 --> 00:39:13,464
AUDIENCE: Those heap --sorts

953
00:39:13,464 --> 00:39:14,220
JASON KU: Mm-hmm.

954
00:39:14,220 --> 00:39:17,130
AUDIENCE: --time, worst
case are expected.

955
00:39:17,130 --> 00:39:19,350
JASON KU: This is worst case.

956
00:39:19,350 --> 00:39:21,090
So it's a little hard to--

957
00:39:21,090 --> 00:39:24,330
there was a lot of moving
parts to get to this bound

958
00:39:24,330 --> 00:39:27,360
in Tuesday's lecture.

959
00:39:27,360 --> 00:39:28,920
Basically what we
did, we showed you

960
00:39:28,920 --> 00:39:31,920
how to think of an
array as a heap--

961
00:39:31,920 --> 00:39:34,020
as a binary tree.

962
00:39:34,020 --> 00:39:35,220
Complete binary tree.

963
00:39:35,220 --> 00:39:36,720
It's not an AVL--

964
00:39:36,720 --> 00:39:40,380
I mean, it is an AVL
tree, but AVL trees

965
00:39:40,380 --> 00:39:43,190
are weaker than a complete tree.

966
00:39:43,190 --> 00:39:46,470
Height balance is a weaker
property than a complete.

967
00:39:46,470 --> 00:39:50,580
The reason why we use
complete is because it's

968
00:39:50,580 --> 00:39:54,270
unique for a number of nodes.

969
00:39:54,270 --> 00:39:57,963
That way, when I give you one
array with a fixed length,

970
00:39:57,963 --> 00:39:59,880
I know exactly what tree
you're talking about,

971
00:39:59,880 --> 00:40:03,547
because there's a
one-to-one mapping there.

972
00:40:03,547 --> 00:40:10,350
If there was some ambiguity on
what tree I was talking about,

973
00:40:10,350 --> 00:40:13,290
I --wouldn't heaps
just wouldn't work.

974
00:40:13,290 --> 00:40:17,130
So what heap sort does is
it has this correspondence

975
00:40:17,130 --> 00:40:20,010
between arrays and binary trees.

976
00:40:20,010 --> 00:40:22,470
And then what it
does is it provides

977
00:40:22,470 --> 00:40:26,940
these operations that kind of
only do operations at the end.

978
00:40:26,940 --> 00:40:30,330
And then the
in-place optimization

979
00:40:30,330 --> 00:40:32,970
is that, well, instead of
actually popping it or pushing

980
00:40:32,970 --> 00:40:34,920
it onto the back
of an array, I'm

981
00:40:34,920 --> 00:40:39,660
just going to think of a
subset of my array as a heap

982
00:40:39,660 --> 00:40:45,960
and then always kind of
pooping the max out to the end.

983
00:40:45,960 --> 00:40:49,020
Just leaving it behind
and thinking of my heap

984
00:40:49,020 --> 00:40:51,660
as a smaller subset.

985
00:40:51,660 --> 00:40:55,095
And that's how we --got
it didn't actually

986
00:40:55,095 --> 00:40:58,950
de-use any amortization.

987
00:40:58,950 --> 00:41:01,440
For the time bound, time
bounds you could actually

988
00:41:01,440 --> 00:41:04,950
do this with the amortized
basically dynamic array

989
00:41:04,950 --> 00:41:05,940
version of this.

990
00:41:05,940 --> 00:41:07,530
The time bound
doesn't rely on that.

991
00:41:07,530 --> 00:41:12,720
The in-place relies on keys
staying all within one array.

992
00:41:12,720 --> 00:41:14,250
Does that make sense?

993
00:41:14,250 --> 00:41:17,080
You're doing a bunch of
amortized operations,

994
00:41:17,080 --> 00:41:19,530
so that this actually does
achieve worst case n log n.

995
00:41:19,530 --> 00:41:20,280
Yeah?

996
00:41:20,280 --> 00:41:22,632
AUDIENCE: It seems that
the things we learned--

997
00:41:22,632 --> 00:41:23,340
JASON KU: Mm-hmm.

998
00:41:23,340 --> 00:41:24,550
AUDIENCE: --not like--

999
00:41:24,550 --> 00:41:25,440
JASON KU: Mm-hmm.

1000
00:41:25,440 --> 00:41:26,815
AUDIENCE: They
tend to be better.

1001
00:41:26,815 --> 00:41:29,594
So assume that most algorithms
than we want them to be--

1002
00:41:29,594 --> 00:41:31,210
JASON KU: Uh huh.

1003
00:41:31,210 --> 00:41:32,430
AUDIENCE: --faster.

1004
00:41:32,430 --> 00:41:35,460
It seems like people will
not use as often, especially

1005
00:41:35,460 --> 00:41:37,620
in these [INAUDIBLE]
insertion and selection.

1006
00:41:37,620 --> 00:41:38,537
JASON KU: Right, yeah.

1007
00:41:38,537 --> 00:41:40,920
So there are these special
cases where they're good,

1008
00:41:40,920 --> 00:41:45,690
but, I mean, generally
these are better

1009
00:41:45,690 --> 00:41:48,600
general data structures
for most situations

1010
00:41:48,600 --> 00:41:49,710
that you come across.

1011
00:41:49,710 --> 00:41:52,140
I mean, there are cases where
those other things are good,

1012
00:41:52,140 --> 00:41:54,210
so you don't want to
completely ignore them,

1013
00:41:54,210 --> 00:41:58,200
but generally, yeah, you're
trying to be lower bound

1014
00:41:58,200 --> 00:41:58,800
in this chart.

1015
00:41:58,800 --> 00:42:01,383
AUDIENCE: What I mean is that
if I don't have any --bound like

1016
00:42:01,383 --> 00:42:03,780
I'm using them all except
for selection sort--

1017
00:42:03,780 --> 00:42:05,910
JASON KU: So there's
too many things on here

1018
00:42:05,910 --> 00:42:09,030
for us to test all
of them on an exam.

1019
00:42:09,030 --> 00:42:12,300
So don't be afraid if not
everything is covered.

1020
00:42:12,300 --> 00:42:15,360
Worry when things are
covered 18 times on the exam,

1021
00:42:15,360 --> 00:42:17,020
that's not good.

1022
00:42:17,020 --> 00:42:17,520
OK.

1023
00:42:17,520 --> 00:42:20,970
So for radix sort,
there are situations

1024
00:42:20,970 --> 00:42:23,430
where you get linear time.

1025
00:42:23,430 --> 00:42:25,380
It's when you're
polynomial-bounded.

1026
00:42:25,380 --> 00:42:28,770
Are there times
when I want to use

1027
00:42:28,770 --> 00:42:31,680
radix sort when I'm
not polynomial-bounded

1028
00:42:31,680 --> 00:42:32,565
in my integers?

1029
00:42:37,708 --> 00:42:39,750
AUDIENCE: Well, if you're
not polynomial-bounded,

1030
00:42:39,750 --> 00:42:41,790
then that could take
a really long time.

1031
00:42:41,790 --> 00:42:43,210
JASON KU: Sure, yeah.

1032
00:42:43,210 --> 00:42:49,990
But like where's --the this
will be worse than n log n when?

1033
00:42:52,960 --> 00:42:55,270
It's definitely
better than n log n

1034
00:42:55,270 --> 00:42:58,330
when u is polynomially bounded.

1035
00:42:58,330 --> 00:43:00,540
Because it's linear.

1036
00:43:00,540 --> 00:43:01,390
Yeah?

1037
00:43:01,390 --> 00:43:03,520
AUDIENCE: [INAUDIBLE]
n to the n.

1038
00:43:03,520 --> 00:43:05,370
JASON KU: n to the n.

1039
00:43:05,370 --> 00:43:05,870
OK.

1040
00:43:05,870 --> 00:43:09,490
So if I put n to
the n in here, I

1041
00:43:09,490 --> 00:43:12,310
get an n factor
that comes out here.

1042
00:43:12,310 --> 00:43:15,080
That gives me a
quadratic running time,

1043
00:43:15,080 --> 00:43:17,710
which is not great.

1044
00:43:17,710 --> 00:43:22,750
But when will this be
better then n log n?

1045
00:43:22,750 --> 00:43:24,010
Yeah?

1046
00:43:24,010 --> 00:43:27,757
AUDIENCE: n to the c,
because it's less n to the c.

1047
00:43:27,757 --> 00:43:29,590
JASON KU: n to the c--
so that'll definitely

1048
00:43:29,590 --> 00:43:31,025
give us linear time.

1049
00:43:31,025 --> 00:43:32,150
That's what this is saying.

1050
00:43:32,150 --> 00:43:35,710
But we can actually
do better than n log n

1051
00:43:35,710 --> 00:43:43,150
if this u is n to the c
times log n for some c.

1052
00:43:43,150 --> 00:43:48,610
If --it's like if it's
n to the c log log n,

1053
00:43:48,610 --> 00:43:50,070
that's smaller than log n.

1054
00:43:50,070 --> 00:43:52,360
So that's a better algorithm.

1055
00:43:52,360 --> 00:43:53,590
That's a faster algorithm.

1056
00:43:53,590 --> 00:43:58,600
Do you guys see why we
wrote these things this way?

1057
00:43:58,600 --> 00:44:02,140
It's so that we give
you a more --precise

1058
00:44:02,140 --> 00:44:05,680
this is more important for you
understand what u means here

1059
00:44:05,680 --> 00:44:09,040
than that this thing
sometimes runs in linear time.

1060
00:44:09,040 --> 00:44:12,740
We want to know when
it runs in linear time.

1061
00:44:12,740 --> 00:44:13,900
Does that makes sense?

1062
00:44:13,900 --> 00:44:16,755
Or when it runs faster
than merge sort.

1063
00:44:16,755 --> 00:44:19,850
Does that makes sense?

1064
00:44:19,850 --> 00:44:20,350
OK.

1065
00:44:20,350 --> 00:44:21,505
So that's sorting.

1066
00:44:24,160 --> 00:44:26,320
We have sequence-type
data structures.

1067
00:44:26,320 --> 00:44:28,870
We have linked lists,
we have dynamic arrays,

1068
00:44:28,870 --> 00:44:30,070
we have sequence AVLs.

1069
00:44:30,070 --> 00:44:32,310
Sequence AVLs are great.

1070
00:44:32,310 --> 00:44:34,030
I don't know why
no one teaches it.

1071
00:44:34,030 --> 00:44:35,290
They're great.

1072
00:44:35,290 --> 00:44:38,230
They don't teach it probably
because they're actually not

1073
00:44:38,230 --> 00:44:40,930
that useful.

1074
00:44:40,930 --> 00:44:45,760
You don't actually use the
insert in the middle a lot

1075
00:44:45,760 --> 00:44:46,660
in coding.

1076
00:44:46,660 --> 00:44:50,140
So it's-- you can usually
get around with like shifting

1077
00:44:50,140 --> 00:44:53,045
something to the end and doing
dynamic operations there,

1078
00:44:53,045 --> 00:44:55,420
and that's a lot of the games
that you try to play so you

1079
00:44:55,420 --> 00:44:57,490
don't have to make your
own data structures,

1080
00:44:57,490 --> 00:45:02,230
and you can just use the
Python list that's in your--

1081
00:45:02,230 --> 00:45:04,120
like native to your thing.

1082
00:45:04,120 --> 00:45:06,190
But it has a
theoretical interest

1083
00:45:06,190 --> 00:45:08,530
because it gets these
kind of balanced bounds

1084
00:45:08,530 --> 00:45:12,970
if you need to insert in
the middle of this sequence.

1085
00:45:12,970 --> 00:45:18,400
Now some of you look at me
and had a question before that

1086
00:45:18,400 --> 00:45:24,490
was like, but Jason,
how does linked list

1087
00:45:24,490 --> 00:45:27,760
operations on the
end of a linked list,

1088
00:45:27,760 --> 00:45:30,220
why does that take linear time?

1089
00:45:30,220 --> 00:45:34,030
It's because in lecture,
we presented you with what?

1090
00:45:36,890 --> 00:45:39,620
A singly-linked list.

1091
00:45:39,620 --> 00:45:42,412
It just had pointers
to the next thing.

1092
00:45:42,412 --> 00:45:44,870
And if I only have pointers to
the next thing and a pointer

1093
00:45:44,870 --> 00:45:49,130
to the head, for
me to find the end,

1094
00:45:49,130 --> 00:45:52,430
I need to walk all
the way down the list.

1095
00:45:52,430 --> 00:45:57,500
Now let's say I keep my pointer
to the tail, then finding that

1096
00:45:57,500 --> 00:46:01,340
and n1 is fine, but removing
it still takes linear time,

1097
00:46:01,340 --> 00:46:04,610
because I don't know
what came before me.

1098
00:46:04,610 --> 00:46:08,420
And so that's why in
p-set whatever, 1, 2,

1099
00:46:08,420 --> 00:46:11,810
I don't remember, you
stored a pointer back

1100
00:46:11,810 --> 00:46:14,190
to your previous one that
gave you doubly-linked lists.

1101
00:46:14,190 --> 00:46:15,110
Yay, right?

1102
00:46:15,110 --> 00:46:19,130
So actually, expanding
this table out,

1103
00:46:19,130 --> 00:46:22,400
you can reference a
doubly-linked list here and get

1104
00:46:22,400 --> 00:46:24,940
this one as constant time.

1105
00:46:24,940 --> 00:46:26,550
Does that make sense?

1106
00:46:26,550 --> 00:46:30,860
And this one's
still linear time.

1107
00:46:30,860 --> 00:46:32,000
OK.

1108
00:46:32,000 --> 00:46:34,200
But this one's
still linear time.

1109
00:46:34,200 --> 00:46:36,650
We actually also
showed you how to do

1110
00:46:36,650 --> 00:46:38,540
this in constant amortized.

1111
00:46:38,540 --> 00:46:40,100
Do you guys remember that?

1112
00:46:40,100 --> 00:46:45,080
That was in problem
session 2 or 1?

1113
00:46:45,080 --> 00:46:46,670
I don't remember.

1114
00:46:46,670 --> 00:46:50,360
It was whatever we talking
about amortized stuff.

1115
00:46:50,360 --> 00:46:52,100
We --got we got
actually both of these

1116
00:46:52,100 --> 00:46:58,160
to one amortized using the
concepts of the dynamic array.

1117
00:46:58,160 --> 00:47:00,470
And then we actually
did it one more time

1118
00:47:00,470 --> 00:47:02,390
where we got a good
doubly-ended thing.

1119
00:47:02,390 --> 00:47:04,970
What was that?

1120
00:47:04,970 --> 00:47:06,380
Does anyone remember?

1121
00:47:06,380 --> 00:47:08,430
We went to problem session 3.

1122
00:47:08,430 --> 00:47:08,930
Yeah?

1123
00:47:08,930 --> 00:47:09,972
AUDIENCE: Oh.

1124
00:47:09,972 --> 00:47:11,180
I'm probably wrong, this is--

1125
00:47:11,180 --> 00:47:11,420
JASON KU: OK.

1126
00:47:11,420 --> 00:47:12,670
AUDIENCE: --problem session 3.

1127
00:47:12,670 --> 00:47:14,510
But like q dq type stuff?

1128
00:47:14,510 --> 00:47:17,330
JASON KU: So q dq,
those are talking

1129
00:47:17,330 --> 00:47:20,210
about doubly-ended things.

1130
00:47:20,210 --> 00:47:23,750
Those are implemented in a
certain way, which is actually

1131
00:47:23,750 --> 00:47:24,680
one of these things.

1132
00:47:24,680 --> 00:47:28,880
It's actually, I think,
this one in Python.

1133
00:47:28,880 --> 00:47:32,330
But there's --a we used a
different data structure

1134
00:47:32,330 --> 00:47:35,810
to get something that
had really good at.

1135
00:47:35,810 --> 00:47:38,960
It had really good
pop and append

1136
00:47:38,960 --> 00:47:41,820
and first and last
dynamic operations.

1137
00:47:41,820 --> 00:47:44,240
Do you --guys anyone
remember from session 3?

1138
00:47:47,635 --> 00:47:49,090
AUDIENCE: [INAUDIBLE]

1139
00:47:49,090 --> 00:47:52,000
AUDIENCE: Isn't it
dynamic array [INAUDIBLE]??

1140
00:47:52,000 --> 00:47:54,790
JASON KU: That's what this was.

1141
00:47:54,790 --> 00:47:55,480
OK.

1142
00:47:55,480 --> 00:47:57,700
We got one that had
expected bounds.

1143
00:47:57,700 --> 00:48:00,640
Does that help?

1144
00:48:00,640 --> 00:48:01,270
What?

1145
00:48:01,270 --> 00:48:04,120
I heard someone say it.

1146
00:48:04,120 --> 00:48:04,770
Hash table.

1147
00:48:04,770 --> 00:48:05,270
Yeah.

1148
00:48:05,270 --> 00:48:09,100
So basically what you
did, instead --of this

1149
00:48:09,100 --> 00:48:10,150
is a sequence thing.

1150
00:48:10,150 --> 00:48:13,300
These things don't have keys.

1151
00:48:13,300 --> 00:48:16,270
But I could identify
with each item

1152
00:48:16,270 --> 00:48:20,727
as I stick it in, a key
representing its index.

1153
00:48:20,727 --> 00:48:22,310
And I could use a
hash table that way.

1154
00:48:22,310 --> 00:48:26,890
Now there was some difficulty
if I removed the first thing.

1155
00:48:30,130 --> 00:48:34,510
Because actually, how
--those are all of my indices

1156
00:48:34,510 --> 00:48:35,710
have now changed.

1157
00:48:35,710 --> 00:48:39,280
But if I just store what the
smallest index in my thing is,

1158
00:48:39,280 --> 00:48:42,160
then I'm golden,
because I can compute

1159
00:48:42,160 --> 00:48:45,890
what that index should be I
change things at the front.

1160
00:48:45,890 --> 00:48:46,390
OK.

1161
00:48:46,390 --> 00:48:48,730
So there's actually
three different ways

1162
00:48:48,730 --> 00:48:51,190
we showed you of getting
constant time at the front

1163
00:48:51,190 --> 00:48:53,570
and the back of this thing.

1164
00:48:53,570 --> 00:48:57,190
So actually, you can think
of that as standard material

1165
00:48:57,190 --> 00:48:59,050
that you can reduce to.

1166
00:48:59,050 --> 00:49:00,790
That's the one
exception of the things

1167
00:49:00,790 --> 00:49:02,720
that I'm not showing
on this chart,

1168
00:49:02,720 --> 00:49:05,290
but is a bonus if you're
watching this problem session.

1169
00:49:05,290 --> 00:49:05,950
Yeah?

1170
00:49:05,950 --> 00:49:08,890
AUDIENCE: So isn't a hash table
a set data structure, though?

1171
00:49:08,890 --> 00:49:09,850
JASON KU: It is.

1172
00:49:09,850 --> 00:49:12,800
But we used it to implement
a sequenced data structure.

1173
00:49:12,800 --> 00:49:15,730
So I will refer you to
that problem session

1174
00:49:15,730 --> 00:49:18,550
if you want to
learn more about it.

1175
00:49:18,550 --> 00:49:21,090
So, any questions on
sequenced data structures?

1176
00:49:21,090 --> 00:49:21,743
Yeah?

1177
00:49:21,743 --> 00:49:22,630
AUDIENCE: I--

1178
00:49:22,630 --> 00:49:23,890
JASON KU: Yeah, uh huh.

1179
00:49:23,890 --> 00:49:25,420
AUDIENCE: Should
we be-- or-- yeah.

1180
00:49:25,420 --> 00:49:28,930
Should we be able to look prove
the tables that we're given?

1181
00:49:28,930 --> 00:49:32,310
JASON KU: So I would hope--

1182
00:49:32,310 --> 00:49:36,550
hope-- that if I gave you
a blank table, that you

1183
00:49:36,550 --> 00:49:37,960
would be able to fill it out.

1184
00:49:37,960 --> 00:49:40,300
That's how well I
want you to know how

1185
00:49:40,300 --> 00:49:43,090
these things are implemented.

1186
00:49:43,090 --> 00:49:46,120
We're not going to
have that on the exam.

1187
00:49:46,120 --> 00:49:47,650
That's a boring
kind of question.

1188
00:49:47,650 --> 00:49:49,480
AUDIENCE: But it is
important to know?

1189
00:49:49,480 --> 00:49:50,105
JASON KU: Yeah.

1190
00:49:50,105 --> 00:49:53,350
I would-- it's good
for you to think,

1191
00:49:53,350 --> 00:49:56,110
like, oh, if I'm going
to use an AVL tree,

1192
00:49:56,110 --> 00:49:58,360
operations are generally
going to be log n.

1193
00:49:58,360 --> 00:50:00,340
That's a really useful
thing-- or, if I'm

1194
00:50:00,340 --> 00:50:03,850
going to use a hash table,
dictionary-type operations,

1195
00:50:03,850 --> 00:50:07,030
finding, inserting, and
deleting, those are fast.

1196
00:50:07,030 --> 00:50:11,620
Doing order-type operations
on hash tables is bad,

1197
00:50:11,620 --> 00:50:14,110
that's hard to do because
I have to basically look

1198
00:50:14,110 --> 00:50:16,150
through all my things.

1199
00:50:16,150 --> 00:50:19,870
Knowing that dynamic operations
on a sorted array is bad.

1200
00:50:19,870 --> 00:50:26,680
Or knowing that-- you have to
think about here what we mean

1201
00:50:26,680 --> 00:50:29,720
when we say linked list and
dynamic array in this table,

1202
00:50:29,720 --> 00:50:30,220
because--

1203
00:50:30,220 --> 00:50:31,360
AUDIENCE: Singly-linked.

1204
00:50:31,360 --> 00:50:32,360
JASON KU: Yeah, exactly.

1205
00:50:32,360 --> 00:50:34,060
We are implying
singly-linked here

1206
00:50:34,060 --> 00:50:36,340
because that's what we
presented to you in lecture.

1207
00:50:36,340 --> 00:50:37,930
And so those are
the standard things

1208
00:50:37,930 --> 00:50:39,370
that we want you to reduce to.

1209
00:50:39,370 --> 00:50:39,520
Yeah?

1210
00:50:39,520 --> 00:50:41,437
AUDIENCE: --three modified
standard things are

1211
00:50:41,437 --> 00:50:43,330
the doubly-linked lists,
the doubly-ended--

1212
00:50:43,330 --> 00:50:43,955
JASON KU: Yeah.

1213
00:50:43,955 --> 00:50:46,236
Basically you can
assume that you have--

1214
00:50:46,236 --> 00:50:49,390
it's this one that you
probably want to use,

1215
00:50:49,390 --> 00:50:53,710
because you get
constant indexing.

1216
00:50:53,710 --> 00:50:57,580
And then pretty
good on both ends.

1217
00:50:57,580 --> 00:51:00,490
But if you need
a double-ended Q,

1218
00:51:00,490 --> 00:51:04,720
you can also reduce it to having
two dynamic arrays back-to-back

1219
00:51:04,720 --> 00:51:06,440
when going this way,
when going this way.

1220
00:51:06,440 --> 00:51:07,607
And so there's lots of--

1221
00:51:07,607 --> 00:51:09,940
we're not going to give that
to you as a standard method

1222
00:51:09,940 --> 00:51:12,460
because there's literally like
four methods we showed you

1223
00:51:12,460 --> 00:51:13,750
how to do.

1224
00:51:13,750 --> 00:51:14,930
So you choose one.

1225
00:51:14,930 --> 00:51:15,430
OK.

1226
00:51:15,430 --> 00:51:16,030
Yeah?

1227
00:51:16,030 --> 00:51:18,910
AUDIENCE: In the interest
of saving time on the exam,

1228
00:51:18,910 --> 00:51:21,860
if we want to say, like, we do
this thing with the sequence

1229
00:51:21,860 --> 00:51:23,978
AVL and it takes log n time.

1230
00:51:23,978 --> 00:51:26,020
Do we have to say the
sentence like, because this

1231
00:51:26,020 --> 00:51:28,228
is sequence AVL, it takes
a longer time because this?

1232
00:51:28,228 --> 00:51:30,880
Or can we just like say like,
for the table that we know?

1233
00:51:30,880 --> 00:51:33,106
JASON KU: Yeah, no.

1234
00:51:33,106 --> 00:51:35,560
If you told me that you're
storing things in a sequence

1235
00:51:35,560 --> 00:51:38,260
AVL and you just say--

1236
00:51:38,260 --> 00:51:40,900
you basically say what
you do to it, and you say,

1237
00:51:40,900 --> 00:51:42,580
which takes blah,
blah, blah time,

1238
00:51:42,580 --> 00:51:45,760
you don't need to say
because it's a sequence AVL,

1239
00:51:45,760 --> 00:51:47,770
because you already told
us it's a sequence AVL.

1240
00:51:47,770 --> 00:51:50,140
I believe that you
probably wrote the chart

1241
00:51:50,140 --> 00:51:52,910
on your cheat sheet
and you looked it up.

1242
00:51:52,910 --> 00:51:54,550
All right.

1243
00:51:54,550 --> 00:51:55,870
Any other questions on this?

1244
00:51:55,870 --> 00:51:56,470
No.

1245
00:51:56,470 --> 00:51:57,130
Yeah?

1246
00:51:57,130 --> 00:51:59,680
AUDIENCE: Just make sure,
the doubly-linked lists

1247
00:51:59,680 --> 00:52:02,968
will make the insert
on [INAUDIBLE]..

1248
00:52:02,968 --> 00:52:04,820
Is that the only change?

1249
00:52:04,820 --> 00:52:05,735
JASON KU: Yes.

1250
00:52:05,735 --> 00:52:10,550
That doubly-linked list
gives this guy constant time.

1251
00:52:10,550 --> 00:52:13,010
And actually, there are
two operations here,

1252
00:52:13,010 --> 00:52:14,270
insert, delete, and--

1253
00:52:14,270 --> 00:52:17,300
I guess there's a
find here as well.

1254
00:52:17,300 --> 00:52:19,100
If I just store
the tail pointer,

1255
00:52:19,100 --> 00:52:22,130
that gets defined
to constant time.

1256
00:52:22,130 --> 00:52:25,190
but it doesn't get the
dynamic ones to constant time.

1257
00:52:25,190 --> 00:52:27,800
I need to store the previous
pointers as well at each node.

1258
00:52:27,800 --> 00:52:29,220
Does that make sense?

1259
00:52:29,220 --> 00:52:31,880
OK.

1260
00:52:31,880 --> 00:52:36,120
Lastly-- or I guess second to
lastly, set data structures.

1261
00:52:36,120 --> 00:52:38,030
There are a little
bit more of these.

1262
00:52:38,030 --> 00:52:39,170
Not so many more.

1263
00:52:42,150 --> 00:52:44,510
But yeah.

1264
00:52:44,510 --> 00:52:47,600
We had a sorted array, gets
good find, but is not dynamic.

1265
00:52:51,320 --> 00:52:55,010
We set AVL tree which
does pretty good

1266
00:52:55,010 --> 00:52:57,380
find and is dynamic.

1267
00:52:57,380 --> 00:53:02,878
Again, you get this n
log n overhead to build,

1268
00:53:02,878 --> 00:53:05,420
because essentially what you're
doing with both of those data

1269
00:53:05,420 --> 00:53:07,260
structures is to sort.

1270
00:53:07,260 --> 00:53:12,080
But if I'm looking
on a theory question,

1271
00:53:12,080 --> 00:53:13,520
like I'm not asking
you something

1272
00:53:13,520 --> 00:53:16,370
specifically about a
sorted array, if you

1273
00:53:16,370 --> 00:53:19,880
have a choice between this
data structure and this data

1274
00:53:19,880 --> 00:53:21,440
structure, which
one do you choose?

1275
00:53:25,620 --> 00:53:27,620
Well, I don't quite
know, because it's

1276
00:53:27,620 --> 00:53:32,510
almost like this one's better at
everything except for this one.

1277
00:53:32,510 --> 00:53:35,245
But can anyone tell me how to
make this one constant time

1278
00:53:35,245 --> 00:53:37,400
as well?

1279
00:53:37,400 --> 00:53:38,420
Augmentation.

1280
00:53:38,420 --> 00:53:43,040
I could just store in my
subtrees the max or min.

1281
00:53:43,040 --> 00:53:45,790
And I can make this one
strictly better than this one.

1282
00:53:45,790 --> 00:53:47,807
So in theory
problem, you probably

1283
00:53:47,807 --> 00:53:48,890
just want to use this one.

1284
00:53:51,410 --> 00:53:54,320
Here, hash tables,
direct access arrays,

1285
00:53:54,320 --> 00:53:56,600
even better for
these operations.

1286
00:53:56,600 --> 00:53:57,830
That's great.

1287
00:53:57,830 --> 00:53:59,750
But they suck at these.

1288
00:53:59,750 --> 00:54:02,720
So if you need these,
don't use these.

1289
00:54:02,720 --> 00:54:05,480
And in actual coding,
especially if you're

1290
00:54:05,480 --> 00:54:08,360
coding in a language that's not
Python, something that doesn't

1291
00:54:08,360 --> 00:54:10,070
automatically give
you a hash table,

1292
00:54:10,070 --> 00:54:14,450
if you're in C in a
microcontroller lab at MIT

1293
00:54:14,450 --> 00:54:18,170
here, you're taking
6115 or whatever,

1294
00:54:18,170 --> 00:54:21,290
and you're doing assembly,
usually what you're doing

1295
00:54:21,290 --> 00:54:23,600
is a direct access stuff.

1296
00:54:23,600 --> 00:54:26,180
Because that's
giving you the jumps

1297
00:54:26,180 --> 00:54:27,740
that you need in
machine language

1298
00:54:27,740 --> 00:54:30,510
to actually go and access
this in constant time.

1299
00:54:30,510 --> 00:54:32,960
That's generally if you
have control over the keys

1300
00:54:32,960 --> 00:54:33,950
that you're putting--

1301
00:54:33,950 --> 00:54:35,870
that you are putting
in your data structure,

1302
00:54:35,870 --> 00:54:38,515
you don't want this
overhead of running

1303
00:54:38,515 --> 00:54:39,890
your keys through
a hash function

1304
00:54:39,890 --> 00:54:40,940
to look these things up.

1305
00:54:40,940 --> 00:54:44,990
You just store the
things in an array.

1306
00:54:44,990 --> 00:54:47,960
You use the hash
table when you don't

1307
00:54:47,960 --> 00:54:49,880
have control over
the keys or your keys

1308
00:54:49,880 --> 00:54:52,767
are like strings or something.

1309
00:54:52,767 --> 00:54:54,350
So that's when you
use the hash table.

1310
00:54:54,350 --> 00:54:58,215
Now for our purposes,
usually a hash table

1311
00:54:58,215 --> 00:54:59,840
is just as good unless
we're asking you

1312
00:54:59,840 --> 00:55:02,690
for worst case bounds.

1313
00:55:02,690 --> 00:55:05,738
And we're going to do this
when we talk about the data

1314
00:55:05,738 --> 00:55:06,530
structures problem.

1315
00:55:06,530 --> 00:55:12,050
If we give you a situation where
we don't care if you achieve

1316
00:55:12,050 --> 00:55:13,760
worst case are
expected or amortized

1317
00:55:13,760 --> 00:55:15,177
or any of these
things, we'll just

1318
00:55:15,177 --> 00:55:19,760
say, make sure you state
which one you achieve.

1319
00:55:19,760 --> 00:55:22,310
And as long as you analyzed
it correctly with respect

1320
00:55:22,310 --> 00:55:25,430
to your data structures,
then you're fine.

1321
00:55:25,430 --> 00:55:27,930
But if we say you better
do worst case here,

1322
00:55:27,930 --> 00:55:29,930
I'm going to slap you around.

1323
00:55:29,930 --> 00:55:32,930
Then please get those bounds.

1324
00:55:32,930 --> 00:55:36,710
Don't use the hash
table in that case.

1325
00:55:36,710 --> 00:55:38,330
That makes sense?

1326
00:55:38,330 --> 00:55:40,640
OK.

1327
00:55:40,640 --> 00:55:43,872
Lastly, we've got priority
queues which we talked about.

1328
00:55:43,872 --> 00:55:45,830
I'm not going to go
through this one very much.

1329
00:55:45,830 --> 00:55:49,760
It's basically just
adding this to the thing.

1330
00:55:49,760 --> 00:55:52,400
But in actuality, you can
get all of these bounds

1331
00:55:52,400 --> 00:55:55,190
with a set AVL--

1332
00:55:55,190 --> 00:55:59,153
I mean a sequence AVL tree
with max or min augmentation,

1333
00:55:59,153 --> 00:56:01,820
which isn't on this list because
we didn't really talk about it,

1334
00:56:01,820 --> 00:56:04,490
but hopefully you can--

1335
00:56:04,490 --> 00:56:07,850
if you need these bounds
without the amortization,

1336
00:56:07,850 --> 00:56:10,980
then you could achieve them.

1337
00:56:10,980 --> 00:56:11,480
All right.

1338
00:56:11,480 --> 00:56:13,700
So that's basically
everything that we've

1339
00:56:13,700 --> 00:56:15,913
talked about in the class.

1340
00:56:15,913 --> 00:56:18,330
We're going to spend the rest
of the time working a couple

1341
00:56:18,330 --> 00:56:19,460
of data structures problem.

1342
00:56:19,460 --> 00:56:23,030
I'm not-- there's a number of
different types of questions

1343
00:56:23,030 --> 00:56:27,980
you'll actually
see on the quiz--

1344
00:56:27,980 --> 00:56:30,530
the practice quiz that we
gave you from last term.

1345
00:56:30,530 --> 00:56:33,500
There are some what I call
mechanical-type questions up

1346
00:56:33,500 --> 00:56:35,300
at the front.

1347
00:56:35,300 --> 00:56:37,940
Then usually some
reduction-type problems

1348
00:56:37,940 --> 00:56:40,490
where you're reducing to
using some sorting algorithms

1349
00:56:40,490 --> 00:56:41,720
or some data structures.

1350
00:56:41,720 --> 00:56:43,850
And then usually
the latter ones are

1351
00:56:43,850 --> 00:56:46,790
ones where you have to do some
kind of something additional,

1352
00:56:46,790 --> 00:56:50,070
like some augmentation or
some divide and conquer

1353
00:56:50,070 --> 00:56:51,920
or something like that.

1354
00:56:51,920 --> 00:56:53,480
OK.

1355
00:56:53,480 --> 00:56:55,460
So we're going to
go ahead and spend

1356
00:56:55,460 --> 00:56:59,390
the rest of the time working
a couple of these problems.

1357
00:56:59,390 --> 00:57:04,520
These were from spring
of 2019 on the exam.

1358
00:57:04,520 --> 00:57:09,260
And actually, one of the
TAs who's TAing for us

1359
00:57:09,260 --> 00:57:12,020
now was also TAing
for us in spring 2019.

1360
00:57:12,020 --> 00:57:13,970
Was grading problem
number 2 here,

1361
00:57:13,970 --> 00:57:16,370
the rainy research
problem, and just hated me,

1362
00:57:16,370 --> 00:57:18,590
because no one did it right.

1363
00:57:18,590 --> 00:57:19,520
All right.

1364
00:57:19,520 --> 00:57:23,120
So, let's try to
solve these problems.

1365
00:57:23,120 --> 00:57:28,730
So problem 1 is
about restaurant--

1366
00:57:28,730 --> 00:57:31,880
restaurant, yes, OK.

1367
00:57:31,880 --> 00:57:32,748
All right.

1368
00:57:32,748 --> 00:57:34,040
So basically, what's happening?

1369
00:57:34,040 --> 00:57:38,150
A popular restaurant,
Criminal Seafood.

1370
00:57:38,150 --> 00:57:39,830
What's the reference?

1371
00:57:39,830 --> 00:57:40,580
Legal Seafood.

1372
00:57:40,580 --> 00:57:41,750
Yes, opposite.

1373
00:57:41,750 --> 00:57:44,360
Does not take reservations,
but maintains a wait list

1374
00:57:44,360 --> 00:57:47,010
where customers who have
been on the wait list longer

1375
00:57:47,010 --> 00:57:48,590
are seated earlier.

1376
00:57:48,590 --> 00:57:50,830
Sometimes customers decide
to eat somewhere else,

1377
00:57:50,830 --> 00:57:53,030
so restaurant must remove
them from the wait list.

1378
00:57:53,030 --> 00:57:54,620
OK.

1379
00:57:54,620 --> 00:57:57,710
Assume that a customer
has a different name.

1380
00:57:57,710 --> 00:58:00,320
No two customers are
added to the wait list

1381
00:58:00,320 --> 00:58:01,880
at the exact same time.

1382
00:58:01,880 --> 00:58:04,550
So there's a kind of an
ordering at which people are

1383
00:58:04,550 --> 00:58:06,060
being added to this wait list.

1384
00:58:06,060 --> 00:58:07,430
Does that makes sense?

1385
00:58:07,430 --> 00:58:09,770
Design a database to help
Criminals Seafood maintain

1386
00:58:09,770 --> 00:58:11,510
its wait lists
supporting the following

1387
00:58:11,510 --> 00:58:13,460
operations, each
in constant time.

1388
00:58:13,460 --> 00:58:18,590
OK, so here, we've refactored
the running time up to the top.

1389
00:58:18,590 --> 00:58:20,090
And it's a-- oh, sorry.

1390
00:58:20,090 --> 00:58:21,692
I added the build here.

1391
00:58:21,692 --> 00:58:23,150
I guess that's
still constant time.

1392
00:58:23,150 --> 00:58:23,840
That's fine, OK.

1393
00:58:23,840 --> 00:58:24,680
AUDIENCE: I have time d--

1394
00:58:24,680 --> 00:58:25,305
JASON KU: Yeah.

1395
00:58:25,305 --> 00:58:29,450
State whether each running
time operation is worst case,

1396
00:58:29,450 --> 00:58:30,480
amortized, expected.

1397
00:58:30,480 --> 00:58:33,260
So, when you see that
statement, you're saying, OK,

1398
00:58:33,260 --> 00:58:37,580
I'm allowed to use a
hash table if I want to.

1399
00:58:37,580 --> 00:58:39,860
I just have to make
sure if I use one,

1400
00:58:39,860 --> 00:58:44,900
I label my operations expected
and amortized when they occur.

1401
00:58:44,900 --> 00:58:46,580
Which operations are expected?

1402
00:58:46,580 --> 00:58:47,840
Basically all of them.

1403
00:58:47,840 --> 00:58:49,490
Which operations are amortized?

1404
00:58:49,490 --> 00:58:52,790
The ones that changed what's
in the data structure, insert,

1405
00:58:52,790 --> 00:58:54,260
delete.

1406
00:58:54,260 --> 00:58:54,890
OK.

1407
00:58:54,890 --> 00:58:58,370
So we've got some operations,
building an empty thing.

1408
00:58:58,370 --> 00:59:02,330
Adding a name-- so this name is
x to the back of the wait list.

1409
00:59:02,330 --> 00:59:03,530
What do I know about x?

1410
00:59:03,530 --> 00:59:06,350
What do I know about the
names per our assumptions

1411
00:59:06,350 --> 00:59:06,980
in this class?

1412
00:59:06,980 --> 00:59:08,690
AUDIENCE: They're unique,
so they can be a key.

1413
00:59:08,690 --> 00:59:10,648
JASON KU: They're unique,
so they can be a key.

1414
00:59:10,648 --> 00:59:14,540
And they fit in a
constant number of words

1415
00:59:14,540 --> 00:59:15,780
by our assumption.

1416
00:59:15,780 --> 00:59:17,920
So I can compare
two of them in--

1417
00:59:17,920 --> 00:59:19,700
or I can hash one
in constant time.

1418
00:59:19,700 --> 00:59:21,950
That's kind of the assumption
we make on these inputs,

1419
00:59:21,950 --> 00:59:23,150
they're strings.

1420
00:59:23,150 --> 00:59:26,060
And I didn't assign you
a bound on their length,

1421
00:59:26,060 --> 00:59:29,690
so it's probably not something
you need to worry about.

1422
00:59:29,690 --> 00:59:33,110
OK remove a name.

1423
00:59:33,110 --> 00:59:35,720
So already I'm
feeling like, I need

1424
00:59:35,720 --> 00:59:39,230
to be able to find
things by their name.

1425
00:59:39,230 --> 00:59:40,400
OK.

1426
00:59:40,400 --> 00:59:43,220
And then seat the
next person in line.

1427
00:59:43,220 --> 00:59:44,610
Does that makes sense?

1428
00:59:44,610 --> 00:59:47,360
So what kinds of things do
I need to maintain here?

1429
00:59:47,360 --> 00:59:49,850
I have people.

1430
00:59:49,850 --> 00:59:53,090
They have names and they
have kind of places,

1431
00:59:53,090 --> 00:59:55,340
the time that they came in.

1432
00:59:55,340 --> 00:59:56,555
But am I given the times?

1433
00:59:59,880 --> 01:00:01,020
No.

1434
01:00:01,020 --> 01:00:02,820
I'm not given times anywhere.

1435
01:00:02,820 --> 01:00:05,710
It's not on the inputs
to my operations.

1436
01:00:05,710 --> 01:00:08,560
So it's not like I'm going
to be able to key on time.

1437
01:00:08,560 --> 01:00:09,270
That makes sense?

1438
01:00:09,270 --> 01:00:12,000
What's the important
part about the times?

1439
01:00:12,000 --> 01:00:12,547
The order.

1440
01:00:12,547 --> 01:00:13,880
AUDIENCE: And you're given that.

1441
01:00:13,880 --> 01:00:14,505
JASON KU: Yeah.

1442
01:00:14,505 --> 01:00:17,670
Basically whenever--
I'm basically

1443
01:00:17,670 --> 01:00:20,160
trying to maintain a
sequence on these guys.

1444
01:00:20,160 --> 01:00:23,797
There's a front one and a back
one and people in the middle.

1445
01:00:23,797 --> 01:00:25,880
And I want to make sure
that order stays the same,

1446
01:00:25,880 --> 01:00:27,880
or else people are going
to getting angry at me,

1447
01:00:27,880 --> 01:00:31,390
because ah, they came here
after me and I got a--

1448
01:00:31,390 --> 01:00:32,970
yeah.

1449
01:00:32,970 --> 01:00:34,720
You've been in that situation.

1450
01:00:34,720 --> 01:00:35,280
OK.

1451
01:00:35,280 --> 01:00:38,220
So, we're trying to maintain
some kind of sequence,

1452
01:00:38,220 --> 01:00:41,550
an extrinsic order
on these things.

1453
01:00:41,550 --> 01:00:44,250
But we're also needing to
be able to look up people

1454
01:00:44,250 --> 01:00:47,640
by their name because I want to
be able to change this thing.

1455
01:00:47,640 --> 01:00:51,000
Does this maybe sound familiar
to some other problem we had

1456
01:00:51,000 --> 01:00:54,990
on this term's problem sets?

1457
01:00:54,990 --> 01:00:58,600
Yeah, I think there
was a problem where--

1458
01:00:58,600 --> 01:00:59,640
AUDIENCE: The chat.

1459
01:00:59,640 --> 01:01:00,900
JASON KU: The chat.

1460
01:01:00,900 --> 01:01:03,090
You had to store a sequence.

1461
01:01:03,090 --> 01:01:06,120
But you also had this dictionary
that you had to look things up.

1462
01:01:06,120 --> 01:01:11,670
Now the nice thing
about that situation

1463
01:01:11,670 --> 01:01:14,940
is that the things that
you needed to look up on

1464
01:01:14,940 --> 01:01:16,530
was static.

1465
01:01:16,530 --> 01:01:18,870
And so what could I
use for my dictionary,

1466
01:01:18,870 --> 01:01:22,320
my sets data structure for that?

1467
01:01:22,320 --> 01:01:25,290
Anyone remember?

1468
01:01:25,290 --> 01:01:26,970
You could just use
a sorted array.

1469
01:01:26,970 --> 01:01:28,770
Because it's
static, these things

1470
01:01:28,770 --> 01:01:32,010
aren't updating all the time,
and so it was fine for me

1471
01:01:32,010 --> 01:01:34,290
to just use a static array.

1472
01:01:34,290 --> 01:01:39,450
Here-- and we gave
you lookup times that

1473
01:01:39,450 --> 01:01:41,610
were worst case logarithmic.

1474
01:01:41,610 --> 01:01:43,200
Here, I'm asking
for constant time.

1475
01:01:45,600 --> 01:01:47,100
Sorted array is not
going to cut it,

1476
01:01:47,100 --> 01:01:49,638
set AVL's not going to cut
it, so what am I going to use?

1477
01:01:49,638 --> 01:01:50,430
AUDIENCE: Dynamic--

1478
01:01:50,430 --> 01:01:52,650
JASON KU: A dynamic
array or a hash table.

1479
01:01:52,650 --> 01:01:55,980
Now dynamic array might not be
great because I don't actually

1480
01:01:55,980 --> 01:01:58,590
have a numeric bound on
how big these keys are,

1481
01:01:58,590 --> 01:02:01,260
I just know that
they fit in words.

1482
01:02:01,260 --> 01:02:03,900
So I can't actually make
a direct access array

1483
01:02:03,900 --> 01:02:05,125
because those words--

1484
01:02:05,125 --> 01:02:07,000
while they fit in a
constant number of words,

1485
01:02:07,000 --> 01:02:09,390
I don't know if the integer
representation of those

1486
01:02:09,390 --> 01:02:11,820
are polynomial-bounded.

1487
01:02:11,820 --> 01:02:13,200
Does that make sense?

1488
01:02:13,200 --> 01:02:16,043
So I do want to use
hashing in this case.

1489
01:02:16,043 --> 01:02:17,460
And so what do I
want to maintain?

1490
01:02:17,460 --> 01:02:30,180
I want to maintain a sequence
data structure on customers.

1491
01:02:30,180 --> 01:02:31,620
Customers.

1492
01:02:31,620 --> 01:02:33,060
Is there a U in there somewhere?

1493
01:02:33,060 --> 01:02:33,560
No.

1494
01:02:33,560 --> 01:02:34,620
This is right, right?

1495
01:02:34,620 --> 01:02:35,120
OK.

1496
01:02:35,120 --> 01:02:41,170
And a set mapping.

1497
01:02:41,170 --> 01:02:42,780
So this is usually how I do it.

1498
01:02:42,780 --> 01:02:46,380
Like I want to say a
set keyed on something.

1499
01:02:46,380 --> 01:02:49,020
If it's just a set,
then I just have it key.

1500
01:02:49,020 --> 01:02:51,150
I can look up whether that
thing is there or not.

1501
01:02:51,150 --> 01:02:55,140
But when I'm actually having
it mapped to something else,

1502
01:02:55,140 --> 01:03:00,120
I'll say, mapping a key, space,
to something else, usually

1503
01:03:00,120 --> 01:03:02,010
the item that I'm
storing or maybe

1504
01:03:02,010 --> 01:03:04,380
some property of the
items that I'm storing.

1505
01:03:04,380 --> 01:03:05,620
Does that make sense?

1506
01:03:05,620 --> 01:03:06,120
OK.

1507
01:03:06,120 --> 01:03:09,140
So mapping, what do I map here?

1508
01:03:09,140 --> 01:03:09,640
Names.

1509
01:03:13,380 --> 01:03:15,348
To-- oh.

1510
01:03:15,348 --> 01:03:16,320
To what?

1511
01:03:16,320 --> 01:03:18,438
Do I want to map?

1512
01:03:18,438 --> 01:03:20,558
AUDIENCE: To time--

1513
01:03:20,558 --> 01:03:21,350
JASON KU: The time.

1514
01:03:21,350 --> 01:03:23,690
The time that they entered.

1515
01:03:23,690 --> 01:03:24,921
Do I want to do that?

1516
01:03:24,921 --> 01:03:27,350
AUDIENCE: Well, you can't
exactly do it with the time

1517
01:03:27,350 --> 01:03:29,517
that they entered, but the
sequence on the customers

1518
01:03:29,517 --> 01:03:30,895
will show what's next in line.

1519
01:03:30,895 --> 01:03:31,520
JASON KU: Yeah.

1520
01:03:31,520 --> 01:03:35,570
I want to store it to where
it is in this sequence.

1521
01:03:35,570 --> 01:03:38,450
So I'll just store the index
where it is in the sequence

1522
01:03:38,450 --> 01:03:39,620
and I can just look it up.

1523
01:03:39,620 --> 01:03:43,177
That's sounds-- yeah?

1524
01:03:43,177 --> 01:03:43,760
Is that what--

1525
01:03:43,760 --> 01:03:45,560
AUDIENCE: I thought
the indices change.

1526
01:03:45,560 --> 01:03:46,185
JASON KU: Yeah.

1527
01:03:46,185 --> 01:03:48,380
Indices change every time
I add or remove things.

1528
01:03:48,380 --> 01:03:49,550
AUDIENCE: [INAUDIBLE]

1529
01:03:49,550 --> 01:03:50,390
JASON KU: Ah, yeah.

1530
01:03:50,390 --> 01:03:53,270
Store a pointer.

1531
01:03:53,270 --> 01:04:00,740
Pointer to place in sequence.

1532
01:04:00,740 --> 01:04:04,520
Now, that's a
little weird to say,

1533
01:04:04,520 --> 01:04:09,500
because I haven't told you how
I represented this sequence.

1534
01:04:09,500 --> 01:04:13,790
But conceptually I can
say I'm drawing a pointer

1535
01:04:13,790 --> 01:04:15,470
to someplace in
this that represents

1536
01:04:15,470 --> 01:04:19,700
where it is, I'll deal with
the details of that later.

1537
01:04:19,700 --> 01:04:22,580
But generally I call this
a linked data structure,

1538
01:04:22,580 --> 01:04:26,780
because I'm linking
between two data structures

1539
01:04:26,780 --> 01:04:30,380
so that I can do a query in one,
say, and find out where it is

1540
01:04:30,380 --> 01:04:31,970
and the other.

1541
01:04:31,970 --> 01:04:36,140
Or do a query in the
other, that kind of thing.

1542
01:04:36,140 --> 01:04:39,990
So, everyone kind of understand
why I chose these things?

1543
01:04:39,990 --> 01:04:41,240
How I approached this problem?

1544
01:04:41,240 --> 01:04:42,020
Yeah?

1545
01:04:42,020 --> 01:04:46,430
AUDIENCE: I'm not sure how
a pointer fixes the problem

1546
01:04:46,430 --> 01:04:49,820
of just storing an index.

1547
01:04:49,820 --> 01:04:53,880
The place that a person
is at in the sequence

1548
01:04:53,880 --> 01:04:55,260
is going to change over time.

1549
01:04:55,260 --> 01:04:55,560
JASON KU: Mm-hmm.

1550
01:04:55,560 --> 01:04:57,852
AUDIENCE: --assuming that a
pointer updates, would that

1551
01:04:57,852 --> 01:04:58,570
change?

1552
01:04:58,570 --> 01:04:59,340
JASON KU: So-- OK.

1553
01:04:59,340 --> 01:05:03,850
So let's say if every time--

1554
01:05:03,850 --> 01:05:05,190
so let's say I'm storing--

1555
01:05:05,190 --> 01:05:07,410
let's say I'm storing this
sequence in a linked list,

1556
01:05:07,410 --> 01:05:09,120
let's just say,
because I know that I'm

1557
01:05:09,120 --> 01:05:11,162
going to have to be
inserting and deleting things

1558
01:05:11,162 --> 01:05:12,860
from the middle of this thing.

1559
01:05:12,860 --> 01:05:13,840
Does that make sense?

1560
01:05:13,840 --> 01:05:14,340
All right.

1561
01:05:14,340 --> 01:05:16,920
So I'm going to go
ahead and say that this

1562
01:05:16,920 --> 01:05:19,050
is going to be a linked list.

1563
01:05:19,050 --> 01:05:21,165
Now I have this linked list.

1564
01:05:24,930 --> 01:05:30,900
So if I said, all right, the
set data structure in my set

1565
01:05:30,900 --> 01:05:32,520
stores--

1566
01:05:32,520 --> 01:05:36,272
or stores where it is
in the linked list,

1567
01:05:36,272 --> 01:05:41,980
let's say it's stored
at k, all right?

1568
01:05:41,980 --> 01:05:43,620
Cool.

1569
01:05:43,620 --> 01:05:51,750
Now if I seat this guy,
I stick him at his table,

1570
01:05:51,750 --> 01:05:54,180
every index has changed.

1571
01:05:54,180 --> 01:05:57,870
So for me to update the
indices stored in this set data

1572
01:05:57,870 --> 01:06:00,545
structure, I have to change
every single one of them.

1573
01:06:00,545 --> 01:06:01,170
AUDIENCE: Yeah.

1574
01:06:01,170 --> 01:06:02,100
JASON KU: Does that make sense?

1575
01:06:02,100 --> 01:06:04,000
AUDIENCE: Yeah, no, this
makes way more sense.

1576
01:06:04,000 --> 01:06:04,625
JASON KU: Yeah.

1577
01:06:04,625 --> 01:06:07,290
So really what I want, not
to store a number here,

1578
01:06:07,290 --> 01:06:09,330
but an actual pointer
to the node that's

1579
01:06:09,330 --> 01:06:12,540
containing this thing,
because the node

1580
01:06:12,540 --> 01:06:16,380
isn't changing unless that
thing left my data structure.

1581
01:06:16,380 --> 01:06:20,340
The node, the address of this
thing in memory, the node

1582
01:06:20,340 --> 01:06:22,500
is just a little
container that contains

1583
01:06:22,500 --> 01:06:25,110
an item and the next
pointer, and actually we're

1584
01:06:25,110 --> 01:06:28,900
going to need a
previous pointer here.

1585
01:06:28,900 --> 01:06:31,800
We're going to need
a doubly-linked list.

1586
01:06:31,800 --> 01:06:34,440
Because what we're going to
do when we remove something,

1587
01:06:34,440 --> 01:06:36,750
we need to stitch
it back together

1588
01:06:36,750 --> 01:06:38,820
in constant time,
which means we need

1589
01:06:38,820 --> 01:06:42,720
to know what's the one in front
of us and the one behind us.

1590
01:06:42,720 --> 01:06:43,395
Yeah?

1591
01:06:43,395 --> 01:06:44,470
No?

1592
01:06:44,470 --> 01:06:44,970
All right.

1593
01:06:44,970 --> 01:06:47,230
So linked list here.

1594
01:06:47,230 --> 01:06:49,500
We already said maybe
using a hash table here.

1595
01:06:54,030 --> 01:06:56,850
And so, OK, great.

1596
01:06:56,850 --> 01:07:00,690
This is basically
enough for me to say,

1597
01:07:00,690 --> 01:07:03,500
this is my data structure,
these are the invariants.

1598
01:07:03,500 --> 01:07:04,500
What are the invariants?

1599
01:07:04,500 --> 01:07:07,230
It's storing all the customers.

1600
01:07:07,230 --> 01:07:08,220
That's an invariant.

1601
01:07:08,220 --> 01:07:10,860
I mean, it's not a very
strong invariant, but it's--

1602
01:07:10,860 --> 01:07:13,260
yeah, I mean, I should say that.

1603
01:07:13,260 --> 01:07:15,090
I'm storing all the
customers because I'm

1604
01:07:15,090 --> 01:07:17,730
going to have to make sure
that I'm maintaining that when

1605
01:07:17,730 --> 01:07:19,770
I do a query.

1606
01:07:19,770 --> 01:07:24,450
And then here, set
mapping names to pointers.

1607
01:07:24,450 --> 01:07:26,940
The place in this thing.

1608
01:07:26,940 --> 01:07:29,520
And as I remove things,
I need to make sure

1609
01:07:29,520 --> 01:07:31,620
that invariant stays the same.

1610
01:07:31,620 --> 01:07:33,810
It's still mapping all
the names of customers

1611
01:07:33,810 --> 01:07:37,560
that I have in my
thing to their nodes.

1612
01:07:37,560 --> 01:07:39,810
So when something
leaves, I better

1613
01:07:39,810 --> 01:07:43,320
need to make sure that both
of these things are updated.

1614
01:07:43,320 --> 01:07:44,320
Does that make sense?

1615
01:07:44,320 --> 01:07:44,820
OK.

1616
01:07:44,820 --> 01:07:47,790
So how do I maintain
these operations?

1617
01:07:47,790 --> 01:07:50,400
We've got a build--

1618
01:07:50,400 --> 01:07:53,910
build just sets up
empty of these things.

1619
01:07:53,910 --> 01:07:56,010
It's easier to say that.

1620
01:07:56,010 --> 01:07:59,610
I build an empty linked
list, doubly-linked lists

1621
01:07:59,610 --> 01:08:04,080
on the customers,
and I build a set--

1622
01:08:04,080 --> 01:08:07,740
a hash table mapping nothing
to nothing right now.

1623
01:08:07,740 --> 01:08:08,430
OK.

1624
01:08:08,430 --> 01:08:10,410
So that's build.

1625
01:08:10,410 --> 01:08:13,080
I'm going to be precise
here and actually

1626
01:08:13,080 --> 01:08:18,870
write down the thing
because I told you not

1627
01:08:18,870 --> 01:08:21,510
to ignore a
operation, or else we

1628
01:08:21,510 --> 01:08:23,850
can't give you points for it.

1629
01:08:23,850 --> 01:08:24,957
The next one-- yeah?

1630
01:08:24,957 --> 01:08:27,374
AUDIENCE: By emptying-- by
building an empty linked list--

1631
01:08:27,374 --> 01:08:28,109
JASON KU: Mm-hmm.

1632
01:08:28,109 --> 01:08:30,460
AUDIENCE: --it just has
like the head and the tail,

1633
01:08:30,460 --> 01:08:32,652
it's actually none,
but, like, it exists?

1634
01:08:32,652 --> 01:08:33,569
JASON KU: Yeah, right.

1635
01:08:33,569 --> 01:08:35,880
It's a thing in
memory that we store.

1636
01:08:35,880 --> 01:08:38,500
It has a pointer to
a head and a tail.

1637
01:08:38,500 --> 01:08:40,140
Those are none right now.

1638
01:08:40,140 --> 01:08:42,630
But we will add things to it.

1639
01:08:42,630 --> 01:08:43,380
OK.

1640
01:08:43,380 --> 01:08:45,870
So the second one, add name.

1641
01:08:50,910 --> 01:08:52,170
What do we have to say?

1642
01:08:52,170 --> 01:08:54,060
We have to update this
data structure so it

1643
01:08:54,060 --> 01:08:56,580
maintains it's a variance.

1644
01:08:56,580 --> 01:09:00,779
I have to-- usually I
start with one of them.

1645
01:09:00,779 --> 01:09:03,300
I get to a point
where, oh, I really

1646
01:09:03,300 --> 01:09:05,850
should have updated
the other one first.

1647
01:09:05,850 --> 01:09:07,560
So sometimes it's hit or miss.

1648
01:09:07,560 --> 01:09:08,720
What do I want to do here?

1649
01:09:08,720 --> 01:09:12,930
Well, I have no idea where
in this sequence this is.

1650
01:09:12,930 --> 01:09:16,470
So I kind of have
to go here first.

1651
01:09:16,470 --> 01:09:17,760
Oh, sorry.

1652
01:09:17,760 --> 01:09:21,240
Adding a guy, I
could do either way.

1653
01:09:21,240 --> 01:09:23,770
I know-- where is
he going to go?

1654
01:09:23,770 --> 01:09:25,420
End of the list.

1655
01:09:25,420 --> 01:09:27,840
So I just stick it there.

1656
01:09:27,840 --> 01:09:36,689
So add x to end of sequence.

1657
01:09:36,689 --> 01:09:41,370
So I come to a
trick that I like.

1658
01:09:41,370 --> 01:09:43,950
Sequence, set.

1659
01:09:43,950 --> 01:09:44,460
OK.

1660
01:09:44,460 --> 01:09:46,830
In this instance I only have
one sequence and one set.

1661
01:09:46,830 --> 01:09:50,388
And so calling them sequence
and set, probably fine.

1662
01:09:50,388 --> 01:09:51,930
I'm not going to
confuse the greater,

1663
01:09:51,930 --> 01:09:54,480
I'm not going to confuse myself.

1664
01:09:54,480 --> 01:09:56,970
But when I have more
than one of these things,

1665
01:09:56,970 --> 01:10:01,470
or even for brevity on an exam
where I'm time-constrained,

1666
01:10:01,470 --> 01:10:03,690
give these things a name.

1667
01:10:03,690 --> 01:10:08,580
Say this is a sequence
C and M. I don't know.

1668
01:10:08,580 --> 01:10:12,240
I see customer here, I
see a map here, so maybe.

1669
01:10:12,240 --> 01:10:13,350
I don't know.

1670
01:10:13,350 --> 01:10:15,720
But just give them
a letter, then we

1671
01:10:15,720 --> 01:10:17,970
can follow you much more
clearly and you can refer

1672
01:10:17,970 --> 01:10:19,980
to these things more precisely.

1673
01:10:19,980 --> 01:10:25,930
So end of C.

1674
01:10:25,930 --> 01:10:27,940
Then what do we have to do?

1675
01:10:27,940 --> 01:10:30,730
I fix this guy, this guy's good.

1676
01:10:30,730 --> 01:10:32,570
Now I have to fix this guy.

1677
01:10:32,570 --> 01:10:37,600
So I add x to the set and
I map it back to that node

1678
01:10:37,600 --> 01:10:39,160
that I just came from.

1679
01:10:39,160 --> 01:10:41,560
I could store it in
a temporary variable.

1680
01:10:41,560 --> 01:10:59,030
Add x to M pointing
to n node v to v. OK.

1681
01:10:59,030 --> 01:11:00,490
Cool?

1682
01:11:00,490 --> 01:11:08,050
So, I added my x to the end of
C into a node v. I'm kind of--

1683
01:11:08,050 --> 01:11:11,410
I labeled it so I can
reference it later.

1684
01:11:11,410 --> 01:11:15,610
And in code, I would probably
remember what that node was.

1685
01:11:15,610 --> 01:11:19,750
Add x to M pointing
to that node,

1686
01:11:19,750 --> 01:11:21,370
and now I've maintained
my invariant.

1687
01:11:21,370 --> 01:11:21,880
Great.

1688
01:11:21,880 --> 01:11:24,470
AUDIENCE: Maybe [INAUDIBLE].

1689
01:11:24,470 --> 01:11:28,370
JASON KU: Add key x.

1690
01:11:28,370 --> 01:11:35,360
Or add x to M having the
key of x point to that node.

1691
01:11:35,360 --> 01:11:36,330
Does that make sense?

1692
01:11:36,330 --> 01:11:38,750
There's a subtlety there.

1693
01:11:38,750 --> 01:11:43,100
3 3, we have remove--

1694
01:11:43,100 --> 01:11:45,230
I don't remember
the name, whatever.

1695
01:11:45,230 --> 01:11:46,760
OK.

1696
01:11:46,760 --> 01:11:48,590
So here, we have to do--

1697
01:11:48,590 --> 01:11:49,490
order matters.

1698
01:11:49,490 --> 01:11:53,175
I don't know where it
is in the sequence,

1699
01:11:53,175 --> 01:11:54,800
but I'm going to look
it up in the set,

1700
01:11:54,800 --> 01:11:57,920
and I'm going to
remove it from the set,

1701
01:11:57,920 --> 01:12:00,170
and I'm going to look
at whatever it points to

1702
01:12:00,170 --> 01:12:02,180
and remove it from the sequence.

1703
01:12:02,180 --> 01:12:03,930
I'm running out of
time a little bit here,

1704
01:12:03,930 --> 01:12:05,597
so I'm not going to
write all that down.

1705
01:12:05,597 --> 01:12:07,160
You guys understand
what that means.

1706
01:12:07,160 --> 01:12:08,780
Here, we're using
the fact that it's

1707
01:12:08,780 --> 01:12:12,740
a doubly-linked list so that
we can relink things together.

1708
01:12:12,740 --> 01:12:16,260
You don't have to tell
me the three points--

1709
01:12:16,260 --> 01:12:20,840
the previous pointer of my
next thing to the next-- the--

1710
01:12:20,840 --> 01:12:21,375
right?

1711
01:12:21,375 --> 01:12:23,000
You don't have to
tell me how to relink

1712
01:12:23,000 --> 01:12:27,110
those pointers because we did
that already in problem set 1

1713
01:12:27,110 --> 01:12:27,878
or whatever.

1714
01:12:27,878 --> 01:12:30,420
AUDIENCE: Just in general, as
you're in a situation for where

1715
01:12:30,420 --> 01:12:32,342
you're using not a
doubly-linked list--

1716
01:12:32,342 --> 01:12:33,050
JASON KU: Mm-hmm.

1717
01:12:33,050 --> 01:12:34,040
AUDIENCE: where
just a linked list

1718
01:12:34,040 --> 01:12:35,420
would be better than
a doubly linked list

1719
01:12:35,420 --> 01:12:37,220
because it seems like it
always solves problems.

1720
01:12:37,220 --> 01:12:37,845
JASON KU: Yeah.

1721
01:12:37,845 --> 01:12:40,430
Doubly-linked lists is
almost always strictly better

1722
01:12:40,430 --> 01:12:42,380
than a singly-linked
in theory problems.

1723
01:12:42,380 --> 01:12:47,540
So yeah, use it.

1724
01:12:47,540 --> 01:12:48,680
OK.

1725
01:12:48,680 --> 01:12:50,420
And then seat, last one.

1726
01:12:55,090 --> 01:12:59,890
That's just take the
front of the sequence,

1727
01:12:59,890 --> 01:13:03,760
remove it, change
the head around,

1728
01:13:03,760 --> 01:13:06,880
but I get that you
can delete first.

1729
01:13:06,880 --> 01:13:09,350
You're reducing to the
interface that we had.

1730
01:13:09,350 --> 01:13:12,490
You're deleting first
on the sequence.

1731
01:13:12,490 --> 01:13:14,870
But now, we have a situation.

1732
01:13:14,870 --> 01:13:16,360
I deleted the first guy.

1733
01:13:16,360 --> 01:13:19,150
How do I know who
the first guy is?

1734
01:13:19,150 --> 01:13:21,320
Well, I'm storing
its name in there.

1735
01:13:21,320 --> 01:13:23,180
I'm storing the names
of these customers.

1736
01:13:23,180 --> 01:13:27,220
So I know who is at the
front, I look in this set data

1737
01:13:27,220 --> 01:13:29,813
structure, and I
remove that entry.

1738
01:13:29,813 --> 01:13:30,730
Does that makes sense?

1739
01:13:30,730 --> 01:13:34,270
Because now, I no longer need
to maintain where he goes.

1740
01:13:34,270 --> 01:13:38,500
Now in actuality,
I could just not

1741
01:13:38,500 --> 01:13:40,790
update this set data structure.

1742
01:13:40,790 --> 01:13:43,360
But if I do that, then,
well, my running times

1743
01:13:43,360 --> 01:13:45,010
are still linear time.

1744
01:13:45,010 --> 01:13:46,900
I'm not giving you
a bound on space.

1745
01:13:46,900 --> 01:13:50,440
I'm still constant time, sorry.

1746
01:13:50,440 --> 01:13:53,320
So you don't actually
have to do that removal,

1747
01:13:53,320 --> 01:13:56,440
but if that customer
comes back and wants

1748
01:13:56,440 --> 01:14:00,565
to get on the wait list again,
there are things to consider.

1749
01:14:03,710 --> 01:14:04,210
OK.

1750
01:14:04,210 --> 01:14:07,130
So that's that question.

1751
01:14:07,130 --> 01:14:11,500
Next question, last
10 minutes or so.

1752
01:14:11,500 --> 01:14:12,790
Raniy Research.

1753
01:14:12,790 --> 01:14:20,260
This is a problem that
people had nightmares about.

1754
01:14:20,260 --> 01:14:25,330
OK, so basically we've
got a Meather Wan.

1755
01:14:25,330 --> 01:14:26,680
He's a weatherman.

1756
01:14:26,680 --> 01:14:30,850
A scientist who studies
global rainfall.

1757
01:14:30,850 --> 01:14:34,450
And he's got a bunch
of sensors everywhere.

1758
01:14:34,450 --> 01:14:37,540
And each one can post to
the cloud or something

1759
01:14:37,540 --> 01:14:39,910
a measurement that's
of the form a triple

1760
01:14:39,910 --> 01:14:43,150
of integers r, l,
and t where r is

1761
01:14:43,150 --> 01:14:46,690
a positive amount of
rainfall, an integer;

1762
01:14:46,690 --> 01:14:51,470
a latitude, an integer
again; and at a time.

1763
01:14:51,470 --> 01:14:53,150
We got three things
to deal with here.

1764
01:14:53,150 --> 01:14:53,650
Yuck.

1765
01:14:56,478 --> 01:14:57,520
But they're all integers.

1766
01:14:57,520 --> 01:14:59,830
And don't be like,
oh, well Jason,

1767
01:14:59,830 --> 01:15:03,260
latitudes are pretty small.

1768
01:15:03,260 --> 01:15:06,370
So I can assume these
integers are small

1769
01:15:06,370 --> 01:15:09,010
and these things
take constant time.

1770
01:15:09,010 --> 01:15:11,530
I'm not specifying to
you a resolution at which

1771
01:15:11,530 --> 01:15:13,600
I'm measuring these integers.

1772
01:15:13,600 --> 01:15:16,630
And I haven't given you a bound
between what that resolution is

1773
01:15:16,630 --> 01:15:18,790
compared to the number of
measurements that I have,

1774
01:15:18,790 --> 01:15:20,000
so I don't play those games.

1775
01:15:20,000 --> 01:15:21,130
OK.

1776
01:15:21,130 --> 01:15:24,880
The peak rainfall
at a given latitude

1777
01:15:24,880 --> 01:15:29,650
since a particular time
is the maximum rainfall

1778
01:15:29,650 --> 01:15:33,520
at any measurement at that
latitude measured at a time

1779
01:15:33,520 --> 01:15:35,820
greater than or
equal to that time.

1780
01:15:35,820 --> 01:15:37,270
Does that make sense?

1781
01:15:37,270 --> 01:15:39,940
Or 0 if there aren't
measurements at that latitude.

1782
01:15:39,940 --> 01:15:40,690
OK.

1783
01:15:40,690 --> 01:15:44,380
To score after the time-- or
before the time or whatever.

1784
01:15:44,380 --> 01:15:50,110
Describe a database that we
can build it in constant time.

1785
01:15:50,110 --> 01:15:51,100
Is an empty one--

1786
01:15:51,100 --> 01:15:53,020
I added this one
because we weren't

1787
01:15:53,020 --> 01:15:55,810
good about that last spring.

1788
01:15:55,810 --> 01:15:57,250
Record data.

1789
01:15:57,250 --> 01:15:58,810
We give you a triplet.

1790
01:15:58,810 --> 01:16:02,170
And then-- so record data,
for it to be correct,

1791
01:16:02,170 --> 01:16:05,092
I just have to maintain
that information.

1792
01:16:05,092 --> 01:16:07,810
For these kind of
updates, I don't--

1793
01:16:07,810 --> 01:16:11,470
it's really hard for me to argue
that this thing is correct.

1794
01:16:11,470 --> 01:16:12,670
Because I just--

1795
01:16:12,670 --> 01:16:15,130
I throw it at the
database, the database

1796
01:16:15,130 --> 01:16:17,890
doesn't have to give
anything back to me.

1797
01:16:17,890 --> 01:16:20,980
So the important thing
here about correctness

1798
01:16:20,980 --> 01:16:24,255
is that peak rainfall gives
it to me and it gives it to me

1799
01:16:24,255 --> 01:16:25,880
in the time bound
that I'm looking for.

1800
01:16:25,880 --> 01:16:28,030
And peak rainfall is
returning the peak rainfall

1801
01:16:28,030 --> 01:16:31,960
at a particular
latitude since t.

1802
01:16:31,960 --> 01:16:33,790
So we have three things.

1803
01:16:33,790 --> 01:16:34,466
Yep?

1804
01:16:34,466 --> 01:16:35,924
AUDIENCE: Given
that you never have

1805
01:16:35,924 --> 01:16:39,290
to return a single measurement,
is that [INAUDIBLE]

1806
01:16:39,290 --> 01:16:40,413
have a record of it?

1807
01:16:40,413 --> 01:16:42,080
JASON KU: There's the
potential that you

1808
01:16:42,080 --> 01:16:44,600
don't need to store
all of the information

1809
01:16:44,600 --> 01:16:46,880
because all we're
doing is giving you

1810
01:16:46,880 --> 01:16:49,340
back R's, essentially.

1811
01:16:49,340 --> 01:16:52,670
It's possible that you don't
need to store the latitudes

1812
01:16:52,670 --> 01:16:54,380
or times at all.

1813
01:16:54,380 --> 01:16:56,360
You don't even need
to store the triplets.

1814
01:16:56,360 --> 01:17:00,980
Now in reality, I'm querying
on the latitudes and the times.

1815
01:17:00,980 --> 01:17:03,518
So I should store
them somewhere,

1816
01:17:03,518 --> 01:17:05,060
but I might be able
to compress them.

1817
01:17:05,060 --> 01:17:11,540
In particular, many things could
be stored at the same latitude.

1818
01:17:11,540 --> 01:17:13,610
That's kind of the whole
point of the query.

1819
01:17:13,610 --> 01:17:15,500
And so we want--

1820
01:17:15,500 --> 01:17:18,120
I mean, we may only need to
store that latitude once.

1821
01:17:18,120 --> 01:17:19,560
Does that makes sense?

1822
01:17:19,560 --> 01:17:20,060
OK.

1823
01:17:20,060 --> 01:17:21,770
I'm going to wait
for questions until

1824
01:17:21,770 --> 01:17:25,140
after because I want to get
to a solution to this problem.

1825
01:17:25,140 --> 01:17:25,640
All right.

1826
01:17:25,640 --> 01:17:28,030
So what do we need to do?

1827
01:17:28,030 --> 01:17:29,870
We need to be able
to add things.

1828
01:17:29,870 --> 01:17:31,110
And I want to return.

1829
01:17:31,110 --> 01:17:34,125
So return, I'm going to
have to query something,

1830
01:17:34,125 --> 01:17:35,750
and then I'm going
to return something.

1831
01:17:35,750 --> 01:17:40,828
So return peak rainfall at
latitude l since time t.

1832
01:17:40,828 --> 01:17:42,620
What do I care about
in a particular query?

1833
01:17:42,620 --> 01:17:48,860
I only care about all the
things at l, at a latitude l.

1834
01:17:48,860 --> 01:17:52,700
So really, this isn't
such an interesting thing,

1835
01:17:52,700 --> 01:17:55,850
but I want to be able to have
maybe many data structures, one

1836
01:17:55,850 --> 01:17:59,120
associated with each L.
Does that make sense?

1837
01:17:59,120 --> 01:18:05,210
And how can I find
one in each L quickly?

1838
01:18:05,210 --> 01:18:06,210
Put it in a dictionary.

1839
01:18:06,210 --> 01:18:07,370
What's my time bound?

1840
01:18:07,370 --> 01:18:08,650
Worst case log n.

1841
01:18:08,650 --> 01:18:11,430
So what data structure do I use
for that set data structure?

1842
01:18:11,430 --> 01:18:12,710
A set AVL.

1843
01:18:12,710 --> 01:18:17,180
So you're going to
first have a set AVL--

1844
01:18:20,840 --> 01:18:33,500
say, L-- mapping latitudes to--

1845
01:18:33,500 --> 01:18:36,903
well, now we have
more data structures.

1846
01:18:36,903 --> 01:18:38,570
I want to store a lot
of the things that

1847
01:18:38,570 --> 01:18:41,710
have the same latitudes
in another data structure.

1848
01:18:41,710 --> 01:18:45,230
The ones probably
storing the times

1849
01:18:45,230 --> 01:18:47,340
in the rainfalls of
all those measurements.

1850
01:18:47,340 --> 01:18:49,510
Yeah?

1851
01:18:49,510 --> 01:18:50,122
Yeah.

1852
01:18:50,122 --> 01:18:51,080
AUDIENCE: A hash table.

1853
01:18:51,080 --> 01:18:52,038
JASON KU: A hash table.

1854
01:18:52,038 --> 01:18:53,810
OK, so what kinds
of query am I going

1855
01:18:53,810 --> 01:18:57,030
to want to do on the things
at the same latitude?

1856
01:18:57,030 --> 01:18:59,030
AUDIENCE: You're going
to want to get the times.

1857
01:18:59,030 --> 01:19:00,905
JASON KU: I'm going to
want to get the times,

1858
01:19:00,905 --> 01:19:04,520
but more than that, I'm doing
kind of an ordered query.

1859
01:19:04,520 --> 01:19:08,300
I need the things less
than a certain time.

1860
01:19:08,300 --> 01:19:09,077
Greater, sorry.

1861
01:19:09,077 --> 01:19:10,160
AUDIENCE: So it's really--

1862
01:19:10,160 --> 01:19:11,302
JASON KU: Just a second.

1863
01:19:11,302 --> 01:19:13,260
AUDIENCE: Could you do
like an AVL for the time

1864
01:19:13,260 --> 01:19:15,060
and an AVL for the rain?

1865
01:19:15,060 --> 01:19:15,620
JASON KU: OK.

1866
01:19:15,620 --> 01:19:18,290
Do I care about an
AVL for the rain?

1867
01:19:18,290 --> 01:19:22,348
I mean, looking up
on the rainfall.

1868
01:19:22,348 --> 01:19:22,890
AUDIENCE: No.

1869
01:19:22,890 --> 01:19:23,862
JASON KU: No.

1870
01:19:23,862 --> 01:19:25,820
So I'm going to go ahead
and store these things

1871
01:19:25,820 --> 01:19:37,370
in a time-sorted AVL to
mapping latitude l to--

1872
01:19:37,370 --> 01:19:39,860
I'm going to call this
data structure a time data

1873
01:19:39,860 --> 01:19:40,520
structure.

1874
01:19:40,520 --> 01:19:43,430
I'm going to say it's t of l.

1875
01:19:43,430 --> 01:19:44,990
That kind of looks
like a recurrence,

1876
01:19:44,990 --> 01:19:46,280
so it's a little
irking me right now,

1877
01:19:46,280 --> 01:19:47,590
but I don't have
anything better.

1878
01:19:47,590 --> 01:19:48,090
All right.

1879
01:19:48,090 --> 01:19:51,680
So now each one of these
time data structures

1880
01:19:51,680 --> 01:20:08,840
is a set AVL mapping time
to the rainfall measurement.

1881
01:20:08,840 --> 01:20:10,160
All right.

1882
01:20:10,160 --> 01:20:11,450
So that's going to--

1883
01:20:11,450 --> 01:20:15,060
if my query was, return
the peak rainfall--

1884
01:20:15,060 --> 01:20:15,560
sorry.

1885
01:20:15,560 --> 01:20:22,820
Return the rainfall of the thing
with latitude l and time t,

1886
01:20:22,820 --> 01:20:24,350
we'd be done, kind of.

1887
01:20:24,350 --> 01:20:27,500
You'd know how to
support that query.

1888
01:20:27,500 --> 01:20:29,270
To insert things,
I insert things

1889
01:20:29,270 --> 01:20:32,450
into both data structures,
and I just look it up.

1890
01:20:32,450 --> 01:20:34,880
The one complication
here is that I'm not

1891
01:20:34,880 --> 01:20:39,740
asking for what is the
rainfall at a particular time.

1892
01:20:39,740 --> 01:20:44,180
I want to know what the maximum
rainfall is up to this time.

1893
01:20:44,180 --> 01:20:45,200
OK.

1894
01:20:45,200 --> 01:20:49,040
So max heap's good if I
want to know the global max.

1895
01:20:49,040 --> 01:20:54,200
But here, I want to know the
max bounded by a certain range.

1896
01:20:54,200 --> 01:20:56,180
So we're going to--

1897
01:20:56,180 --> 01:20:57,860
you can ask me
questions after this,

1898
01:20:57,860 --> 01:21:00,350
we're running out of
time a little bit.

1899
01:21:00,350 --> 01:21:03,810
So anyone have an idea for how--

1900
01:21:03,810 --> 01:21:04,310
yeah?

1901
01:21:04,310 --> 01:21:06,723
AUDIENCE: Could you just
augment the AVL with the max?

1902
01:21:06,723 --> 01:21:07,265
JASON KU: OK.

1903
01:21:07,265 --> 01:21:08,710
AUDIENCE: And you can just
look at the right child

1904
01:21:08,710 --> 01:21:10,700
and then just look at
the max at that point?

1905
01:21:10,700 --> 01:21:11,408
JASON KU: Ah, OK.

1906
01:21:11,408 --> 01:21:12,920
So what your
colleague is saying,

1907
01:21:12,920 --> 01:21:18,110
if we augment by the
max r in my subtree,

1908
01:21:18,110 --> 01:21:21,800
maybe we can use that to
figure out this query.

1909
01:21:21,800 --> 01:21:24,410
Because we're ordered
on t, right we

1910
01:21:24,410 --> 01:21:28,190
have this nice monotonic
property that everything that's

1911
01:21:28,190 --> 01:21:30,980
going to be in my query--

1912
01:21:30,980 --> 01:21:35,210
everything to the right
of a certain time--

1913
01:21:35,210 --> 01:21:41,700
if my time is above t
at a particular node,

1914
01:21:41,700 --> 01:21:43,260
in everything in
the right subtree

1915
01:21:43,260 --> 01:21:48,870
is also above that t because
of the order of my set's data

1916
01:21:48,870 --> 01:21:51,690
structure, because
I'm ordered on times.

1917
01:21:51,690 --> 01:21:54,240
So there's maybe the
possibility that if I

1918
01:21:54,240 --> 01:21:56,520
look to my right
subtree, I can not

1919
01:21:56,520 --> 01:21:59,910
do work all over
here by just looking

1920
01:21:59,910 --> 01:22:01,980
at the max in that subtree.

1921
01:22:01,980 --> 01:22:15,000
so That's an idea of, let's
say, augmented by subtree max r.

1922
01:22:15,000 --> 01:22:17,290
You probably want to
give this a name as well.

1923
01:22:17,290 --> 01:22:24,840
So like v max where v
is a node in my thing.

1924
01:22:24,840 --> 01:22:28,530
And I want to show how to
support this, how I can compute

1925
01:22:28,530 --> 01:22:29,980
that from its children.

1926
01:22:29,980 --> 01:22:33,690
So how do I actually
support this query,

1927
01:22:33,690 --> 01:22:37,380
I can think of it recursively.

1928
01:22:37,380 --> 01:22:39,400
I have a couple of cases.

1929
01:22:39,400 --> 01:22:44,190
If I'm at a v here, I want to
define a recursive function

1930
01:22:44,190 --> 01:22:52,200
that's called peak rainfall
of a given node lower bounded

1931
01:22:52,200 --> 01:22:52,770
by a t.

1932
01:22:55,920 --> 01:22:59,190
So if I'm here,
there's two cases.

1933
01:22:59,190 --> 01:23:03,885
Either my t, my time is bigger
or smaller-- is in my range

1934
01:23:03,885 --> 01:23:06,690
or out of my range.

1935
01:23:06,690 --> 01:23:08,850
If it's out of my
range, what do I do?

1936
01:23:08,850 --> 01:23:12,120
It's lower than my time bound.

1937
01:23:12,120 --> 01:23:16,140
I can just recursively call
this function on this node.

1938
01:23:16,140 --> 01:23:19,290
Because I know that
anything is going

1939
01:23:19,290 --> 01:23:23,460
to be down here
that I care about.

1940
01:23:23,460 --> 01:23:26,400
And that's just one
recursive call down the tree.

1941
01:23:26,400 --> 01:23:29,490
And so if I only limit myself
to one recursive call down

1942
01:23:29,490 --> 01:23:32,490
the tree, I'm always
going down each time.

1943
01:23:32,490 --> 01:23:34,920
This is going to take
logarithmic time.

1944
01:23:34,920 --> 01:23:37,740
So that's the first case,
that's the easy case.

1945
01:23:37,740 --> 01:23:41,220
This thing is not in range, I
return recursively the thing

1946
01:23:41,220 --> 01:23:42,133
to my right.

1947
01:23:42,133 --> 01:23:43,050
What's the other case?

1948
01:23:43,050 --> 01:23:46,440
I'm in my range.

1949
01:23:46,440 --> 01:23:51,240
Well now I could return,
recursively call both sides.

1950
01:23:51,240 --> 01:23:53,640
Because that's what this
peak is talking about.

1951
01:23:53,640 --> 01:23:55,020
What's my peak rainfall?

1952
01:23:55,020 --> 01:23:57,720
But if I do that, if I
call it here recursively

1953
01:23:57,720 --> 01:24:00,750
and I call it here recursively,
that could take linear time.

1954
01:24:00,750 --> 01:24:03,600
I might touch every
node in my tree.

1955
01:24:03,600 --> 01:24:05,300
So why did I do
this augmentation?

1956
01:24:05,300 --> 01:24:07,800
So I don't have to
do work on this node.

1957
01:24:07,800 --> 01:24:12,780
I just return the maximum
rainfall in this subtree,

1958
01:24:12,780 --> 01:24:15,090
and then recurse on this side.

1959
01:24:15,090 --> 01:24:18,060
So I did constant
work on this side,

1960
01:24:18,060 --> 01:24:19,750
I did one recursive
call down here

1961
01:24:19,750 --> 01:24:21,750
which you could go to the
bottom, but that's OK,

1962
01:24:21,750 --> 01:24:24,863
I can afford to go to
the bottom of the tree.

1963
01:24:24,863 --> 01:24:25,780
Does that makes sense?

1964
01:24:25,780 --> 01:24:29,850
And if I don't have either
subtree, then I'm done.

1965
01:24:29,850 --> 01:24:31,420
If at any time.

1966
01:24:31,420 --> 01:24:33,660
I don't have the node
that I'm supposed

1967
01:24:33,660 --> 01:24:40,500
to recurse on, I take the
max of this subtree, myself,

1968
01:24:40,500 --> 01:24:43,860
and whatever the recursive
return value is here.

1969
01:24:43,860 --> 01:24:47,070
And comparing three values,
returning their max.

1970
01:24:47,070 --> 01:24:48,280
Does that make sense?

1971
01:24:48,280 --> 01:24:48,780
OK.

1972
01:24:48,780 --> 01:24:52,380
So that's what we call
a one-sided range query.

1973
01:24:52,380 --> 01:24:58,260
So in the-- I think problem
session 4 that I didn't get to,

1974
01:24:58,260 --> 01:25:02,100
it shows you a way to do this
for a two-sided range query

1975
01:25:02,100 --> 01:25:05,610
where I need to know the maximum
of all things between two

1976
01:25:05,610 --> 01:25:07,170
things.

1977
01:25:07,170 --> 01:25:09,930
But it's really no more
difficult than this

1978
01:25:09,930 --> 01:25:13,560
to finding a recursive function
that uses an augmentation so

1979
01:25:13,560 --> 01:25:18,210
that you don't have to do
recursive call on both sides.

1980
01:25:18,210 --> 01:25:19,740
Does that makes sense?

1981
01:25:19,740 --> 01:25:21,000
OK.

1982
01:25:21,000 --> 01:25:25,830
That's going to be it for now,
and I can take questions after.

1983
01:25:25,830 --> 01:25:27,740
Thanks for coming.